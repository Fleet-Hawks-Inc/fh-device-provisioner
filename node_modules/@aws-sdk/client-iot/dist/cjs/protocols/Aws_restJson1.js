"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeAws_restJson1DeleteJobCommand = exports.serializeAws_restJson1DeleteDynamicThingGroupCommand = exports.serializeAws_restJson1DeleteDomainConfigurationCommand = exports.serializeAws_restJson1DeleteDimensionCommand = exports.serializeAws_restJson1DeleteCertificateCommand = exports.serializeAws_restJson1DeleteCACertificateCommand = exports.serializeAws_restJson1DeleteBillingGroupCommand = exports.serializeAws_restJson1DeleteAuthorizerCommand = exports.serializeAws_restJson1DeleteAuditSuppressionCommand = exports.serializeAws_restJson1DeleteAccountAuditConfigurationCommand = exports.serializeAws_restJson1CreateTopicRuleDestinationCommand = exports.serializeAws_restJson1CreateTopicRuleCommand = exports.serializeAws_restJson1CreateThingTypeCommand = exports.serializeAws_restJson1CreateThingGroupCommand = exports.serializeAws_restJson1CreateThingCommand = exports.serializeAws_restJson1CreateStreamCommand = exports.serializeAws_restJson1CreateSecurityProfileCommand = exports.serializeAws_restJson1CreateScheduledAuditCommand = exports.serializeAws_restJson1CreateRoleAliasCommand = exports.serializeAws_restJson1CreateProvisioningTemplateVersionCommand = exports.serializeAws_restJson1CreateProvisioningTemplateCommand = exports.serializeAws_restJson1CreateProvisioningClaimCommand = exports.serializeAws_restJson1CreatePolicyVersionCommand = exports.serializeAws_restJson1CreatePolicyCommand = exports.serializeAws_restJson1CreateOTAUpdateCommand = exports.serializeAws_restJson1CreateMitigationActionCommand = exports.serializeAws_restJson1CreateKeysAndCertificateCommand = exports.serializeAws_restJson1CreateJobCommand = exports.serializeAws_restJson1CreateDynamicThingGroupCommand = exports.serializeAws_restJson1CreateDomainConfigurationCommand = exports.serializeAws_restJson1CreateDimensionCommand = exports.serializeAws_restJson1CreateCertificateFromCsrCommand = exports.serializeAws_restJson1CreateBillingGroupCommand = exports.serializeAws_restJson1CreateAuthorizerCommand = exports.serializeAws_restJson1CreateAuditSuppressionCommand = exports.serializeAws_restJson1ConfirmTopicRuleDestinationCommand = exports.serializeAws_restJson1ClearDefaultAuthorizerCommand = exports.serializeAws_restJson1CancelJobExecutionCommand = exports.serializeAws_restJson1CancelJobCommand = exports.serializeAws_restJson1CancelCertificateTransferCommand = exports.serializeAws_restJson1CancelAuditTaskCommand = exports.serializeAws_restJson1CancelAuditMitigationActionsTaskCommand = exports.serializeAws_restJson1AttachThingPrincipalCommand = exports.serializeAws_restJson1AttachSecurityProfileCommand = exports.serializeAws_restJson1AttachPrincipalPolicyCommand = exports.serializeAws_restJson1AttachPolicyCommand = exports.serializeAws_restJson1AssociateTargetsWithJobCommand = exports.serializeAws_restJson1AddThingToThingGroupCommand = exports.serializeAws_restJson1AddThingToBillingGroupCommand = exports.serializeAws_restJson1AcceptCertificateTransferCommand = void 0;
exports.serializeAws_restJson1DetachSecurityProfileCommand = exports.serializeAws_restJson1DetachPrincipalPolicyCommand = exports.serializeAws_restJson1DetachPolicyCommand = exports.serializeAws_restJson1DescribeThingTypeCommand = exports.serializeAws_restJson1DescribeThingRegistrationTaskCommand = exports.serializeAws_restJson1DescribeThingGroupCommand = exports.serializeAws_restJson1DescribeThingCommand = exports.serializeAws_restJson1DescribeStreamCommand = exports.serializeAws_restJson1DescribeSecurityProfileCommand = exports.serializeAws_restJson1DescribeScheduledAuditCommand = exports.serializeAws_restJson1DescribeRoleAliasCommand = exports.serializeAws_restJson1DescribeProvisioningTemplateVersionCommand = exports.serializeAws_restJson1DescribeProvisioningTemplateCommand = exports.serializeAws_restJson1DescribeMitigationActionCommand = exports.serializeAws_restJson1DescribeJobExecutionCommand = exports.serializeAws_restJson1DescribeJobCommand = exports.serializeAws_restJson1DescribeIndexCommand = exports.serializeAws_restJson1DescribeEventConfigurationsCommand = exports.serializeAws_restJson1DescribeEndpointCommand = exports.serializeAws_restJson1DescribeDomainConfigurationCommand = exports.serializeAws_restJson1DescribeDimensionCommand = exports.serializeAws_restJson1DescribeDefaultAuthorizerCommand = exports.serializeAws_restJson1DescribeCertificateCommand = exports.serializeAws_restJson1DescribeCACertificateCommand = exports.serializeAws_restJson1DescribeBillingGroupCommand = exports.serializeAws_restJson1DescribeAuthorizerCommand = exports.serializeAws_restJson1DescribeAuditTaskCommand = exports.serializeAws_restJson1DescribeAuditSuppressionCommand = exports.serializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = exports.serializeAws_restJson1DescribeAuditFindingCommand = exports.serializeAws_restJson1DescribeAccountAuditConfigurationCommand = exports.serializeAws_restJson1DeprecateThingTypeCommand = exports.serializeAws_restJson1DeleteV2LoggingLevelCommand = exports.serializeAws_restJson1DeleteTopicRuleDestinationCommand = exports.serializeAws_restJson1DeleteTopicRuleCommand = exports.serializeAws_restJson1DeleteThingTypeCommand = exports.serializeAws_restJson1DeleteThingGroupCommand = exports.serializeAws_restJson1DeleteThingCommand = exports.serializeAws_restJson1DeleteStreamCommand = exports.serializeAws_restJson1DeleteSecurityProfileCommand = exports.serializeAws_restJson1DeleteScheduledAuditCommand = exports.serializeAws_restJson1DeleteRoleAliasCommand = exports.serializeAws_restJson1DeleteRegistrationCodeCommand = exports.serializeAws_restJson1DeleteProvisioningTemplateVersionCommand = exports.serializeAws_restJson1DeleteProvisioningTemplateCommand = exports.serializeAws_restJson1DeletePolicyVersionCommand = exports.serializeAws_restJson1DeletePolicyCommand = exports.serializeAws_restJson1DeleteOTAUpdateCommand = exports.serializeAws_restJson1DeleteMitigationActionCommand = exports.serializeAws_restJson1DeleteJobExecutionCommand = void 0;
exports.serializeAws_restJson1ListStreamsCommand = exports.serializeAws_restJson1ListSecurityProfilesForTargetCommand = exports.serializeAws_restJson1ListSecurityProfilesCommand = exports.serializeAws_restJson1ListScheduledAuditsCommand = exports.serializeAws_restJson1ListRoleAliasesCommand = exports.serializeAws_restJson1ListProvisioningTemplateVersionsCommand = exports.serializeAws_restJson1ListProvisioningTemplatesCommand = exports.serializeAws_restJson1ListPrincipalThingsCommand = exports.serializeAws_restJson1ListPrincipalPoliciesCommand = exports.serializeAws_restJson1ListPolicyVersionsCommand = exports.serializeAws_restJson1ListPolicyPrincipalsCommand = exports.serializeAws_restJson1ListPoliciesCommand = exports.serializeAws_restJson1ListOutgoingCertificatesCommand = exports.serializeAws_restJson1ListOTAUpdatesCommand = exports.serializeAws_restJson1ListMitigationActionsCommand = exports.serializeAws_restJson1ListJobsCommand = exports.serializeAws_restJson1ListJobExecutionsForThingCommand = exports.serializeAws_restJson1ListJobExecutionsForJobCommand = exports.serializeAws_restJson1ListIndicesCommand = exports.serializeAws_restJson1ListDomainConfigurationsCommand = exports.serializeAws_restJson1ListDimensionsCommand = exports.serializeAws_restJson1ListCertificatesByCACommand = exports.serializeAws_restJson1ListCertificatesCommand = exports.serializeAws_restJson1ListCACertificatesCommand = exports.serializeAws_restJson1ListBillingGroupsCommand = exports.serializeAws_restJson1ListAuthorizersCommand = exports.serializeAws_restJson1ListAuditTasksCommand = exports.serializeAws_restJson1ListAuditSuppressionsCommand = exports.serializeAws_restJson1ListAuditMitigationActionsTasksCommand = exports.serializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = exports.serializeAws_restJson1ListAuditFindingsCommand = exports.serializeAws_restJson1ListAttachedPoliciesCommand = exports.serializeAws_restJson1ListActiveViolationsCommand = exports.serializeAws_restJson1GetV2LoggingOptionsCommand = exports.serializeAws_restJson1GetTopicRuleDestinationCommand = exports.serializeAws_restJson1GetTopicRuleCommand = exports.serializeAws_restJson1GetStatisticsCommand = exports.serializeAws_restJson1GetRegistrationCodeCommand = exports.serializeAws_restJson1GetPolicyVersionCommand = exports.serializeAws_restJson1GetPolicyCommand = exports.serializeAws_restJson1GetPercentilesCommand = exports.serializeAws_restJson1GetOTAUpdateCommand = exports.serializeAws_restJson1GetLoggingOptionsCommand = exports.serializeAws_restJson1GetJobDocumentCommand = exports.serializeAws_restJson1GetIndexingConfigurationCommand = exports.serializeAws_restJson1GetEffectivePoliciesCommand = exports.serializeAws_restJson1GetCardinalityCommand = exports.serializeAws_restJson1EnableTopicRuleCommand = exports.serializeAws_restJson1DisableTopicRuleCommand = exports.serializeAws_restJson1DetachThingPrincipalCommand = void 0;
exports.serializeAws_restJson1UpdateIndexingConfigurationCommand = exports.serializeAws_restJson1UpdateEventConfigurationsCommand = exports.serializeAws_restJson1UpdateDynamicThingGroupCommand = exports.serializeAws_restJson1UpdateDomainConfigurationCommand = exports.serializeAws_restJson1UpdateDimensionCommand = exports.serializeAws_restJson1UpdateCertificateCommand = exports.serializeAws_restJson1UpdateCACertificateCommand = exports.serializeAws_restJson1UpdateBillingGroupCommand = exports.serializeAws_restJson1UpdateAuthorizerCommand = exports.serializeAws_restJson1UpdateAuditSuppressionCommand = exports.serializeAws_restJson1UpdateAccountAuditConfigurationCommand = exports.serializeAws_restJson1UntagResourceCommand = exports.serializeAws_restJson1TransferCertificateCommand = exports.serializeAws_restJson1TestInvokeAuthorizerCommand = exports.serializeAws_restJson1TestAuthorizationCommand = exports.serializeAws_restJson1TagResourceCommand = exports.serializeAws_restJson1StopThingRegistrationTaskCommand = exports.serializeAws_restJson1StartThingRegistrationTaskCommand = exports.serializeAws_restJson1StartOnDemandAuditTaskCommand = exports.serializeAws_restJson1StartAuditMitigationActionsTaskCommand = exports.serializeAws_restJson1SetV2LoggingOptionsCommand = exports.serializeAws_restJson1SetV2LoggingLevelCommand = exports.serializeAws_restJson1SetLoggingOptionsCommand = exports.serializeAws_restJson1SetDefaultPolicyVersionCommand = exports.serializeAws_restJson1SetDefaultAuthorizerCommand = exports.serializeAws_restJson1SearchIndexCommand = exports.serializeAws_restJson1ReplaceTopicRuleCommand = exports.serializeAws_restJson1RemoveThingFromThingGroupCommand = exports.serializeAws_restJson1RemoveThingFromBillingGroupCommand = exports.serializeAws_restJson1RejectCertificateTransferCommand = exports.serializeAws_restJson1RegisterThingCommand = exports.serializeAws_restJson1RegisterCertificateWithoutCACommand = exports.serializeAws_restJson1RegisterCertificateCommand = exports.serializeAws_restJson1RegisterCACertificateCommand = exports.serializeAws_restJson1ListViolationEventsCommand = exports.serializeAws_restJson1ListV2LoggingLevelsCommand = exports.serializeAws_restJson1ListTopicRulesCommand = exports.serializeAws_restJson1ListTopicRuleDestinationsCommand = exports.serializeAws_restJson1ListThingTypesCommand = exports.serializeAws_restJson1ListThingsInThingGroupCommand = exports.serializeAws_restJson1ListThingsInBillingGroupCommand = exports.serializeAws_restJson1ListThingsCommand = exports.serializeAws_restJson1ListThingRegistrationTasksCommand = exports.serializeAws_restJson1ListThingRegistrationTaskReportsCommand = exports.serializeAws_restJson1ListThingPrincipalsCommand = exports.serializeAws_restJson1ListThingGroupsForThingCommand = exports.serializeAws_restJson1ListThingGroupsCommand = exports.serializeAws_restJson1ListTargetsForSecurityProfileCommand = exports.serializeAws_restJson1ListTargetsForPolicyCommand = exports.serializeAws_restJson1ListTagsForResourceCommand = void 0;
exports.deserializeAws_restJson1CreateThingTypeCommand = exports.deserializeAws_restJson1CreateThingGroupCommand = exports.deserializeAws_restJson1CreateThingCommand = exports.deserializeAws_restJson1CreateStreamCommand = exports.deserializeAws_restJson1CreateSecurityProfileCommand = exports.deserializeAws_restJson1CreateScheduledAuditCommand = exports.deserializeAws_restJson1CreateRoleAliasCommand = exports.deserializeAws_restJson1CreateProvisioningTemplateVersionCommand = exports.deserializeAws_restJson1CreateProvisioningTemplateCommand = exports.deserializeAws_restJson1CreateProvisioningClaimCommand = exports.deserializeAws_restJson1CreatePolicyVersionCommand = exports.deserializeAws_restJson1CreatePolicyCommand = exports.deserializeAws_restJson1CreateOTAUpdateCommand = exports.deserializeAws_restJson1CreateMitigationActionCommand = exports.deserializeAws_restJson1CreateKeysAndCertificateCommand = exports.deserializeAws_restJson1CreateJobCommand = exports.deserializeAws_restJson1CreateDynamicThingGroupCommand = exports.deserializeAws_restJson1CreateDomainConfigurationCommand = exports.deserializeAws_restJson1CreateDimensionCommand = exports.deserializeAws_restJson1CreateCertificateFromCsrCommand = exports.deserializeAws_restJson1CreateBillingGroupCommand = exports.deserializeAws_restJson1CreateAuthorizerCommand = exports.deserializeAws_restJson1CreateAuditSuppressionCommand = exports.deserializeAws_restJson1ConfirmTopicRuleDestinationCommand = exports.deserializeAws_restJson1ClearDefaultAuthorizerCommand = exports.deserializeAws_restJson1CancelJobExecutionCommand = exports.deserializeAws_restJson1CancelJobCommand = exports.deserializeAws_restJson1CancelCertificateTransferCommand = exports.deserializeAws_restJson1CancelAuditTaskCommand = exports.deserializeAws_restJson1CancelAuditMitigationActionsTaskCommand = exports.deserializeAws_restJson1AttachThingPrincipalCommand = exports.deserializeAws_restJson1AttachSecurityProfileCommand = exports.deserializeAws_restJson1AttachPrincipalPolicyCommand = exports.deserializeAws_restJson1AttachPolicyCommand = exports.deserializeAws_restJson1AssociateTargetsWithJobCommand = exports.deserializeAws_restJson1AddThingToThingGroupCommand = exports.deserializeAws_restJson1AddThingToBillingGroupCommand = exports.deserializeAws_restJson1AcceptCertificateTransferCommand = exports.serializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = exports.serializeAws_restJson1UpdateTopicRuleDestinationCommand = exports.serializeAws_restJson1UpdateThingGroupsForThingCommand = exports.serializeAws_restJson1UpdateThingGroupCommand = exports.serializeAws_restJson1UpdateThingCommand = exports.serializeAws_restJson1UpdateStreamCommand = exports.serializeAws_restJson1UpdateSecurityProfileCommand = exports.serializeAws_restJson1UpdateScheduledAuditCommand = exports.serializeAws_restJson1UpdateRoleAliasCommand = exports.serializeAws_restJson1UpdateProvisioningTemplateCommand = exports.serializeAws_restJson1UpdateMitigationActionCommand = exports.serializeAws_restJson1UpdateJobCommand = void 0;
exports.deserializeAws_restJson1DescribeProvisioningTemplateCommand = exports.deserializeAws_restJson1DescribeMitigationActionCommand = exports.deserializeAws_restJson1DescribeJobExecutionCommand = exports.deserializeAws_restJson1DescribeJobCommand = exports.deserializeAws_restJson1DescribeIndexCommand = exports.deserializeAws_restJson1DescribeEventConfigurationsCommand = exports.deserializeAws_restJson1DescribeEndpointCommand = exports.deserializeAws_restJson1DescribeDomainConfigurationCommand = exports.deserializeAws_restJson1DescribeDimensionCommand = exports.deserializeAws_restJson1DescribeDefaultAuthorizerCommand = exports.deserializeAws_restJson1DescribeCertificateCommand = exports.deserializeAws_restJson1DescribeCACertificateCommand = exports.deserializeAws_restJson1DescribeBillingGroupCommand = exports.deserializeAws_restJson1DescribeAuthorizerCommand = exports.deserializeAws_restJson1DescribeAuditTaskCommand = exports.deserializeAws_restJson1DescribeAuditSuppressionCommand = exports.deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = exports.deserializeAws_restJson1DescribeAuditFindingCommand = exports.deserializeAws_restJson1DescribeAccountAuditConfigurationCommand = exports.deserializeAws_restJson1DeprecateThingTypeCommand = exports.deserializeAws_restJson1DeleteV2LoggingLevelCommand = exports.deserializeAws_restJson1DeleteTopicRuleDestinationCommand = exports.deserializeAws_restJson1DeleteTopicRuleCommand = exports.deserializeAws_restJson1DeleteThingTypeCommand = exports.deserializeAws_restJson1DeleteThingGroupCommand = exports.deserializeAws_restJson1DeleteThingCommand = exports.deserializeAws_restJson1DeleteStreamCommand = exports.deserializeAws_restJson1DeleteSecurityProfileCommand = exports.deserializeAws_restJson1DeleteScheduledAuditCommand = exports.deserializeAws_restJson1DeleteRoleAliasCommand = exports.deserializeAws_restJson1DeleteRegistrationCodeCommand = exports.deserializeAws_restJson1DeleteProvisioningTemplateVersionCommand = exports.deserializeAws_restJson1DeleteProvisioningTemplateCommand = exports.deserializeAws_restJson1DeletePolicyVersionCommand = exports.deserializeAws_restJson1DeletePolicyCommand = exports.deserializeAws_restJson1DeleteOTAUpdateCommand = exports.deserializeAws_restJson1DeleteMitigationActionCommand = exports.deserializeAws_restJson1DeleteJobExecutionCommand = exports.deserializeAws_restJson1DeleteJobCommand = exports.deserializeAws_restJson1DeleteDynamicThingGroupCommand = exports.deserializeAws_restJson1DeleteDomainConfigurationCommand = exports.deserializeAws_restJson1DeleteDimensionCommand = exports.deserializeAws_restJson1DeleteCertificateCommand = exports.deserializeAws_restJson1DeleteCACertificateCommand = exports.deserializeAws_restJson1DeleteBillingGroupCommand = exports.deserializeAws_restJson1DeleteAuthorizerCommand = exports.deserializeAws_restJson1DeleteAuditSuppressionCommand = exports.deserializeAws_restJson1DeleteAccountAuditConfigurationCommand = exports.deserializeAws_restJson1CreateTopicRuleDestinationCommand = exports.deserializeAws_restJson1CreateTopicRuleCommand = void 0;
exports.deserializeAws_restJson1ListOutgoingCertificatesCommand = exports.deserializeAws_restJson1ListOTAUpdatesCommand = exports.deserializeAws_restJson1ListMitigationActionsCommand = exports.deserializeAws_restJson1ListJobsCommand = exports.deserializeAws_restJson1ListJobExecutionsForThingCommand = exports.deserializeAws_restJson1ListJobExecutionsForJobCommand = exports.deserializeAws_restJson1ListIndicesCommand = exports.deserializeAws_restJson1ListDomainConfigurationsCommand = exports.deserializeAws_restJson1ListDimensionsCommand = exports.deserializeAws_restJson1ListCertificatesByCACommand = exports.deserializeAws_restJson1ListCertificatesCommand = exports.deserializeAws_restJson1ListCACertificatesCommand = exports.deserializeAws_restJson1ListBillingGroupsCommand = exports.deserializeAws_restJson1ListAuthorizersCommand = exports.deserializeAws_restJson1ListAuditTasksCommand = exports.deserializeAws_restJson1ListAuditSuppressionsCommand = exports.deserializeAws_restJson1ListAuditMitigationActionsTasksCommand = exports.deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = exports.deserializeAws_restJson1ListAuditFindingsCommand = exports.deserializeAws_restJson1ListAttachedPoliciesCommand = exports.deserializeAws_restJson1ListActiveViolationsCommand = exports.deserializeAws_restJson1GetV2LoggingOptionsCommand = exports.deserializeAws_restJson1GetTopicRuleDestinationCommand = exports.deserializeAws_restJson1GetTopicRuleCommand = exports.deserializeAws_restJson1GetStatisticsCommand = exports.deserializeAws_restJson1GetRegistrationCodeCommand = exports.deserializeAws_restJson1GetPolicyVersionCommand = exports.deserializeAws_restJson1GetPolicyCommand = exports.deserializeAws_restJson1GetPercentilesCommand = exports.deserializeAws_restJson1GetOTAUpdateCommand = exports.deserializeAws_restJson1GetLoggingOptionsCommand = exports.deserializeAws_restJson1GetJobDocumentCommand = exports.deserializeAws_restJson1GetIndexingConfigurationCommand = exports.deserializeAws_restJson1GetEffectivePoliciesCommand = exports.deserializeAws_restJson1GetCardinalityCommand = exports.deserializeAws_restJson1EnableTopicRuleCommand = exports.deserializeAws_restJson1DisableTopicRuleCommand = exports.deserializeAws_restJson1DetachThingPrincipalCommand = exports.deserializeAws_restJson1DetachSecurityProfileCommand = exports.deserializeAws_restJson1DetachPrincipalPolicyCommand = exports.deserializeAws_restJson1DetachPolicyCommand = exports.deserializeAws_restJson1DescribeThingTypeCommand = exports.deserializeAws_restJson1DescribeThingRegistrationTaskCommand = exports.deserializeAws_restJson1DescribeThingGroupCommand = exports.deserializeAws_restJson1DescribeThingCommand = exports.deserializeAws_restJson1DescribeStreamCommand = exports.deserializeAws_restJson1DescribeSecurityProfileCommand = exports.deserializeAws_restJson1DescribeScheduledAuditCommand = exports.deserializeAws_restJson1DescribeRoleAliasCommand = exports.deserializeAws_restJson1DescribeProvisioningTemplateVersionCommand = void 0;
exports.deserializeAws_restJson1TransferCertificateCommand = exports.deserializeAws_restJson1TestInvokeAuthorizerCommand = exports.deserializeAws_restJson1TestAuthorizationCommand = exports.deserializeAws_restJson1TagResourceCommand = exports.deserializeAws_restJson1StopThingRegistrationTaskCommand = exports.deserializeAws_restJson1StartThingRegistrationTaskCommand = exports.deserializeAws_restJson1StartOnDemandAuditTaskCommand = exports.deserializeAws_restJson1StartAuditMitigationActionsTaskCommand = exports.deserializeAws_restJson1SetV2LoggingOptionsCommand = exports.deserializeAws_restJson1SetV2LoggingLevelCommand = exports.deserializeAws_restJson1SetLoggingOptionsCommand = exports.deserializeAws_restJson1SetDefaultPolicyVersionCommand = exports.deserializeAws_restJson1SetDefaultAuthorizerCommand = exports.deserializeAws_restJson1SearchIndexCommand = exports.deserializeAws_restJson1ReplaceTopicRuleCommand = exports.deserializeAws_restJson1RemoveThingFromThingGroupCommand = exports.deserializeAws_restJson1RemoveThingFromBillingGroupCommand = exports.deserializeAws_restJson1RejectCertificateTransferCommand = exports.deserializeAws_restJson1RegisterThingCommand = exports.deserializeAws_restJson1RegisterCertificateWithoutCACommand = exports.deserializeAws_restJson1RegisterCertificateCommand = exports.deserializeAws_restJson1RegisterCACertificateCommand = exports.deserializeAws_restJson1ListViolationEventsCommand = exports.deserializeAws_restJson1ListV2LoggingLevelsCommand = exports.deserializeAws_restJson1ListTopicRulesCommand = exports.deserializeAws_restJson1ListTopicRuleDestinationsCommand = exports.deserializeAws_restJson1ListThingTypesCommand = exports.deserializeAws_restJson1ListThingsInThingGroupCommand = exports.deserializeAws_restJson1ListThingsInBillingGroupCommand = exports.deserializeAws_restJson1ListThingsCommand = exports.deserializeAws_restJson1ListThingRegistrationTasksCommand = exports.deserializeAws_restJson1ListThingRegistrationTaskReportsCommand = exports.deserializeAws_restJson1ListThingPrincipalsCommand = exports.deserializeAws_restJson1ListThingGroupsForThingCommand = exports.deserializeAws_restJson1ListThingGroupsCommand = exports.deserializeAws_restJson1ListTargetsForSecurityProfileCommand = exports.deserializeAws_restJson1ListTargetsForPolicyCommand = exports.deserializeAws_restJson1ListTagsForResourceCommand = exports.deserializeAws_restJson1ListStreamsCommand = exports.deserializeAws_restJson1ListSecurityProfilesForTargetCommand = exports.deserializeAws_restJson1ListSecurityProfilesCommand = exports.deserializeAws_restJson1ListScheduledAuditsCommand = exports.deserializeAws_restJson1ListRoleAliasesCommand = exports.deserializeAws_restJson1ListProvisioningTemplateVersionsCommand = exports.deserializeAws_restJson1ListProvisioningTemplatesCommand = exports.deserializeAws_restJson1ListPrincipalThingsCommand = exports.deserializeAws_restJson1ListPrincipalPoliciesCommand = exports.deserializeAws_restJson1ListPolicyVersionsCommand = exports.deserializeAws_restJson1ListPolicyPrincipalsCommand = exports.deserializeAws_restJson1ListPoliciesCommand = void 0;
exports.deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = exports.deserializeAws_restJson1UpdateTopicRuleDestinationCommand = exports.deserializeAws_restJson1UpdateThingGroupsForThingCommand = exports.deserializeAws_restJson1UpdateThingGroupCommand = exports.deserializeAws_restJson1UpdateThingCommand = exports.deserializeAws_restJson1UpdateStreamCommand = exports.deserializeAws_restJson1UpdateSecurityProfileCommand = exports.deserializeAws_restJson1UpdateScheduledAuditCommand = exports.deserializeAws_restJson1UpdateRoleAliasCommand = exports.deserializeAws_restJson1UpdateProvisioningTemplateCommand = exports.deserializeAws_restJson1UpdateMitigationActionCommand = exports.deserializeAws_restJson1UpdateJobCommand = exports.deserializeAws_restJson1UpdateIndexingConfigurationCommand = exports.deserializeAws_restJson1UpdateEventConfigurationsCommand = exports.deserializeAws_restJson1UpdateDynamicThingGroupCommand = exports.deserializeAws_restJson1UpdateDomainConfigurationCommand = exports.deserializeAws_restJson1UpdateDimensionCommand = exports.deserializeAws_restJson1UpdateCertificateCommand = exports.deserializeAws_restJson1UpdateCACertificateCommand = exports.deserializeAws_restJson1UpdateBillingGroupCommand = exports.deserializeAws_restJson1UpdateAuthorizerCommand = exports.deserializeAws_restJson1UpdateAuditSuppressionCommand = exports.deserializeAws_restJson1UpdateAccountAuditConfigurationCommand = exports.deserializeAws_restJson1UntagResourceCommand = void 0;
const models_0_1 = require("../models/models_0");
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
const uuid_1 = require("uuid");
const serializeAws_restJson1AcceptCertificateTransferCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/accept-certificate-transfer/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    const query = {
        ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1AcceptCertificateTransferCommand = serializeAws_restJson1AcceptCertificateTransferCommand;
const serializeAws_restJson1AddThingToBillingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/billing-groups/addThingToBillingGroup";
    let body;
    body = JSON.stringify({
        ...(input.billingGroupArn !== undefined &&
            input.billingGroupArn !== null && { billingGroupArn: input.billingGroupArn }),
        ...(input.billingGroupName !== undefined &&
            input.billingGroupName !== null && { billingGroupName: input.billingGroupName }),
        ...(input.thingArn !== undefined && input.thingArn !== null && { thingArn: input.thingArn }),
        ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1AddThingToBillingGroupCommand = serializeAws_restJson1AddThingToBillingGroupCommand;
const serializeAws_restJson1AddThingToThingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/thing-groups/addThingToThingGroup";
    let body;
    body = JSON.stringify({
        ...(input.overrideDynamicGroups !== undefined &&
            input.overrideDynamicGroups !== null && { overrideDynamicGroups: input.overrideDynamicGroups }),
        ...(input.thingArn !== undefined && input.thingArn !== null && { thingArn: input.thingArn }),
        ...(input.thingGroupArn !== undefined && input.thingGroupArn !== null && { thingGroupArn: input.thingGroupArn }),
        ...(input.thingGroupName !== undefined &&
            input.thingGroupName !== null && { thingGroupName: input.thingGroupName }),
        ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1AddThingToThingGroupCommand = serializeAws_restJson1AddThingToThingGroupCommand;
const serializeAws_restJson1AssociateTargetsWithJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/jobs/{jobId}/targets";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    const query = {
        ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
    };
    let body;
    body = JSON.stringify({
        ...(input.comment !== undefined && input.comment !== null && { comment: input.comment }),
        ...(input.targets !== undefined &&
            input.targets !== null && { targets: serializeAws_restJson1JobTargets(input.targets, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1AssociateTargetsWithJobCommand = serializeAws_restJson1AssociateTargetsWithJobCommand;
const serializeAws_restJson1AttachPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/target-policies/{policyName}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.target !== undefined && input.target !== null && { target: input.target }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1AttachPolicyCommand = serializeAws_restJson1AttachPolicyCommand;
const serializeAws_restJson1AttachPrincipalPolicyCommand = async (input, context) => {
    const headers = {
        ...(isSerializableHeaderValue(input.principal) && { "x-amzn-iot-principal": input.principal }),
    };
    let resolvedPath = "/principal-policies/{policyName}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1AttachPrincipalPolicyCommand = serializeAws_restJson1AttachPrincipalPolicyCommand;
const serializeAws_restJson1AttachSecurityProfileCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/security-profiles/{securityProfileName}/targets";
    if (input.securityProfileName !== undefined) {
        const labelValue = input.securityProfileName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: securityProfileName.");
        }
        resolvedPath = resolvedPath.replace("{securityProfileName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: securityProfileName.");
    }
    const query = {
        ...(input.securityProfileTargetArn !== undefined && { securityProfileTargetArn: input.securityProfileTargetArn }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1AttachSecurityProfileCommand = serializeAws_restJson1AttachSecurityProfileCommand;
const serializeAws_restJson1AttachThingPrincipalCommand = async (input, context) => {
    const headers = {
        ...(isSerializableHeaderValue(input.principal) && { "x-amzn-principal": input.principal }),
    };
    let resolvedPath = "/things/{thingName}/principals";
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1AttachThingPrincipalCommand = serializeAws_restJson1AttachThingPrincipalCommand;
const serializeAws_restJson1CancelAuditMitigationActionsTaskCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/mitigationactions/tasks/{taskId}/cancel";
    if (input.taskId !== undefined) {
        const labelValue = input.taskId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: taskId.");
        }
        resolvedPath = resolvedPath.replace("{taskId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: taskId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CancelAuditMitigationActionsTaskCommand = serializeAws_restJson1CancelAuditMitigationActionsTaskCommand;
const serializeAws_restJson1CancelAuditTaskCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/tasks/{taskId}/cancel";
    if (input.taskId !== undefined) {
        const labelValue = input.taskId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: taskId.");
        }
        resolvedPath = resolvedPath.replace("{taskId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: taskId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CancelAuditTaskCommand = serializeAws_restJson1CancelAuditTaskCommand;
const serializeAws_restJson1CancelCertificateTransferCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/cancel-certificate-transfer/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CancelCertificateTransferCommand = serializeAws_restJson1CancelCertificateTransferCommand;
const serializeAws_restJson1CancelJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/jobs/{jobId}/cancel";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    const query = {
        ...(input.force !== undefined && { force: input.force.toString() }),
    };
    let body;
    body = JSON.stringify({
        ...(input.comment !== undefined && input.comment !== null && { comment: input.comment }),
        ...(input.reasonCode !== undefined && input.reasonCode !== null && { reasonCode: input.reasonCode }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1CancelJobCommand = serializeAws_restJson1CancelJobCommand;
const serializeAws_restJson1CancelJobExecutionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/things/{thingName}/jobs/{jobId}/cancel";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    const query = {
        ...(input.force !== undefined && { force: input.force.toString() }),
    };
    let body;
    body = JSON.stringify({
        ...(input.expectedVersion !== undefined &&
            input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
        ...(input.statusDetails !== undefined &&
            input.statusDetails !== null && {
            statusDetails: serializeAws_restJson1DetailsMap(input.statusDetails, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1CancelJobExecutionCommand = serializeAws_restJson1CancelJobExecutionCommand;
const serializeAws_restJson1ClearDefaultAuthorizerCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/default-authorizer";
    let body;
    body = "";
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1ClearDefaultAuthorizerCommand = serializeAws_restJson1ClearDefaultAuthorizerCommand;
const serializeAws_restJson1ConfirmTopicRuleDestinationCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/confirmdestination/{confirmationToken+}";
    if (input.confirmationToken !== undefined) {
        const labelValue = input.confirmationToken;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: confirmationToken.");
        }
        resolvedPath = resolvedPath.replace("{confirmationToken+}", labelValue
            .split("/")
            .map((segment) => smithy_client_1.extendedEncodeURIComponent(segment))
            .join("/"));
    }
    else {
        throw new Error("No value provided for input HTTP label: confirmationToken.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1ConfirmTopicRuleDestinationCommand = serializeAws_restJson1ConfirmTopicRuleDestinationCommand;
const serializeAws_restJson1CreateAuditSuppressionCommand = async (input, context) => {
    var _a;
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/suppressions/create";
    let body;
    body = JSON.stringify({
        ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
        clientRequestToken: (_a = input.clientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.expirationDate !== undefined &&
            input.expirationDate !== null && { expirationDate: Math.round(input.expirationDate.getTime() / 1000) }),
        ...(input.resourceIdentifier !== undefined &&
            input.resourceIdentifier !== null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
        ...(input.suppressIndefinitely !== undefined &&
            input.suppressIndefinitely !== null && { suppressIndefinitely: input.suppressIndefinitely }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateAuditSuppressionCommand = serializeAws_restJson1CreateAuditSuppressionCommand;
const serializeAws_restJson1CreateAuthorizerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/authorizer/{authorizerName}";
    if (input.authorizerName !== undefined) {
        const labelValue = input.authorizerName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: authorizerName.");
        }
        resolvedPath = resolvedPath.replace("{authorizerName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: authorizerName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.authorizerFunctionArn !== undefined &&
            input.authorizerFunctionArn !== null && { authorizerFunctionArn: input.authorizerFunctionArn }),
        ...(input.signingDisabled !== undefined &&
            input.signingDisabled !== null && { signingDisabled: input.signingDisabled }),
        ...(input.status !== undefined && input.status !== null && { status: input.status }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.tokenKeyName !== undefined && input.tokenKeyName !== null && { tokenKeyName: input.tokenKeyName }),
        ...(input.tokenSigningPublicKeys !== undefined &&
            input.tokenSigningPublicKeys !== null && {
            tokenSigningPublicKeys: serializeAws_restJson1PublicKeyMap(input.tokenSigningPublicKeys, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateAuthorizerCommand = serializeAws_restJson1CreateAuthorizerCommand;
const serializeAws_restJson1CreateBillingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/billing-groups/{billingGroupName}";
    if (input.billingGroupName !== undefined) {
        const labelValue = input.billingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: billingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{billingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: billingGroupName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.billingGroupProperties !== undefined &&
            input.billingGroupProperties !== null && {
            billingGroupProperties: serializeAws_restJson1BillingGroupProperties(input.billingGroupProperties, context),
        }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateBillingGroupCommand = serializeAws_restJson1CreateBillingGroupCommand;
const serializeAws_restJson1CreateCertificateFromCsrCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/certificates";
    const query = {
        ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
    };
    let body;
    body = JSON.stringify({
        ...(input.certificateSigningRequest !== undefined &&
            input.certificateSigningRequest !== null && { certificateSigningRequest: input.certificateSigningRequest }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1CreateCertificateFromCsrCommand = serializeAws_restJson1CreateCertificateFromCsrCommand;
const serializeAws_restJson1CreateDimensionCommand = async (input, context) => {
    var _a;
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/dimensions/{name}";
    if (input.name !== undefined) {
        const labelValue = input.name;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: name.");
        }
        resolvedPath = resolvedPath.replace("{name}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: name.");
    }
    let body;
    body = JSON.stringify({
        clientRequestToken: (_a = input.clientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
        ...(input.stringValues !== undefined &&
            input.stringValues !== null && {
            stringValues: serializeAws_restJson1DimensionStringValues(input.stringValues, context),
        }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.type !== undefined && input.type !== null && { type: input.type }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateDimensionCommand = serializeAws_restJson1CreateDimensionCommand;
const serializeAws_restJson1CreateDomainConfigurationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/domainConfigurations/{domainConfigurationName}";
    if (input.domainConfigurationName !== undefined) {
        const labelValue = input.domainConfigurationName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: domainConfigurationName.");
        }
        resolvedPath = resolvedPath.replace("{domainConfigurationName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: domainConfigurationName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.authorizerConfig !== undefined &&
            input.authorizerConfig !== null && {
            authorizerConfig: serializeAws_restJson1AuthorizerConfig(input.authorizerConfig, context),
        }),
        ...(input.domainName !== undefined && input.domainName !== null && { domainName: input.domainName }),
        ...(input.serverCertificateArns !== undefined &&
            input.serverCertificateArns !== null && {
            serverCertificateArns: serializeAws_restJson1ServerCertificateArns(input.serverCertificateArns, context),
        }),
        ...(input.serviceType !== undefined && input.serviceType !== null && { serviceType: input.serviceType }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.validationCertificateArn !== undefined &&
            input.validationCertificateArn !== null && { validationCertificateArn: input.validationCertificateArn }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateDomainConfigurationCommand = serializeAws_restJson1CreateDomainConfigurationCommand;
const serializeAws_restJson1CreateDynamicThingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/dynamic-thing-groups/{thingGroupName}";
    if (input.thingGroupName !== undefined) {
        const labelValue = input.thingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{thingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingGroupName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
        ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
        ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.thingGroupProperties !== undefined &&
            input.thingGroupProperties !== null && {
            thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateDynamicThingGroupCommand = serializeAws_restJson1CreateDynamicThingGroupCommand;
const serializeAws_restJson1CreateJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/jobs/{jobId}";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    let body;
    body = JSON.stringify({
        ...(input.abortConfig !== undefined &&
            input.abortConfig !== null && { abortConfig: serializeAws_restJson1AbortConfig(input.abortConfig, context) }),
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.document !== undefined && input.document !== null && { document: input.document }),
        ...(input.documentSource !== undefined &&
            input.documentSource !== null && { documentSource: input.documentSource }),
        ...(input.jobExecutionsRolloutConfig !== undefined &&
            input.jobExecutionsRolloutConfig !== null && {
            jobExecutionsRolloutConfig: serializeAws_restJson1JobExecutionsRolloutConfig(input.jobExecutionsRolloutConfig, context),
        }),
        ...(input.namespaceId !== undefined && input.namespaceId !== null && { namespaceId: input.namespaceId }),
        ...(input.presignedUrlConfig !== undefined &&
            input.presignedUrlConfig !== null && {
            presignedUrlConfig: serializeAws_restJson1PresignedUrlConfig(input.presignedUrlConfig, context),
        }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.targetSelection !== undefined &&
            input.targetSelection !== null && { targetSelection: input.targetSelection }),
        ...(input.targets !== undefined &&
            input.targets !== null && { targets: serializeAws_restJson1JobTargets(input.targets, context) }),
        ...(input.timeoutConfig !== undefined &&
            input.timeoutConfig !== null && {
            timeoutConfig: serializeAws_restJson1TimeoutConfig(input.timeoutConfig, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateJobCommand = serializeAws_restJson1CreateJobCommand;
const serializeAws_restJson1CreateKeysAndCertificateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/keys-and-certificate";
    const query = {
        ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1CreateKeysAndCertificateCommand = serializeAws_restJson1CreateKeysAndCertificateCommand;
const serializeAws_restJson1CreateMitigationActionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/mitigationactions/actions/{actionName}";
    if (input.actionName !== undefined) {
        const labelValue = input.actionName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: actionName.");
        }
        resolvedPath = resolvedPath.replace("{actionName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: actionName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.actionParams !== undefined &&
            input.actionParams !== null && {
            actionParams: serializeAws_restJson1MitigationActionParams(input.actionParams, context),
        }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateMitigationActionCommand = serializeAws_restJson1CreateMitigationActionCommand;
const serializeAws_restJson1CreateOTAUpdateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/otaUpdates/{otaUpdateId}";
    if (input.otaUpdateId !== undefined) {
        const labelValue = input.otaUpdateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: otaUpdateId.");
        }
        resolvedPath = resolvedPath.replace("{otaUpdateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: otaUpdateId.");
    }
    let body;
    body = JSON.stringify({
        ...(input.additionalParameters !== undefined &&
            input.additionalParameters !== null && {
            additionalParameters: serializeAws_restJson1AdditionalParameterMap(input.additionalParameters, context),
        }),
        ...(input.awsJobAbortConfig !== undefined &&
            input.awsJobAbortConfig !== null && {
            awsJobAbortConfig: serializeAws_restJson1AwsJobAbortConfig(input.awsJobAbortConfig, context),
        }),
        ...(input.awsJobExecutionsRolloutConfig !== undefined &&
            input.awsJobExecutionsRolloutConfig !== null && {
            awsJobExecutionsRolloutConfig: serializeAws_restJson1AwsJobExecutionsRolloutConfig(input.awsJobExecutionsRolloutConfig, context),
        }),
        ...(input.awsJobPresignedUrlConfig !== undefined &&
            input.awsJobPresignedUrlConfig !== null && {
            awsJobPresignedUrlConfig: serializeAws_restJson1AwsJobPresignedUrlConfig(input.awsJobPresignedUrlConfig, context),
        }),
        ...(input.awsJobTimeoutConfig !== undefined &&
            input.awsJobTimeoutConfig !== null && {
            awsJobTimeoutConfig: serializeAws_restJson1AwsJobTimeoutConfig(input.awsJobTimeoutConfig, context),
        }),
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.files !== undefined &&
            input.files !== null && { files: serializeAws_restJson1OTAUpdateFiles(input.files, context) }),
        ...(input.protocols !== undefined &&
            input.protocols !== null && { protocols: serializeAws_restJson1Protocols(input.protocols, context) }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.targetSelection !== undefined &&
            input.targetSelection !== null && { targetSelection: input.targetSelection }),
        ...(input.targets !== undefined &&
            input.targets !== null && { targets: serializeAws_restJson1Targets(input.targets, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateOTAUpdateCommand = serializeAws_restJson1CreateOTAUpdateCommand;
const serializeAws_restJson1CreatePolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/policies/{policyName}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.policyDocument !== undefined &&
            input.policyDocument !== null && { policyDocument: input.policyDocument }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreatePolicyCommand = serializeAws_restJson1CreatePolicyCommand;
const serializeAws_restJson1CreatePolicyVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/policies/{policyName}/version";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    const query = {
        ...(input.setAsDefault !== undefined && { setAsDefault: input.setAsDefault.toString() }),
    };
    let body;
    body = JSON.stringify({
        ...(input.policyDocument !== undefined &&
            input.policyDocument !== null && { policyDocument: input.policyDocument }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1CreatePolicyVersionCommand = serializeAws_restJson1CreatePolicyVersionCommand;
const serializeAws_restJson1CreateProvisioningClaimCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/provisioning-templates/{templateName}/provisioning-claim";
    if (input.templateName !== undefined) {
        const labelValue = input.templateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: templateName.");
        }
        resolvedPath = resolvedPath.replace("{templateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: templateName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateProvisioningClaimCommand = serializeAws_restJson1CreateProvisioningClaimCommand;
const serializeAws_restJson1CreateProvisioningTemplateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/provisioning-templates";
    let body;
    body = JSON.stringify({
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.enabled !== undefined && input.enabled !== null && { enabled: input.enabled }),
        ...(input.preProvisioningHook !== undefined &&
            input.preProvisioningHook !== null && {
            preProvisioningHook: serializeAws_restJson1ProvisioningHook(input.preProvisioningHook, context),
        }),
        ...(input.provisioningRoleArn !== undefined &&
            input.provisioningRoleArn !== null && { provisioningRoleArn: input.provisioningRoleArn }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
        ...(input.templateName !== undefined && input.templateName !== null && { templateName: input.templateName }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateProvisioningTemplateCommand = serializeAws_restJson1CreateProvisioningTemplateCommand;
const serializeAws_restJson1CreateProvisioningTemplateVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/provisioning-templates/{templateName}/versions";
    if (input.templateName !== undefined) {
        const labelValue = input.templateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: templateName.");
        }
        resolvedPath = resolvedPath.replace("{templateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: templateName.");
    }
    const query = {
        ...(input.setAsDefault !== undefined && { setAsDefault: input.setAsDefault.toString() }),
    };
    let body;
    body = JSON.stringify({
        ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1CreateProvisioningTemplateVersionCommand = serializeAws_restJson1CreateProvisioningTemplateVersionCommand;
const serializeAws_restJson1CreateRoleAliasCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/role-aliases/{roleAlias}";
    if (input.roleAlias !== undefined) {
        const labelValue = input.roleAlias;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: roleAlias.");
        }
        resolvedPath = resolvedPath.replace("{roleAlias}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: roleAlias.");
    }
    let body;
    body = JSON.stringify({
        ...(input.credentialDurationSeconds !== undefined &&
            input.credentialDurationSeconds !== null && { credentialDurationSeconds: input.credentialDurationSeconds }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateRoleAliasCommand = serializeAws_restJson1CreateRoleAliasCommand;
const serializeAws_restJson1CreateScheduledAuditCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/scheduledaudits/{scheduledAuditName}";
    if (input.scheduledAuditName !== undefined) {
        const labelValue = input.scheduledAuditName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: scheduledAuditName.");
        }
        resolvedPath = resolvedPath.replace("{scheduledAuditName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: scheduledAuditName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.dayOfMonth !== undefined && input.dayOfMonth !== null && { dayOfMonth: input.dayOfMonth }),
        ...(input.dayOfWeek !== undefined && input.dayOfWeek !== null && { dayOfWeek: input.dayOfWeek }),
        ...(input.frequency !== undefined && input.frequency !== null && { frequency: input.frequency }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.targetCheckNames !== undefined &&
            input.targetCheckNames !== null && {
            targetCheckNames: serializeAws_restJson1TargetAuditCheckNames(input.targetCheckNames, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateScheduledAuditCommand = serializeAws_restJson1CreateScheduledAuditCommand;
const serializeAws_restJson1CreateSecurityProfileCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/security-profiles/{securityProfileName}";
    if (input.securityProfileName !== undefined) {
        const labelValue = input.securityProfileName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: securityProfileName.");
        }
        resolvedPath = resolvedPath.replace("{securityProfileName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: securityProfileName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.additionalMetricsToRetain !== undefined &&
            input.additionalMetricsToRetain !== null && {
            additionalMetricsToRetain: serializeAws_restJson1AdditionalMetricsToRetainList(input.additionalMetricsToRetain, context),
        }),
        ...(input.additionalMetricsToRetainV2 !== undefined &&
            input.additionalMetricsToRetainV2 !== null && {
            additionalMetricsToRetainV2: serializeAws_restJson1AdditionalMetricsToRetainV2List(input.additionalMetricsToRetainV2, context),
        }),
        ...(input.alertTargets !== undefined &&
            input.alertTargets !== null && { alertTargets: serializeAws_restJson1AlertTargets(input.alertTargets, context) }),
        ...(input.behaviors !== undefined &&
            input.behaviors !== null && { behaviors: serializeAws_restJson1Behaviors(input.behaviors, context) }),
        ...(input.securityProfileDescription !== undefined &&
            input.securityProfileDescription !== null && { securityProfileDescription: input.securityProfileDescription }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateSecurityProfileCommand = serializeAws_restJson1CreateSecurityProfileCommand;
const serializeAws_restJson1CreateStreamCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/streams/{streamId}";
    if (input.streamId !== undefined) {
        const labelValue = input.streamId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: streamId.");
        }
        resolvedPath = resolvedPath.replace("{streamId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: streamId.");
    }
    let body;
    body = JSON.stringify({
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.files !== undefined &&
            input.files !== null && { files: serializeAws_restJson1StreamFiles(input.files, context) }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateStreamCommand = serializeAws_restJson1CreateStreamCommand;
const serializeAws_restJson1CreateThingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/things/{thingName}";
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.attributePayload !== undefined &&
            input.attributePayload !== null && {
            attributePayload: serializeAws_restJson1AttributePayload(input.attributePayload, context),
        }),
        ...(input.billingGroupName !== undefined &&
            input.billingGroupName !== null && { billingGroupName: input.billingGroupName }),
        ...(input.thingTypeName !== undefined && input.thingTypeName !== null && { thingTypeName: input.thingTypeName }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateThingCommand = serializeAws_restJson1CreateThingCommand;
const serializeAws_restJson1CreateThingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/thing-groups/{thingGroupName}";
    if (input.thingGroupName !== undefined) {
        const labelValue = input.thingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{thingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingGroupName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.parentGroupName !== undefined &&
            input.parentGroupName !== null && { parentGroupName: input.parentGroupName }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.thingGroupProperties !== undefined &&
            input.thingGroupProperties !== null && {
            thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateThingGroupCommand = serializeAws_restJson1CreateThingGroupCommand;
const serializeAws_restJson1CreateThingTypeCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/thing-types/{thingTypeName}";
    if (input.thingTypeName !== undefined) {
        const labelValue = input.thingTypeName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingTypeName.");
        }
        resolvedPath = resolvedPath.replace("{thingTypeName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingTypeName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.thingTypeProperties !== undefined &&
            input.thingTypeProperties !== null && {
            thingTypeProperties: serializeAws_restJson1ThingTypeProperties(input.thingTypeProperties, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateThingTypeCommand = serializeAws_restJson1CreateThingTypeCommand;
const serializeAws_restJson1CreateTopicRuleCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
        ...(isSerializableHeaderValue(input.tags) && { "x-amz-tagging": input.tags }),
    };
    let resolvedPath = "/rules/{ruleName}";
    if (input.ruleName !== undefined) {
        const labelValue = input.ruleName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ruleName.");
        }
        resolvedPath = resolvedPath.replace("{ruleName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ruleName.");
    }
    let body;
    if (input.topicRulePayload !== undefined) {
        body = serializeAws_restJson1TopicRulePayload(input.topicRulePayload, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateTopicRuleCommand = serializeAws_restJson1CreateTopicRuleCommand;
const serializeAws_restJson1CreateTopicRuleDestinationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/destinations";
    let body;
    body = JSON.stringify({
        ...(input.destinationConfiguration !== undefined &&
            input.destinationConfiguration !== null && {
            destinationConfiguration: serializeAws_restJson1TopicRuleDestinationConfiguration(input.destinationConfiguration, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateTopicRuleDestinationCommand = serializeAws_restJson1CreateTopicRuleDestinationCommand;
const serializeAws_restJson1DeleteAccountAuditConfigurationCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/configuration";
    const query = {
        ...(input.deleteScheduledAudits !== undefined && { deleteScheduledAudits: input.deleteScheduledAudits.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteAccountAuditConfigurationCommand = serializeAws_restJson1DeleteAccountAuditConfigurationCommand;
const serializeAws_restJson1DeleteAuditSuppressionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/suppressions/delete";
    let body;
    body = JSON.stringify({
        ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
        ...(input.resourceIdentifier !== undefined &&
            input.resourceIdentifier !== null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteAuditSuppressionCommand = serializeAws_restJson1DeleteAuditSuppressionCommand;
const serializeAws_restJson1DeleteAuthorizerCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/authorizer/{authorizerName}";
    if (input.authorizerName !== undefined) {
        const labelValue = input.authorizerName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: authorizerName.");
        }
        resolvedPath = resolvedPath.replace("{authorizerName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: authorizerName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteAuthorizerCommand = serializeAws_restJson1DeleteAuthorizerCommand;
const serializeAws_restJson1DeleteBillingGroupCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/billing-groups/{billingGroupName}";
    if (input.billingGroupName !== undefined) {
        const labelValue = input.billingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: billingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{billingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: billingGroupName.");
    }
    const query = {
        ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteBillingGroupCommand = serializeAws_restJson1DeleteBillingGroupCommand;
const serializeAws_restJson1DeleteCACertificateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/cacertificate/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteCACertificateCommand = serializeAws_restJson1DeleteCACertificateCommand;
const serializeAws_restJson1DeleteCertificateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/certificates/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    const query = {
        ...(input.forceDelete !== undefined && { forceDelete: input.forceDelete.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteCertificateCommand = serializeAws_restJson1DeleteCertificateCommand;
const serializeAws_restJson1DeleteDimensionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/dimensions/{name}";
    if (input.name !== undefined) {
        const labelValue = input.name;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: name.");
        }
        resolvedPath = resolvedPath.replace("{name}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: name.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteDimensionCommand = serializeAws_restJson1DeleteDimensionCommand;
const serializeAws_restJson1DeleteDomainConfigurationCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/domainConfigurations/{domainConfigurationName}";
    if (input.domainConfigurationName !== undefined) {
        const labelValue = input.domainConfigurationName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: domainConfigurationName.");
        }
        resolvedPath = resolvedPath.replace("{domainConfigurationName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: domainConfigurationName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteDomainConfigurationCommand = serializeAws_restJson1DeleteDomainConfigurationCommand;
const serializeAws_restJson1DeleteDynamicThingGroupCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/dynamic-thing-groups/{thingGroupName}";
    if (input.thingGroupName !== undefined) {
        const labelValue = input.thingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{thingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingGroupName.");
    }
    const query = {
        ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteDynamicThingGroupCommand = serializeAws_restJson1DeleteDynamicThingGroupCommand;
const serializeAws_restJson1DeleteJobCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/jobs/{jobId}";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    const query = {
        ...(input.force !== undefined && { force: input.force.toString() }),
        ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteJobCommand = serializeAws_restJson1DeleteJobCommand;
const serializeAws_restJson1DeleteJobExecutionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    if (input.executionNumber !== undefined) {
        const labelValue = input.executionNumber.toString();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: executionNumber.");
        }
        resolvedPath = resolvedPath.replace("{executionNumber}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: executionNumber.");
    }
    const query = {
        ...(input.force !== undefined && { force: input.force.toString() }),
        ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteJobExecutionCommand = serializeAws_restJson1DeleteJobExecutionCommand;
const serializeAws_restJson1DeleteMitigationActionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/mitigationactions/actions/{actionName}";
    if (input.actionName !== undefined) {
        const labelValue = input.actionName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: actionName.");
        }
        resolvedPath = resolvedPath.replace("{actionName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: actionName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteMitigationActionCommand = serializeAws_restJson1DeleteMitigationActionCommand;
const serializeAws_restJson1DeleteOTAUpdateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/otaUpdates/{otaUpdateId}";
    if (input.otaUpdateId !== undefined) {
        const labelValue = input.otaUpdateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: otaUpdateId.");
        }
        resolvedPath = resolvedPath.replace("{otaUpdateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: otaUpdateId.");
    }
    const query = {
        ...(input.deleteStream !== undefined && { deleteStream: input.deleteStream.toString() }),
        ...(input.forceDeleteAWSJob !== undefined && { forceDeleteAWSJob: input.forceDeleteAWSJob.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteOTAUpdateCommand = serializeAws_restJson1DeleteOTAUpdateCommand;
const serializeAws_restJson1DeletePolicyCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/policies/{policyName}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeletePolicyCommand = serializeAws_restJson1DeletePolicyCommand;
const serializeAws_restJson1DeletePolicyVersionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/policies/{policyName}/version/{policyVersionId}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    if (input.policyVersionId !== undefined) {
        const labelValue = input.policyVersionId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyVersionId.");
        }
        resolvedPath = resolvedPath.replace("{policyVersionId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyVersionId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeletePolicyVersionCommand = serializeAws_restJson1DeletePolicyVersionCommand;
const serializeAws_restJson1DeleteProvisioningTemplateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/provisioning-templates/{templateName}";
    if (input.templateName !== undefined) {
        const labelValue = input.templateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: templateName.");
        }
        resolvedPath = resolvedPath.replace("{templateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: templateName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteProvisioningTemplateCommand = serializeAws_restJson1DeleteProvisioningTemplateCommand;
const serializeAws_restJson1DeleteProvisioningTemplateVersionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/provisioning-templates/{templateName}/versions/{versionId}";
    if (input.templateName !== undefined) {
        const labelValue = input.templateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: templateName.");
        }
        resolvedPath = resolvedPath.replace("{templateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: templateName.");
    }
    if (input.versionId !== undefined) {
        const labelValue = input.versionId.toString();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: versionId.");
        }
        resolvedPath = resolvedPath.replace("{versionId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: versionId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteProvisioningTemplateVersionCommand = serializeAws_restJson1DeleteProvisioningTemplateVersionCommand;
const serializeAws_restJson1DeleteRegistrationCodeCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/registrationcode";
    let body;
    body = "";
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteRegistrationCodeCommand = serializeAws_restJson1DeleteRegistrationCodeCommand;
const serializeAws_restJson1DeleteRoleAliasCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/role-aliases/{roleAlias}";
    if (input.roleAlias !== undefined) {
        const labelValue = input.roleAlias;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: roleAlias.");
        }
        resolvedPath = resolvedPath.replace("{roleAlias}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: roleAlias.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteRoleAliasCommand = serializeAws_restJson1DeleteRoleAliasCommand;
const serializeAws_restJson1DeleteScheduledAuditCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/scheduledaudits/{scheduledAuditName}";
    if (input.scheduledAuditName !== undefined) {
        const labelValue = input.scheduledAuditName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: scheduledAuditName.");
        }
        resolvedPath = resolvedPath.replace("{scheduledAuditName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: scheduledAuditName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteScheduledAuditCommand = serializeAws_restJson1DeleteScheduledAuditCommand;
const serializeAws_restJson1DeleteSecurityProfileCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/security-profiles/{securityProfileName}";
    if (input.securityProfileName !== undefined) {
        const labelValue = input.securityProfileName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: securityProfileName.");
        }
        resolvedPath = resolvedPath.replace("{securityProfileName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: securityProfileName.");
    }
    const query = {
        ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteSecurityProfileCommand = serializeAws_restJson1DeleteSecurityProfileCommand;
const serializeAws_restJson1DeleteStreamCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/streams/{streamId}";
    if (input.streamId !== undefined) {
        const labelValue = input.streamId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: streamId.");
        }
        resolvedPath = resolvedPath.replace("{streamId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: streamId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteStreamCommand = serializeAws_restJson1DeleteStreamCommand;
const serializeAws_restJson1DeleteThingCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/things/{thingName}";
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    const query = {
        ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteThingCommand = serializeAws_restJson1DeleteThingCommand;
const serializeAws_restJson1DeleteThingGroupCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-groups/{thingGroupName}";
    if (input.thingGroupName !== undefined) {
        const labelValue = input.thingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{thingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingGroupName.");
    }
    const query = {
        ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteThingGroupCommand = serializeAws_restJson1DeleteThingGroupCommand;
const serializeAws_restJson1DeleteThingTypeCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-types/{thingTypeName}";
    if (input.thingTypeName !== undefined) {
        const labelValue = input.thingTypeName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingTypeName.");
        }
        resolvedPath = resolvedPath.replace("{thingTypeName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingTypeName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteThingTypeCommand = serializeAws_restJson1DeleteThingTypeCommand;
const serializeAws_restJson1DeleteTopicRuleCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/rules/{ruleName}";
    if (input.ruleName !== undefined) {
        const labelValue = input.ruleName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ruleName.");
        }
        resolvedPath = resolvedPath.replace("{ruleName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ruleName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteTopicRuleCommand = serializeAws_restJson1DeleteTopicRuleCommand;
const serializeAws_restJson1DeleteTopicRuleDestinationCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/destinations/{arn+}";
    if (input.arn !== undefined) {
        const labelValue = input.arn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: arn.");
        }
        resolvedPath = resolvedPath.replace("{arn+}", labelValue
            .split("/")
            .map((segment) => smithy_client_1.extendedEncodeURIComponent(segment))
            .join("/"));
    }
    else {
        throw new Error("No value provided for input HTTP label: arn.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeleteTopicRuleDestinationCommand = serializeAws_restJson1DeleteTopicRuleDestinationCommand;
const serializeAws_restJson1DeleteV2LoggingLevelCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/v2LoggingLevel";
    const query = {
        ...(input.targetType !== undefined && { targetType: input.targetType }),
        ...(input.targetName !== undefined && { targetName: input.targetName }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteV2LoggingLevelCommand = serializeAws_restJson1DeleteV2LoggingLevelCommand;
const serializeAws_restJson1DeprecateThingTypeCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/thing-types/{thingTypeName}/deprecate";
    if (input.thingTypeName !== undefined) {
        const labelValue = input.thingTypeName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingTypeName.");
        }
        resolvedPath = resolvedPath.replace("{thingTypeName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingTypeName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.undoDeprecate !== undefined && input.undoDeprecate !== null && { undoDeprecate: input.undoDeprecate }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DeprecateThingTypeCommand = serializeAws_restJson1DeprecateThingTypeCommand;
const serializeAws_restJson1DescribeAccountAuditConfigurationCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/configuration";
    let body;
    body = "";
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeAccountAuditConfigurationCommand = serializeAws_restJson1DescribeAccountAuditConfigurationCommand;
const serializeAws_restJson1DescribeAuditFindingCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/findings/{findingId}";
    if (input.findingId !== undefined) {
        const labelValue = input.findingId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: findingId.");
        }
        resolvedPath = resolvedPath.replace("{findingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: findingId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeAuditFindingCommand = serializeAws_restJson1DescribeAuditFindingCommand;
const serializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/mitigationactions/tasks/{taskId}";
    if (input.taskId !== undefined) {
        const labelValue = input.taskId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: taskId.");
        }
        resolvedPath = resolvedPath.replace("{taskId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: taskId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = serializeAws_restJson1DescribeAuditMitigationActionsTaskCommand;
const serializeAws_restJson1DescribeAuditSuppressionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/suppressions/describe";
    let body;
    body = JSON.stringify({
        ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
        ...(input.resourceIdentifier !== undefined &&
            input.resourceIdentifier !== null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeAuditSuppressionCommand = serializeAws_restJson1DescribeAuditSuppressionCommand;
const serializeAws_restJson1DescribeAuditTaskCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/tasks/{taskId}";
    if (input.taskId !== undefined) {
        const labelValue = input.taskId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: taskId.");
        }
        resolvedPath = resolvedPath.replace("{taskId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: taskId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeAuditTaskCommand = serializeAws_restJson1DescribeAuditTaskCommand;
const serializeAws_restJson1DescribeAuthorizerCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/authorizer/{authorizerName}";
    if (input.authorizerName !== undefined) {
        const labelValue = input.authorizerName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: authorizerName.");
        }
        resolvedPath = resolvedPath.replace("{authorizerName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: authorizerName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeAuthorizerCommand = serializeAws_restJson1DescribeAuthorizerCommand;
const serializeAws_restJson1DescribeBillingGroupCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/billing-groups/{billingGroupName}";
    if (input.billingGroupName !== undefined) {
        const labelValue = input.billingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: billingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{billingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: billingGroupName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeBillingGroupCommand = serializeAws_restJson1DescribeBillingGroupCommand;
const serializeAws_restJson1DescribeCACertificateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/cacertificate/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeCACertificateCommand = serializeAws_restJson1DescribeCACertificateCommand;
const serializeAws_restJson1DescribeCertificateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/certificates/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeCertificateCommand = serializeAws_restJson1DescribeCertificateCommand;
const serializeAws_restJson1DescribeDefaultAuthorizerCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/default-authorizer";
    let body;
    body = "";
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeDefaultAuthorizerCommand = serializeAws_restJson1DescribeDefaultAuthorizerCommand;
const serializeAws_restJson1DescribeDimensionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/dimensions/{name}";
    if (input.name !== undefined) {
        const labelValue = input.name;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: name.");
        }
        resolvedPath = resolvedPath.replace("{name}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: name.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeDimensionCommand = serializeAws_restJson1DescribeDimensionCommand;
const serializeAws_restJson1DescribeDomainConfigurationCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/domainConfigurations/{domainConfigurationName}";
    if (input.domainConfigurationName !== undefined) {
        const labelValue = input.domainConfigurationName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: domainConfigurationName.");
        }
        resolvedPath = resolvedPath.replace("{domainConfigurationName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: domainConfigurationName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeDomainConfigurationCommand = serializeAws_restJson1DescribeDomainConfigurationCommand;
const serializeAws_restJson1DescribeEndpointCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/endpoint";
    const query = {
        ...(input.endpointType !== undefined && { endpointType: input.endpointType }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DescribeEndpointCommand = serializeAws_restJson1DescribeEndpointCommand;
const serializeAws_restJson1DescribeEventConfigurationsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/event-configurations";
    let body;
    body = "";
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeEventConfigurationsCommand = serializeAws_restJson1DescribeEventConfigurationsCommand;
const serializeAws_restJson1DescribeIndexCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/indices/{indexName}";
    if (input.indexName !== undefined) {
        const labelValue = input.indexName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: indexName.");
        }
        resolvedPath = resolvedPath.replace("{indexName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: indexName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeIndexCommand = serializeAws_restJson1DescribeIndexCommand;
const serializeAws_restJson1DescribeJobCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/jobs/{jobId}";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeJobCommand = serializeAws_restJson1DescribeJobCommand;
const serializeAws_restJson1DescribeJobExecutionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/things/{thingName}/jobs/{jobId}";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    const query = {
        ...(input.executionNumber !== undefined && { executionNumber: input.executionNumber.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DescribeJobExecutionCommand = serializeAws_restJson1DescribeJobExecutionCommand;
const serializeAws_restJson1DescribeMitigationActionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/mitigationactions/actions/{actionName}";
    if (input.actionName !== undefined) {
        const labelValue = input.actionName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: actionName.");
        }
        resolvedPath = resolvedPath.replace("{actionName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: actionName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeMitigationActionCommand = serializeAws_restJson1DescribeMitigationActionCommand;
const serializeAws_restJson1DescribeProvisioningTemplateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/provisioning-templates/{templateName}";
    if (input.templateName !== undefined) {
        const labelValue = input.templateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: templateName.");
        }
        resolvedPath = resolvedPath.replace("{templateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: templateName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeProvisioningTemplateCommand = serializeAws_restJson1DescribeProvisioningTemplateCommand;
const serializeAws_restJson1DescribeProvisioningTemplateVersionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/provisioning-templates/{templateName}/versions/{versionId}";
    if (input.templateName !== undefined) {
        const labelValue = input.templateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: templateName.");
        }
        resolvedPath = resolvedPath.replace("{templateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: templateName.");
    }
    if (input.versionId !== undefined) {
        const labelValue = input.versionId.toString();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: versionId.");
        }
        resolvedPath = resolvedPath.replace("{versionId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: versionId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeProvisioningTemplateVersionCommand = serializeAws_restJson1DescribeProvisioningTemplateVersionCommand;
const serializeAws_restJson1DescribeRoleAliasCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/role-aliases/{roleAlias}";
    if (input.roleAlias !== undefined) {
        const labelValue = input.roleAlias;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: roleAlias.");
        }
        resolvedPath = resolvedPath.replace("{roleAlias}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: roleAlias.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeRoleAliasCommand = serializeAws_restJson1DescribeRoleAliasCommand;
const serializeAws_restJson1DescribeScheduledAuditCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/scheduledaudits/{scheduledAuditName}";
    if (input.scheduledAuditName !== undefined) {
        const labelValue = input.scheduledAuditName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: scheduledAuditName.");
        }
        resolvedPath = resolvedPath.replace("{scheduledAuditName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: scheduledAuditName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeScheduledAuditCommand = serializeAws_restJson1DescribeScheduledAuditCommand;
const serializeAws_restJson1DescribeSecurityProfileCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/security-profiles/{securityProfileName}";
    if (input.securityProfileName !== undefined) {
        const labelValue = input.securityProfileName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: securityProfileName.");
        }
        resolvedPath = resolvedPath.replace("{securityProfileName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: securityProfileName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeSecurityProfileCommand = serializeAws_restJson1DescribeSecurityProfileCommand;
const serializeAws_restJson1DescribeStreamCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/streams/{streamId}";
    if (input.streamId !== undefined) {
        const labelValue = input.streamId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: streamId.");
        }
        resolvedPath = resolvedPath.replace("{streamId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: streamId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeStreamCommand = serializeAws_restJson1DescribeStreamCommand;
const serializeAws_restJson1DescribeThingCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/things/{thingName}";
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeThingCommand = serializeAws_restJson1DescribeThingCommand;
const serializeAws_restJson1DescribeThingGroupCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-groups/{thingGroupName}";
    if (input.thingGroupName !== undefined) {
        const labelValue = input.thingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{thingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingGroupName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeThingGroupCommand = serializeAws_restJson1DescribeThingGroupCommand;
const serializeAws_restJson1DescribeThingRegistrationTaskCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-registration-tasks/{taskId}";
    if (input.taskId !== undefined) {
        const labelValue = input.taskId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: taskId.");
        }
        resolvedPath = resolvedPath.replace("{taskId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: taskId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeThingRegistrationTaskCommand = serializeAws_restJson1DescribeThingRegistrationTaskCommand;
const serializeAws_restJson1DescribeThingTypeCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-types/{thingTypeName}";
    if (input.thingTypeName !== undefined) {
        const labelValue = input.thingTypeName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingTypeName.");
        }
        resolvedPath = resolvedPath.replace("{thingTypeName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingTypeName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DescribeThingTypeCommand = serializeAws_restJson1DescribeThingTypeCommand;
const serializeAws_restJson1DetachPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/target-policies/{policyName}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.target !== undefined && input.target !== null && { target: input.target }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DetachPolicyCommand = serializeAws_restJson1DetachPolicyCommand;
const serializeAws_restJson1DetachPrincipalPolicyCommand = async (input, context) => {
    const headers = {
        ...(isSerializableHeaderValue(input.principal) && { "x-amzn-iot-principal": input.principal }),
    };
    let resolvedPath = "/principal-policies/{policyName}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DetachPrincipalPolicyCommand = serializeAws_restJson1DetachPrincipalPolicyCommand;
const serializeAws_restJson1DetachSecurityProfileCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/security-profiles/{securityProfileName}/targets";
    if (input.securityProfileName !== undefined) {
        const labelValue = input.securityProfileName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: securityProfileName.");
        }
        resolvedPath = resolvedPath.replace("{securityProfileName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: securityProfileName.");
    }
    const query = {
        ...(input.securityProfileTargetArn !== undefined && { securityProfileTargetArn: input.securityProfileTargetArn }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DetachSecurityProfileCommand = serializeAws_restJson1DetachSecurityProfileCommand;
const serializeAws_restJson1DetachThingPrincipalCommand = async (input, context) => {
    const headers = {
        ...(isSerializableHeaderValue(input.principal) && { "x-amzn-principal": input.principal }),
    };
    let resolvedPath = "/things/{thingName}/principals";
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DetachThingPrincipalCommand = serializeAws_restJson1DetachThingPrincipalCommand;
const serializeAws_restJson1DisableTopicRuleCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/rules/{ruleName}/disable";
    if (input.ruleName !== undefined) {
        const labelValue = input.ruleName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ruleName.");
        }
        resolvedPath = resolvedPath.replace("{ruleName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ruleName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1DisableTopicRuleCommand = serializeAws_restJson1DisableTopicRuleCommand;
const serializeAws_restJson1EnableTopicRuleCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/rules/{ruleName}/enable";
    if (input.ruleName !== undefined) {
        const labelValue = input.ruleName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ruleName.");
        }
        resolvedPath = resolvedPath.replace("{ruleName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ruleName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1EnableTopicRuleCommand = serializeAws_restJson1EnableTopicRuleCommand;
const serializeAws_restJson1GetCardinalityCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/indices/cardinality";
    let body;
    body = JSON.stringify({
        ...(input.aggregationField !== undefined &&
            input.aggregationField !== null && { aggregationField: input.aggregationField }),
        ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
        ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
        ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetCardinalityCommand = serializeAws_restJson1GetCardinalityCommand;
const serializeAws_restJson1GetEffectivePoliciesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/effective-policies";
    const query = {
        ...(input.thingName !== undefined && { thingName: input.thingName }),
    };
    let body;
    body = JSON.stringify({
        ...(input.cognitoIdentityPoolId !== undefined &&
            input.cognitoIdentityPoolId !== null && { cognitoIdentityPoolId: input.cognitoIdentityPoolId }),
        ...(input.principal !== undefined && input.principal !== null && { principal: input.principal }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1GetEffectivePoliciesCommand = serializeAws_restJson1GetEffectivePoliciesCommand;
const serializeAws_restJson1GetIndexingConfigurationCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/indexing/config";
    let body;
    body = "";
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetIndexingConfigurationCommand = serializeAws_restJson1GetIndexingConfigurationCommand;
const serializeAws_restJson1GetJobDocumentCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/jobs/{jobId}/job-document";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetJobDocumentCommand = serializeAws_restJson1GetJobDocumentCommand;
const serializeAws_restJson1GetLoggingOptionsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/loggingOptions";
    let body;
    body = "";
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetLoggingOptionsCommand = serializeAws_restJson1GetLoggingOptionsCommand;
const serializeAws_restJson1GetOTAUpdateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/otaUpdates/{otaUpdateId}";
    if (input.otaUpdateId !== undefined) {
        const labelValue = input.otaUpdateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: otaUpdateId.");
        }
        resolvedPath = resolvedPath.replace("{otaUpdateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: otaUpdateId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetOTAUpdateCommand = serializeAws_restJson1GetOTAUpdateCommand;
const serializeAws_restJson1GetPercentilesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/indices/percentiles";
    let body;
    body = JSON.stringify({
        ...(input.aggregationField !== undefined &&
            input.aggregationField !== null && { aggregationField: input.aggregationField }),
        ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
        ...(input.percents !== undefined &&
            input.percents !== null && { percents: serializeAws_restJson1PercentList(input.percents, context) }),
        ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
        ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetPercentilesCommand = serializeAws_restJson1GetPercentilesCommand;
const serializeAws_restJson1GetPolicyCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/policies/{policyName}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetPolicyCommand = serializeAws_restJson1GetPolicyCommand;
const serializeAws_restJson1GetPolicyVersionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/policies/{policyName}/version/{policyVersionId}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    if (input.policyVersionId !== undefined) {
        const labelValue = input.policyVersionId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyVersionId.");
        }
        resolvedPath = resolvedPath.replace("{policyVersionId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyVersionId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetPolicyVersionCommand = serializeAws_restJson1GetPolicyVersionCommand;
const serializeAws_restJson1GetRegistrationCodeCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/registrationcode";
    let body;
    body = "";
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetRegistrationCodeCommand = serializeAws_restJson1GetRegistrationCodeCommand;
const serializeAws_restJson1GetStatisticsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/indices/statistics";
    let body;
    body = JSON.stringify({
        ...(input.aggregationField !== undefined &&
            input.aggregationField !== null && { aggregationField: input.aggregationField }),
        ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
        ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
        ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetStatisticsCommand = serializeAws_restJson1GetStatisticsCommand;
const serializeAws_restJson1GetTopicRuleCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/rules/{ruleName}";
    if (input.ruleName !== undefined) {
        const labelValue = input.ruleName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ruleName.");
        }
        resolvedPath = resolvedPath.replace("{ruleName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ruleName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetTopicRuleCommand = serializeAws_restJson1GetTopicRuleCommand;
const serializeAws_restJson1GetTopicRuleDestinationCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/destinations/{arn+}";
    if (input.arn !== undefined) {
        const labelValue = input.arn;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: arn.");
        }
        resolvedPath = resolvedPath.replace("{arn+}", labelValue
            .split("/")
            .map((segment) => smithy_client_1.extendedEncodeURIComponent(segment))
            .join("/"));
    }
    else {
        throw new Error("No value provided for input HTTP label: arn.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetTopicRuleDestinationCommand = serializeAws_restJson1GetTopicRuleDestinationCommand;
const serializeAws_restJson1GetV2LoggingOptionsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/v2LoggingOptions";
    let body;
    body = "";
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1GetV2LoggingOptionsCommand = serializeAws_restJson1GetV2LoggingOptionsCommand;
const serializeAws_restJson1ListActiveViolationsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/active-violations";
    const query = {
        ...(input.thingName !== undefined && { thingName: input.thingName }),
        ...(input.securityProfileName !== undefined && { securityProfileName: input.securityProfileName }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListActiveViolationsCommand = serializeAws_restJson1ListActiveViolationsCommand;
const serializeAws_restJson1ListAttachedPoliciesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/attached-policies/{target}";
    if (input.target !== undefined) {
        const labelValue = input.target;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: target.");
        }
        resolvedPath = resolvedPath.replace("{target}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: target.");
    }
    const query = {
        ...(input.recursive !== undefined && { recursive: input.recursive.toString() }),
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListAttachedPoliciesCommand = serializeAws_restJson1ListAttachedPoliciesCommand;
const serializeAws_restJson1ListAuditFindingsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/findings";
    let body;
    body = JSON.stringify({
        ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
        ...(input.endTime !== undefined &&
            input.endTime !== null && { endTime: Math.round(input.endTime.getTime() / 1000) }),
        ...(input.listSuppressedFindings !== undefined &&
            input.listSuppressedFindings !== null && { listSuppressedFindings: input.listSuppressedFindings }),
        ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
        ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
        ...(input.resourceIdentifier !== undefined &&
            input.resourceIdentifier !== null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
        ...(input.startTime !== undefined &&
            input.startTime !== null && { startTime: Math.round(input.startTime.getTime() / 1000) }),
        ...(input.taskId !== undefined && input.taskId !== null && { taskId: input.taskId }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1ListAuditFindingsCommand = serializeAws_restJson1ListAuditFindingsCommand;
const serializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/mitigationactions/executions";
    const query = {
        ...(input.taskId !== undefined && { taskId: input.taskId }),
        ...(input.actionStatus !== undefined && { actionStatus: input.actionStatus }),
        ...(input.findingId !== undefined && { findingId: input.findingId }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = serializeAws_restJson1ListAuditMitigationActionsExecutionsCommand;
const serializeAws_restJson1ListAuditMitigationActionsTasksCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/mitigationactions/tasks";
    const query = {
        ...(input.auditTaskId !== undefined && { auditTaskId: input.auditTaskId }),
        ...(input.findingId !== undefined && { findingId: input.findingId }),
        ...(input.taskStatus !== undefined && { taskStatus: input.taskStatus }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.startTime !== undefined && { startTime: (input.startTime.toISOString().split(".")[0] + "Z").toString() }),
        ...(input.endTime !== undefined && { endTime: (input.endTime.toISOString().split(".")[0] + "Z").toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListAuditMitigationActionsTasksCommand = serializeAws_restJson1ListAuditMitigationActionsTasksCommand;
const serializeAws_restJson1ListAuditSuppressionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/suppressions/list";
    let body;
    body = JSON.stringify({
        ...(input.ascendingOrder !== undefined &&
            input.ascendingOrder !== null && { ascendingOrder: input.ascendingOrder }),
        ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
        ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
        ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
        ...(input.resourceIdentifier !== undefined &&
            input.resourceIdentifier !== null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1ListAuditSuppressionsCommand = serializeAws_restJson1ListAuditSuppressionsCommand;
const serializeAws_restJson1ListAuditTasksCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/tasks";
    const query = {
        ...(input.startTime !== undefined && { startTime: (input.startTime.toISOString().split(".")[0] + "Z").toString() }),
        ...(input.endTime !== undefined && { endTime: (input.endTime.toISOString().split(".")[0] + "Z").toString() }),
        ...(input.taskType !== undefined && { taskType: input.taskType }),
        ...(input.taskStatus !== undefined && { taskStatus: input.taskStatus }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListAuditTasksCommand = serializeAws_restJson1ListAuditTasksCommand;
const serializeAws_restJson1ListAuthorizersCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/authorizers";
    const query = {
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
        ...(input.status !== undefined && { status: input.status }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListAuthorizersCommand = serializeAws_restJson1ListAuthorizersCommand;
const serializeAws_restJson1ListBillingGroupsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/billing-groups";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.namePrefixFilter !== undefined && { namePrefixFilter: input.namePrefixFilter }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListBillingGroupsCommand = serializeAws_restJson1ListBillingGroupsCommand;
const serializeAws_restJson1ListCACertificatesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/cacertificates";
    const query = {
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListCACertificatesCommand = serializeAws_restJson1ListCACertificatesCommand;
const serializeAws_restJson1ListCertificatesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/certificates";
    const query = {
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListCertificatesCommand = serializeAws_restJson1ListCertificatesCommand;
const serializeAws_restJson1ListCertificatesByCACommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/certificates-by-ca/{caCertificateId}";
    if (input.caCertificateId !== undefined) {
        const labelValue = input.caCertificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: caCertificateId.");
        }
        resolvedPath = resolvedPath.replace("{caCertificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: caCertificateId.");
    }
    const query = {
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListCertificatesByCACommand = serializeAws_restJson1ListCertificatesByCACommand;
const serializeAws_restJson1ListDimensionsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/dimensions";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListDimensionsCommand = serializeAws_restJson1ListDimensionsCommand;
const serializeAws_restJson1ListDomainConfigurationsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/domainConfigurations";
    const query = {
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.serviceType !== undefined && { serviceType: input.serviceType }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListDomainConfigurationsCommand = serializeAws_restJson1ListDomainConfigurationsCommand;
const serializeAws_restJson1ListIndicesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/indices";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListIndicesCommand = serializeAws_restJson1ListIndicesCommand;
const serializeAws_restJson1ListJobExecutionsForJobCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/jobs/{jobId}/things";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    const query = {
        ...(input.status !== undefined && { status: input.status }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListJobExecutionsForJobCommand = serializeAws_restJson1ListJobExecutionsForJobCommand;
const serializeAws_restJson1ListJobExecutionsForThingCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/things/{thingName}/jobs";
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    const query = {
        ...(input.status !== undefined && { status: input.status }),
        ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListJobExecutionsForThingCommand = serializeAws_restJson1ListJobExecutionsForThingCommand;
const serializeAws_restJson1ListJobsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/jobs";
    const query = {
        ...(input.status !== undefined && { status: input.status }),
        ...(input.targetSelection !== undefined && { targetSelection: input.targetSelection }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.thingGroupName !== undefined && { thingGroupName: input.thingGroupName }),
        ...(input.thingGroupId !== undefined && { thingGroupId: input.thingGroupId }),
        ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListJobsCommand = serializeAws_restJson1ListJobsCommand;
const serializeAws_restJson1ListMitigationActionsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/mitigationactions/actions";
    const query = {
        ...(input.actionType !== undefined && { actionType: input.actionType }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListMitigationActionsCommand = serializeAws_restJson1ListMitigationActionsCommand;
const serializeAws_restJson1ListOTAUpdatesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/otaUpdates";
    const query = {
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.otaUpdateStatus !== undefined && { otaUpdateStatus: input.otaUpdateStatus }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListOTAUpdatesCommand = serializeAws_restJson1ListOTAUpdatesCommand;
const serializeAws_restJson1ListOutgoingCertificatesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/certificates-out-going";
    const query = {
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListOutgoingCertificatesCommand = serializeAws_restJson1ListOutgoingCertificatesCommand;
const serializeAws_restJson1ListPoliciesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/policies";
    const query = {
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListPoliciesCommand = serializeAws_restJson1ListPoliciesCommand;
const serializeAws_restJson1ListPolicyPrincipalsCommand = async (input, context) => {
    const headers = {
        ...(isSerializableHeaderValue(input.policyName) && { "x-amzn-iot-policy": input.policyName }),
    };
    let resolvedPath = "/policy-principals";
    const query = {
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListPolicyPrincipalsCommand = serializeAws_restJson1ListPolicyPrincipalsCommand;
const serializeAws_restJson1ListPolicyVersionsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/policies/{policyName}/version";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1ListPolicyVersionsCommand = serializeAws_restJson1ListPolicyVersionsCommand;
const serializeAws_restJson1ListPrincipalPoliciesCommand = async (input, context) => {
    const headers = {
        ...(isSerializableHeaderValue(input.principal) && { "x-amzn-iot-principal": input.principal }),
    };
    let resolvedPath = "/principal-policies";
    const query = {
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListPrincipalPoliciesCommand = serializeAws_restJson1ListPrincipalPoliciesCommand;
const serializeAws_restJson1ListPrincipalThingsCommand = async (input, context) => {
    const headers = {
        ...(isSerializableHeaderValue(input.principal) && { "x-amzn-principal": input.principal }),
    };
    let resolvedPath = "/principals/things";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListPrincipalThingsCommand = serializeAws_restJson1ListPrincipalThingsCommand;
const serializeAws_restJson1ListProvisioningTemplatesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/provisioning-templates";
    const query = {
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListProvisioningTemplatesCommand = serializeAws_restJson1ListProvisioningTemplatesCommand;
const serializeAws_restJson1ListProvisioningTemplateVersionsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/provisioning-templates/{templateName}/versions";
    if (input.templateName !== undefined) {
        const labelValue = input.templateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: templateName.");
        }
        resolvedPath = resolvedPath.replace("{templateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: templateName.");
    }
    const query = {
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListProvisioningTemplateVersionsCommand = serializeAws_restJson1ListProvisioningTemplateVersionsCommand;
const serializeAws_restJson1ListRoleAliasesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/role-aliases";
    const query = {
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListRoleAliasesCommand = serializeAws_restJson1ListRoleAliasesCommand;
const serializeAws_restJson1ListScheduledAuditsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/audit/scheduledaudits";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListScheduledAuditsCommand = serializeAws_restJson1ListScheduledAuditsCommand;
const serializeAws_restJson1ListSecurityProfilesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/security-profiles";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.dimensionName !== undefined && { dimensionName: input.dimensionName }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListSecurityProfilesCommand = serializeAws_restJson1ListSecurityProfilesCommand;
const serializeAws_restJson1ListSecurityProfilesForTargetCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/security-profiles-for-target";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.recursive !== undefined && { recursive: input.recursive.toString() }),
        ...(input.securityProfileTargetArn !== undefined && { securityProfileTargetArn: input.securityProfileTargetArn }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListSecurityProfilesForTargetCommand = serializeAws_restJson1ListSecurityProfilesForTargetCommand;
const serializeAws_restJson1ListStreamsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/streams";
    const query = {
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListStreamsCommand = serializeAws_restJson1ListStreamsCommand;
const serializeAws_restJson1ListTagsForResourceCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/tags";
    const query = {
        ...(input.resourceArn !== undefined && { resourceArn: input.resourceArn }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListTagsForResourceCommand = serializeAws_restJson1ListTagsForResourceCommand;
const serializeAws_restJson1ListTargetsForPolicyCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/policy-targets/{policyName}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    const query = {
        ...(input.marker !== undefined && { marker: input.marker }),
        ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListTargetsForPolicyCommand = serializeAws_restJson1ListTargetsForPolicyCommand;
const serializeAws_restJson1ListTargetsForSecurityProfileCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/security-profiles/{securityProfileName}/targets";
    if (input.securityProfileName !== undefined) {
        const labelValue = input.securityProfileName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: securityProfileName.");
        }
        resolvedPath = resolvedPath.replace("{securityProfileName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: securityProfileName.");
    }
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListTargetsForSecurityProfileCommand = serializeAws_restJson1ListTargetsForSecurityProfileCommand;
const serializeAws_restJson1ListThingGroupsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-groups";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.parentGroup !== undefined && { parentGroup: input.parentGroup }),
        ...(input.namePrefixFilter !== undefined && { namePrefixFilter: input.namePrefixFilter }),
        ...(input.recursive !== undefined && { recursive: input.recursive.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListThingGroupsCommand = serializeAws_restJson1ListThingGroupsCommand;
const serializeAws_restJson1ListThingGroupsForThingCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/things/{thingName}/thing-groups";
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListThingGroupsForThingCommand = serializeAws_restJson1ListThingGroupsForThingCommand;
const serializeAws_restJson1ListThingPrincipalsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/things/{thingName}/principals";
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListThingPrincipalsCommand = serializeAws_restJson1ListThingPrincipalsCommand;
const serializeAws_restJson1ListThingRegistrationTaskReportsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-registration-tasks/{taskId}/reports";
    if (input.taskId !== undefined) {
        const labelValue = input.taskId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: taskId.");
        }
        resolvedPath = resolvedPath.replace("{taskId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: taskId.");
    }
    const query = {
        ...(input.reportType !== undefined && { reportType: input.reportType }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListThingRegistrationTaskReportsCommand = serializeAws_restJson1ListThingRegistrationTaskReportsCommand;
const serializeAws_restJson1ListThingRegistrationTasksCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-registration-tasks";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.status !== undefined && { status: input.status }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListThingRegistrationTasksCommand = serializeAws_restJson1ListThingRegistrationTasksCommand;
const serializeAws_restJson1ListThingsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/things";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.attributeName !== undefined && { attributeName: input.attributeName }),
        ...(input.attributeValue !== undefined && { attributeValue: input.attributeValue }),
        ...(input.thingTypeName !== undefined && { thingTypeName: input.thingTypeName }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListThingsCommand = serializeAws_restJson1ListThingsCommand;
const serializeAws_restJson1ListThingsInBillingGroupCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/billing-groups/{billingGroupName}/things";
    if (input.billingGroupName !== undefined) {
        const labelValue = input.billingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: billingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{billingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: billingGroupName.");
    }
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListThingsInBillingGroupCommand = serializeAws_restJson1ListThingsInBillingGroupCommand;
const serializeAws_restJson1ListThingsInThingGroupCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-groups/{thingGroupName}/things";
    if (input.thingGroupName !== undefined) {
        const labelValue = input.thingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{thingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingGroupName.");
    }
    const query = {
        ...(input.recursive !== undefined && { recursive: input.recursive.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListThingsInThingGroupCommand = serializeAws_restJson1ListThingsInThingGroupCommand;
const serializeAws_restJson1ListThingTypesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-types";
    const query = {
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.thingTypeName !== undefined && { thingTypeName: input.thingTypeName }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListThingTypesCommand = serializeAws_restJson1ListThingTypesCommand;
const serializeAws_restJson1ListTopicRuleDestinationsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/destinations";
    const query = {
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListTopicRuleDestinationsCommand = serializeAws_restJson1ListTopicRuleDestinationsCommand;
const serializeAws_restJson1ListTopicRulesCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/rules";
    const query = {
        ...(input.topic !== undefined && { topic: input.topic }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.ruleDisabled !== undefined && { ruleDisabled: input.ruleDisabled.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListTopicRulesCommand = serializeAws_restJson1ListTopicRulesCommand;
const serializeAws_restJson1ListV2LoggingLevelsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/v2LoggingLevel";
    const query = {
        ...(input.targetType !== undefined && { targetType: input.targetType }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListV2LoggingLevelsCommand = serializeAws_restJson1ListV2LoggingLevelsCommand;
const serializeAws_restJson1ListViolationEventsCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/violation-events";
    const query = {
        ...(input.startTime !== undefined && { startTime: (input.startTime.toISOString().split(".")[0] + "Z").toString() }),
        ...(input.endTime !== undefined && { endTime: (input.endTime.toISOString().split(".")[0] + "Z").toString() }),
        ...(input.thingName !== undefined && { thingName: input.thingName }),
        ...(input.securityProfileName !== undefined && { securityProfileName: input.securityProfileName }),
        ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
        ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListViolationEventsCommand = serializeAws_restJson1ListViolationEventsCommand;
const serializeAws_restJson1RegisterCACertificateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/cacertificate";
    const query = {
        ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
        ...(input.allowAutoRegistration !== undefined && { allowAutoRegistration: input.allowAutoRegistration.toString() }),
    };
    let body;
    body = JSON.stringify({
        ...(input.caCertificate !== undefined && input.caCertificate !== null && { caCertificate: input.caCertificate }),
        ...(input.registrationConfig !== undefined &&
            input.registrationConfig !== null && {
            registrationConfig: serializeAws_restJson1RegistrationConfig(input.registrationConfig, context),
        }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.verificationCertificate !== undefined &&
            input.verificationCertificate !== null && { verificationCertificate: input.verificationCertificate }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1RegisterCACertificateCommand = serializeAws_restJson1RegisterCACertificateCommand;
const serializeAws_restJson1RegisterCertificateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/certificate/register";
    const query = {
        ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
    };
    let body;
    body = JSON.stringify({
        ...(input.caCertificatePem !== undefined &&
            input.caCertificatePem !== null && { caCertificatePem: input.caCertificatePem }),
        ...(input.certificatePem !== undefined &&
            input.certificatePem !== null && { certificatePem: input.certificatePem }),
        ...(input.status !== undefined && input.status !== null && { status: input.status }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1RegisterCertificateCommand = serializeAws_restJson1RegisterCertificateCommand;
const serializeAws_restJson1RegisterCertificateWithoutCACommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/certificate/register-no-ca";
    let body;
    body = JSON.stringify({
        ...(input.certificatePem !== undefined &&
            input.certificatePem !== null && { certificatePem: input.certificatePem }),
        ...(input.status !== undefined && input.status !== null && { status: input.status }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1RegisterCertificateWithoutCACommand = serializeAws_restJson1RegisterCertificateWithoutCACommand;
const serializeAws_restJson1RegisterThingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/things";
    let body;
    body = JSON.stringify({
        ...(input.parameters !== undefined &&
            input.parameters !== null && { parameters: serializeAws_restJson1Parameters(input.parameters, context) }),
        ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1RegisterThingCommand = serializeAws_restJson1RegisterThingCommand;
const serializeAws_restJson1RejectCertificateTransferCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/reject-certificate-transfer/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    let body;
    body = JSON.stringify({
        ...(input.rejectReason !== undefined && input.rejectReason !== null && { rejectReason: input.rejectReason }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1RejectCertificateTransferCommand = serializeAws_restJson1RejectCertificateTransferCommand;
const serializeAws_restJson1RemoveThingFromBillingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/billing-groups/removeThingFromBillingGroup";
    let body;
    body = JSON.stringify({
        ...(input.billingGroupArn !== undefined &&
            input.billingGroupArn !== null && { billingGroupArn: input.billingGroupArn }),
        ...(input.billingGroupName !== undefined &&
            input.billingGroupName !== null && { billingGroupName: input.billingGroupName }),
        ...(input.thingArn !== undefined && input.thingArn !== null && { thingArn: input.thingArn }),
        ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1RemoveThingFromBillingGroupCommand = serializeAws_restJson1RemoveThingFromBillingGroupCommand;
const serializeAws_restJson1RemoveThingFromThingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/thing-groups/removeThingFromThingGroup";
    let body;
    body = JSON.stringify({
        ...(input.thingArn !== undefined && input.thingArn !== null && { thingArn: input.thingArn }),
        ...(input.thingGroupArn !== undefined && input.thingGroupArn !== null && { thingGroupArn: input.thingGroupArn }),
        ...(input.thingGroupName !== undefined &&
            input.thingGroupName !== null && { thingGroupName: input.thingGroupName }),
        ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1RemoveThingFromThingGroupCommand = serializeAws_restJson1RemoveThingFromThingGroupCommand;
const serializeAws_restJson1ReplaceTopicRuleCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/rules/{ruleName}";
    if (input.ruleName !== undefined) {
        const labelValue = input.ruleName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: ruleName.");
        }
        resolvedPath = resolvedPath.replace("{ruleName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: ruleName.");
    }
    let body;
    if (input.topicRulePayload !== undefined) {
        body = serializeAws_restJson1TopicRulePayload(input.topicRulePayload, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1ReplaceTopicRuleCommand = serializeAws_restJson1ReplaceTopicRuleCommand;
const serializeAws_restJson1SearchIndexCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/indices/search";
    let body;
    body = JSON.stringify({
        ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
        ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
        ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
        ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
        ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1SearchIndexCommand = serializeAws_restJson1SearchIndexCommand;
const serializeAws_restJson1SetDefaultAuthorizerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/default-authorizer";
    let body;
    body = JSON.stringify({
        ...(input.authorizerName !== undefined &&
            input.authorizerName !== null && { authorizerName: input.authorizerName }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1SetDefaultAuthorizerCommand = serializeAws_restJson1SetDefaultAuthorizerCommand;
const serializeAws_restJson1SetDefaultPolicyVersionCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/policies/{policyName}/version/{policyVersionId}";
    if (input.policyName !== undefined) {
        const labelValue = input.policyName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyName.");
        }
        resolvedPath = resolvedPath.replace("{policyName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyName.");
    }
    if (input.policyVersionId !== undefined) {
        const labelValue = input.policyVersionId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: policyVersionId.");
        }
        resolvedPath = resolvedPath.replace("{policyVersionId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: policyVersionId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1SetDefaultPolicyVersionCommand = serializeAws_restJson1SetDefaultPolicyVersionCommand;
const serializeAws_restJson1SetLoggingOptionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/loggingOptions";
    let body;
    if (input.loggingOptionsPayload !== undefined) {
        body = serializeAws_restJson1LoggingOptionsPayload(input.loggingOptionsPayload, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1SetLoggingOptionsCommand = serializeAws_restJson1SetLoggingOptionsCommand;
const serializeAws_restJson1SetV2LoggingLevelCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/v2LoggingLevel";
    let body;
    body = JSON.stringify({
        ...(input.logLevel !== undefined && input.logLevel !== null && { logLevel: input.logLevel }),
        ...(input.logTarget !== undefined &&
            input.logTarget !== null && { logTarget: serializeAws_restJson1LogTarget(input.logTarget, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1SetV2LoggingLevelCommand = serializeAws_restJson1SetV2LoggingLevelCommand;
const serializeAws_restJson1SetV2LoggingOptionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/v2LoggingOptions";
    let body;
    body = JSON.stringify({
        ...(input.defaultLogLevel !== undefined &&
            input.defaultLogLevel !== null && { defaultLogLevel: input.defaultLogLevel }),
        ...(input.disableAllLogs !== undefined &&
            input.disableAllLogs !== null && { disableAllLogs: input.disableAllLogs }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1SetV2LoggingOptionsCommand = serializeAws_restJson1SetV2LoggingOptionsCommand;
const serializeAws_restJson1StartAuditMitigationActionsTaskCommand = async (input, context) => {
    var _a;
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/mitigationactions/tasks/{taskId}";
    if (input.taskId !== undefined) {
        const labelValue = input.taskId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: taskId.");
        }
        resolvedPath = resolvedPath.replace("{taskId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: taskId.");
    }
    let body;
    body = JSON.stringify({
        ...(input.auditCheckToActionsMapping !== undefined &&
            input.auditCheckToActionsMapping !== null && {
            auditCheckToActionsMapping: serializeAws_restJson1AuditCheckToActionsMapping(input.auditCheckToActionsMapping, context),
        }),
        clientRequestToken: (_a = input.clientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
        ...(input.target !== undefined &&
            input.target !== null && {
            target: serializeAws_restJson1AuditMitigationActionsTaskTarget(input.target, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1StartAuditMitigationActionsTaskCommand = serializeAws_restJson1StartAuditMitigationActionsTaskCommand;
const serializeAws_restJson1StartOnDemandAuditTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/tasks";
    let body;
    body = JSON.stringify({
        ...(input.targetCheckNames !== undefined &&
            input.targetCheckNames !== null && {
            targetCheckNames: serializeAws_restJson1TargetAuditCheckNames(input.targetCheckNames, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1StartOnDemandAuditTaskCommand = serializeAws_restJson1StartOnDemandAuditTaskCommand;
const serializeAws_restJson1StartThingRegistrationTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/thing-registration-tasks";
    let body;
    body = JSON.stringify({
        ...(input.inputFileBucket !== undefined &&
            input.inputFileBucket !== null && { inputFileBucket: input.inputFileBucket }),
        ...(input.inputFileKey !== undefined && input.inputFileKey !== null && { inputFileKey: input.inputFileKey }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1StartThingRegistrationTaskCommand = serializeAws_restJson1StartThingRegistrationTaskCommand;
const serializeAws_restJson1StopThingRegistrationTaskCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/thing-registration-tasks/{taskId}/cancel";
    if (input.taskId !== undefined) {
        const labelValue = input.taskId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: taskId.");
        }
        resolvedPath = resolvedPath.replace("{taskId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: taskId.");
    }
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1StopThingRegistrationTaskCommand = serializeAws_restJson1StopThingRegistrationTaskCommand;
const serializeAws_restJson1TagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/tags";
    let body;
    body = JSON.stringify({
        ...(input.resourceArn !== undefined && input.resourceArn !== null && { resourceArn: input.resourceArn }),
        ...(input.tags !== undefined &&
            input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1TagResourceCommand = serializeAws_restJson1TagResourceCommand;
const serializeAws_restJson1TestAuthorizationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/test-authorization";
    const query = {
        ...(input.clientId !== undefined && { clientId: input.clientId }),
    };
    let body;
    body = JSON.stringify({
        ...(input.authInfos !== undefined &&
            input.authInfos !== null && { authInfos: serializeAws_restJson1AuthInfos(input.authInfos, context) }),
        ...(input.cognitoIdentityPoolId !== undefined &&
            input.cognitoIdentityPoolId !== null && { cognitoIdentityPoolId: input.cognitoIdentityPoolId }),
        ...(input.policyNamesToAdd !== undefined &&
            input.policyNamesToAdd !== null && {
            policyNamesToAdd: serializeAws_restJson1PolicyNames(input.policyNamesToAdd, context),
        }),
        ...(input.policyNamesToSkip !== undefined &&
            input.policyNamesToSkip !== null && {
            policyNamesToSkip: serializeAws_restJson1PolicyNames(input.policyNamesToSkip, context),
        }),
        ...(input.principal !== undefined && input.principal !== null && { principal: input.principal }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1TestAuthorizationCommand = serializeAws_restJson1TestAuthorizationCommand;
const serializeAws_restJson1TestInvokeAuthorizerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/authorizer/{authorizerName}/test";
    if (input.authorizerName !== undefined) {
        const labelValue = input.authorizerName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: authorizerName.");
        }
        resolvedPath = resolvedPath.replace("{authorizerName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: authorizerName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.httpContext !== undefined &&
            input.httpContext !== null && { httpContext: serializeAws_restJson1HttpContext(input.httpContext, context) }),
        ...(input.mqttContext !== undefined &&
            input.mqttContext !== null && { mqttContext: serializeAws_restJson1MqttContext(input.mqttContext, context) }),
        ...(input.tlsContext !== undefined &&
            input.tlsContext !== null && { tlsContext: serializeAws_restJson1TlsContext(input.tlsContext, context) }),
        ...(input.token !== undefined && input.token !== null && { token: input.token }),
        ...(input.tokenSignature !== undefined &&
            input.tokenSignature !== null && { tokenSignature: input.tokenSignature }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1TestInvokeAuthorizerCommand = serializeAws_restJson1TestInvokeAuthorizerCommand;
const serializeAws_restJson1TransferCertificateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/transfer-certificate/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    const query = {
        ...(input.targetAwsAccount !== undefined && { targetAwsAccount: input.targetAwsAccount }),
    };
    let body;
    body = JSON.stringify({
        ...(input.transferMessage !== undefined &&
            input.transferMessage !== null && { transferMessage: input.transferMessage }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1TransferCertificateCommand = serializeAws_restJson1TransferCertificateCommand;
const serializeAws_restJson1UntagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/untag";
    let body;
    body = JSON.stringify({
        ...(input.resourceArn !== undefined && input.resourceArn !== null && { resourceArn: input.resourceArn }),
        ...(input.tagKeys !== undefined &&
            input.tagKeys !== null && { tagKeys: serializeAws_restJson1TagKeyList(input.tagKeys, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UntagResourceCommand = serializeAws_restJson1UntagResourceCommand;
const serializeAws_restJson1UpdateAccountAuditConfigurationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/configuration";
    let body;
    body = JSON.stringify({
        ...(input.auditCheckConfigurations !== undefined &&
            input.auditCheckConfigurations !== null && {
            auditCheckConfigurations: serializeAws_restJson1AuditCheckConfigurations(input.auditCheckConfigurations, context),
        }),
        ...(input.auditNotificationTargetConfigurations !== undefined &&
            input.auditNotificationTargetConfigurations !== null && {
            auditNotificationTargetConfigurations: serializeAws_restJson1AuditNotificationTargetConfigurations(input.auditNotificationTargetConfigurations, context),
        }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateAccountAuditConfigurationCommand = serializeAws_restJson1UpdateAccountAuditConfigurationCommand;
const serializeAws_restJson1UpdateAuditSuppressionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/suppressions/update";
    let body;
    body = JSON.stringify({
        ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.expirationDate !== undefined &&
            input.expirationDate !== null && { expirationDate: Math.round(input.expirationDate.getTime() / 1000) }),
        ...(input.resourceIdentifier !== undefined &&
            input.resourceIdentifier !== null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
        ...(input.suppressIndefinitely !== undefined &&
            input.suppressIndefinitely !== null && { suppressIndefinitely: input.suppressIndefinitely }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateAuditSuppressionCommand = serializeAws_restJson1UpdateAuditSuppressionCommand;
const serializeAws_restJson1UpdateAuthorizerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/authorizer/{authorizerName}";
    if (input.authorizerName !== undefined) {
        const labelValue = input.authorizerName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: authorizerName.");
        }
        resolvedPath = resolvedPath.replace("{authorizerName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: authorizerName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.authorizerFunctionArn !== undefined &&
            input.authorizerFunctionArn !== null && { authorizerFunctionArn: input.authorizerFunctionArn }),
        ...(input.status !== undefined && input.status !== null && { status: input.status }),
        ...(input.tokenKeyName !== undefined && input.tokenKeyName !== null && { tokenKeyName: input.tokenKeyName }),
        ...(input.tokenSigningPublicKeys !== undefined &&
            input.tokenSigningPublicKeys !== null && {
            tokenSigningPublicKeys: serializeAws_restJson1PublicKeyMap(input.tokenSigningPublicKeys, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateAuthorizerCommand = serializeAws_restJson1UpdateAuthorizerCommand;
const serializeAws_restJson1UpdateBillingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/billing-groups/{billingGroupName}";
    if (input.billingGroupName !== undefined) {
        const labelValue = input.billingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: billingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{billingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: billingGroupName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.billingGroupProperties !== undefined &&
            input.billingGroupProperties !== null && {
            billingGroupProperties: serializeAws_restJson1BillingGroupProperties(input.billingGroupProperties, context),
        }),
        ...(input.expectedVersion !== undefined &&
            input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateBillingGroupCommand = serializeAws_restJson1UpdateBillingGroupCommand;
const serializeAws_restJson1UpdateCACertificateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/cacertificate/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    const query = {
        ...(input.newStatus !== undefined && { newStatus: input.newStatus }),
        ...(input.newAutoRegistrationStatus !== undefined && {
            newAutoRegistrationStatus: input.newAutoRegistrationStatus,
        }),
    };
    let body;
    body = JSON.stringify({
        ...(input.registrationConfig !== undefined &&
            input.registrationConfig !== null && {
            registrationConfig: serializeAws_restJson1RegistrationConfig(input.registrationConfig, context),
        }),
        ...(input.removeAutoRegistration !== undefined &&
            input.removeAutoRegistration !== null && { removeAutoRegistration: input.removeAutoRegistration }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1UpdateCACertificateCommand = serializeAws_restJson1UpdateCACertificateCommand;
const serializeAws_restJson1UpdateCertificateCommand = async (input, context) => {
    const headers = {};
    let resolvedPath = "/certificates/{certificateId}";
    if (input.certificateId !== undefined) {
        const labelValue = input.certificateId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: certificateId.");
        }
        resolvedPath = resolvedPath.replace("{certificateId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: certificateId.");
    }
    const query = {
        ...(input.newStatus !== undefined && { newStatus: input.newStatus }),
    };
    let body;
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1UpdateCertificateCommand = serializeAws_restJson1UpdateCertificateCommand;
const serializeAws_restJson1UpdateDimensionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/dimensions/{name}";
    if (input.name !== undefined) {
        const labelValue = input.name;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: name.");
        }
        resolvedPath = resolvedPath.replace("{name}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: name.");
    }
    let body;
    body = JSON.stringify({
        ...(input.stringValues !== undefined &&
            input.stringValues !== null && {
            stringValues: serializeAws_restJson1DimensionStringValues(input.stringValues, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateDimensionCommand = serializeAws_restJson1UpdateDimensionCommand;
const serializeAws_restJson1UpdateDomainConfigurationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/domainConfigurations/{domainConfigurationName}";
    if (input.domainConfigurationName !== undefined) {
        const labelValue = input.domainConfigurationName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: domainConfigurationName.");
        }
        resolvedPath = resolvedPath.replace("{domainConfigurationName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: domainConfigurationName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.authorizerConfig !== undefined &&
            input.authorizerConfig !== null && {
            authorizerConfig: serializeAws_restJson1AuthorizerConfig(input.authorizerConfig, context),
        }),
        ...(input.domainConfigurationStatus !== undefined &&
            input.domainConfigurationStatus !== null && { domainConfigurationStatus: input.domainConfigurationStatus }),
        ...(input.removeAuthorizerConfig !== undefined &&
            input.removeAuthorizerConfig !== null && { removeAuthorizerConfig: input.removeAuthorizerConfig }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateDomainConfigurationCommand = serializeAws_restJson1UpdateDomainConfigurationCommand;
const serializeAws_restJson1UpdateDynamicThingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/dynamic-thing-groups/{thingGroupName}";
    if (input.thingGroupName !== undefined) {
        const labelValue = input.thingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{thingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingGroupName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.expectedVersion !== undefined &&
            input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
        ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
        ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
        ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
        ...(input.thingGroupProperties !== undefined &&
            input.thingGroupProperties !== null && {
            thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateDynamicThingGroupCommand = serializeAws_restJson1UpdateDynamicThingGroupCommand;
const serializeAws_restJson1UpdateEventConfigurationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/event-configurations";
    let body;
    body = JSON.stringify({
        ...(input.eventConfigurations !== undefined &&
            input.eventConfigurations !== null && {
            eventConfigurations: serializeAws_restJson1EventConfigurations(input.eventConfigurations, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateEventConfigurationsCommand = serializeAws_restJson1UpdateEventConfigurationsCommand;
const serializeAws_restJson1UpdateIndexingConfigurationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/indexing/config";
    let body;
    body = JSON.stringify({
        ...(input.thingGroupIndexingConfiguration !== undefined &&
            input.thingGroupIndexingConfiguration !== null && {
            thingGroupIndexingConfiguration: serializeAws_restJson1ThingGroupIndexingConfiguration(input.thingGroupIndexingConfiguration, context),
        }),
        ...(input.thingIndexingConfiguration !== undefined &&
            input.thingIndexingConfiguration !== null && {
            thingIndexingConfiguration: serializeAws_restJson1ThingIndexingConfiguration(input.thingIndexingConfiguration, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateIndexingConfigurationCommand = serializeAws_restJson1UpdateIndexingConfigurationCommand;
const serializeAws_restJson1UpdateJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/jobs/{jobId}";
    if (input.jobId !== undefined) {
        const labelValue = input.jobId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: jobId.");
        }
        resolvedPath = resolvedPath.replace("{jobId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: jobId.");
    }
    const query = {
        ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
    };
    let body;
    body = JSON.stringify({
        ...(input.abortConfig !== undefined &&
            input.abortConfig !== null && { abortConfig: serializeAws_restJson1AbortConfig(input.abortConfig, context) }),
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.jobExecutionsRolloutConfig !== undefined &&
            input.jobExecutionsRolloutConfig !== null && {
            jobExecutionsRolloutConfig: serializeAws_restJson1JobExecutionsRolloutConfig(input.jobExecutionsRolloutConfig, context),
        }),
        ...(input.presignedUrlConfig !== undefined &&
            input.presignedUrlConfig !== null && {
            presignedUrlConfig: serializeAws_restJson1PresignedUrlConfig(input.presignedUrlConfig, context),
        }),
        ...(input.timeoutConfig !== undefined &&
            input.timeoutConfig !== null && {
            timeoutConfig: serializeAws_restJson1TimeoutConfig(input.timeoutConfig, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1UpdateJobCommand = serializeAws_restJson1UpdateJobCommand;
const serializeAws_restJson1UpdateMitigationActionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/mitigationactions/actions/{actionName}";
    if (input.actionName !== undefined) {
        const labelValue = input.actionName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: actionName.");
        }
        resolvedPath = resolvedPath.replace("{actionName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: actionName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.actionParams !== undefined &&
            input.actionParams !== null && {
            actionParams: serializeAws_restJson1MitigationActionParams(input.actionParams, context),
        }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateMitigationActionCommand = serializeAws_restJson1UpdateMitigationActionCommand;
const serializeAws_restJson1UpdateProvisioningTemplateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/provisioning-templates/{templateName}";
    if (input.templateName !== undefined) {
        const labelValue = input.templateName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: templateName.");
        }
        resolvedPath = resolvedPath.replace("{templateName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: templateName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.defaultVersionId !== undefined &&
            input.defaultVersionId !== null && { defaultVersionId: input.defaultVersionId }),
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.enabled !== undefined && input.enabled !== null && { enabled: input.enabled }),
        ...(input.preProvisioningHook !== undefined &&
            input.preProvisioningHook !== null && {
            preProvisioningHook: serializeAws_restJson1ProvisioningHook(input.preProvisioningHook, context),
        }),
        ...(input.provisioningRoleArn !== undefined &&
            input.provisioningRoleArn !== null && { provisioningRoleArn: input.provisioningRoleArn }),
        ...(input.removePreProvisioningHook !== undefined &&
            input.removePreProvisioningHook !== null && { removePreProvisioningHook: input.removePreProvisioningHook }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateProvisioningTemplateCommand = serializeAws_restJson1UpdateProvisioningTemplateCommand;
const serializeAws_restJson1UpdateRoleAliasCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/role-aliases/{roleAlias}";
    if (input.roleAlias !== undefined) {
        const labelValue = input.roleAlias;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: roleAlias.");
        }
        resolvedPath = resolvedPath.replace("{roleAlias}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: roleAlias.");
    }
    let body;
    body = JSON.stringify({
        ...(input.credentialDurationSeconds !== undefined &&
            input.credentialDurationSeconds !== null && { credentialDurationSeconds: input.credentialDurationSeconds }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateRoleAliasCommand = serializeAws_restJson1UpdateRoleAliasCommand;
const serializeAws_restJson1UpdateScheduledAuditCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/audit/scheduledaudits/{scheduledAuditName}";
    if (input.scheduledAuditName !== undefined) {
        const labelValue = input.scheduledAuditName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: scheduledAuditName.");
        }
        resolvedPath = resolvedPath.replace("{scheduledAuditName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: scheduledAuditName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.dayOfMonth !== undefined && input.dayOfMonth !== null && { dayOfMonth: input.dayOfMonth }),
        ...(input.dayOfWeek !== undefined && input.dayOfWeek !== null && { dayOfWeek: input.dayOfWeek }),
        ...(input.frequency !== undefined && input.frequency !== null && { frequency: input.frequency }),
        ...(input.targetCheckNames !== undefined &&
            input.targetCheckNames !== null && {
            targetCheckNames: serializeAws_restJson1TargetAuditCheckNames(input.targetCheckNames, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateScheduledAuditCommand = serializeAws_restJson1UpdateScheduledAuditCommand;
const serializeAws_restJson1UpdateSecurityProfileCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/security-profiles/{securityProfileName}";
    if (input.securityProfileName !== undefined) {
        const labelValue = input.securityProfileName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: securityProfileName.");
        }
        resolvedPath = resolvedPath.replace("{securityProfileName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: securityProfileName.");
    }
    const query = {
        ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
    };
    let body;
    body = JSON.stringify({
        ...(input.additionalMetricsToRetain !== undefined &&
            input.additionalMetricsToRetain !== null && {
            additionalMetricsToRetain: serializeAws_restJson1AdditionalMetricsToRetainList(input.additionalMetricsToRetain, context),
        }),
        ...(input.additionalMetricsToRetainV2 !== undefined &&
            input.additionalMetricsToRetainV2 !== null && {
            additionalMetricsToRetainV2: serializeAws_restJson1AdditionalMetricsToRetainV2List(input.additionalMetricsToRetainV2, context),
        }),
        ...(input.alertTargets !== undefined &&
            input.alertTargets !== null && { alertTargets: serializeAws_restJson1AlertTargets(input.alertTargets, context) }),
        ...(input.behaviors !== undefined &&
            input.behaviors !== null && { behaviors: serializeAws_restJson1Behaviors(input.behaviors, context) }),
        ...(input.deleteAdditionalMetricsToRetain !== undefined &&
            input.deleteAdditionalMetricsToRetain !== null && {
            deleteAdditionalMetricsToRetain: input.deleteAdditionalMetricsToRetain,
        }),
        ...(input.deleteAlertTargets !== undefined &&
            input.deleteAlertTargets !== null && { deleteAlertTargets: input.deleteAlertTargets }),
        ...(input.deleteBehaviors !== undefined &&
            input.deleteBehaviors !== null && { deleteBehaviors: input.deleteBehaviors }),
        ...(input.securityProfileDescription !== undefined &&
            input.securityProfileDescription !== null && { securityProfileDescription: input.securityProfileDescription }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1UpdateSecurityProfileCommand = serializeAws_restJson1UpdateSecurityProfileCommand;
const serializeAws_restJson1UpdateStreamCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/streams/{streamId}";
    if (input.streamId !== undefined) {
        const labelValue = input.streamId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: streamId.");
        }
        resolvedPath = resolvedPath.replace("{streamId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: streamId.");
    }
    let body;
    body = JSON.stringify({
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.files !== undefined &&
            input.files !== null && { files: serializeAws_restJson1StreamFiles(input.files, context) }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateStreamCommand = serializeAws_restJson1UpdateStreamCommand;
const serializeAws_restJson1UpdateThingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/things/{thingName}";
    if (input.thingName !== undefined) {
        const labelValue = input.thingName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingName.");
        }
        resolvedPath = resolvedPath.replace("{thingName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.attributePayload !== undefined &&
            input.attributePayload !== null && {
            attributePayload: serializeAws_restJson1AttributePayload(input.attributePayload, context),
        }),
        ...(input.expectedVersion !== undefined &&
            input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
        ...(input.removeThingType !== undefined &&
            input.removeThingType !== null && { removeThingType: input.removeThingType }),
        ...(input.thingTypeName !== undefined && input.thingTypeName !== null && { thingTypeName: input.thingTypeName }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateThingCommand = serializeAws_restJson1UpdateThingCommand;
const serializeAws_restJson1UpdateThingGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/thing-groups/{thingGroupName}";
    if (input.thingGroupName !== undefined) {
        const labelValue = input.thingGroupName;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: thingGroupName.");
        }
        resolvedPath = resolvedPath.replace("{thingGroupName}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: thingGroupName.");
    }
    let body;
    body = JSON.stringify({
        ...(input.expectedVersion !== undefined &&
            input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
        ...(input.thingGroupProperties !== undefined &&
            input.thingGroupProperties !== null && {
            thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
        }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateThingGroupCommand = serializeAws_restJson1UpdateThingGroupCommand;
const serializeAws_restJson1UpdateThingGroupsForThingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/thing-groups/updateThingGroupsForThing";
    let body;
    body = JSON.stringify({
        ...(input.overrideDynamicGroups !== undefined &&
            input.overrideDynamicGroups !== null && { overrideDynamicGroups: input.overrideDynamicGroups }),
        ...(input.thingGroupsToAdd !== undefined &&
            input.thingGroupsToAdd !== null && {
            thingGroupsToAdd: serializeAws_restJson1ThingGroupList(input.thingGroupsToAdd, context),
        }),
        ...(input.thingGroupsToRemove !== undefined &&
            input.thingGroupsToRemove !== null && {
            thingGroupsToRemove: serializeAws_restJson1ThingGroupList(input.thingGroupsToRemove, context),
        }),
        ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateThingGroupsForThingCommand = serializeAws_restJson1UpdateThingGroupsForThingCommand;
const serializeAws_restJson1UpdateTopicRuleDestinationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/destinations";
    let body;
    body = JSON.stringify({
        ...(input.arn !== undefined && input.arn !== null && { arn: input.arn }),
        ...(input.status !== undefined && input.status !== null && { status: input.status }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1UpdateTopicRuleDestinationCommand = serializeAws_restJson1UpdateTopicRuleDestinationCommand;
const serializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = "/security-profile-behaviors/validate";
    let body;
    body = JSON.stringify({
        ...(input.behaviors !== undefined &&
            input.behaviors !== null && { behaviors: serializeAws_restJson1Behaviors(input.behaviors, context) }),
    });
    const { hostname, protocol = "https", port } = await context.endpoint();
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = serializeAws_restJson1ValidateSecurityProfileBehaviorsCommand;
const deserializeAws_restJson1AcceptCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AcceptCertificateTransferCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AcceptCertificateTransferCommand = deserializeAws_restJson1AcceptCertificateTransferCommand;
const deserializeAws_restJson1AcceptCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            response = {
                ...(await deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AddThingToBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AddThingToBillingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AddThingToBillingGroupCommand = deserializeAws_restJson1AddThingToBillingGroupCommand;
const deserializeAws_restJson1AddThingToBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AddThingToThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AddThingToThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AddThingToThingGroupCommand = deserializeAws_restJson1AddThingToThingGroupCommand;
const deserializeAws_restJson1AddThingToThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AssociateTargetsWithJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AssociateTargetsWithJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        description: undefined,
        jobArn: undefined,
        jobId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.description !== undefined && data.description !== null) {
        contents.description = data.description;
    }
    if (data.jobArn !== undefined && data.jobArn !== null) {
        contents.jobArn = data.jobArn;
    }
    if (data.jobId !== undefined && data.jobId !== null) {
        contents.jobId = data.jobId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AssociateTargetsWithJobCommand = deserializeAws_restJson1AssociateTargetsWithJobCommand;
const deserializeAws_restJson1AssociateTargetsWithJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AttachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AttachPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AttachPolicyCommand = deserializeAws_restJson1AttachPolicyCommand;
const deserializeAws_restJson1AttachPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AttachPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AttachPrincipalPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AttachPrincipalPolicyCommand = deserializeAws_restJson1AttachPrincipalPolicyCommand;
const deserializeAws_restJson1AttachPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AttachSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AttachSecurityProfileCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AttachSecurityProfileCommand = deserializeAws_restJson1AttachSecurityProfileCommand;
const deserializeAws_restJson1AttachSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AttachThingPrincipalCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AttachThingPrincipalCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AttachThingPrincipalCommand = deserializeAws_restJson1AttachThingPrincipalCommand;
const deserializeAws_restJson1AttachThingPrincipalCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CancelAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CancelAuditMitigationActionsTaskCommand = deserializeAws_restJson1CancelAuditMitigationActionsTaskCommand;
const deserializeAws_restJson1CancelAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CancelAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelAuditTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CancelAuditTaskCommand = deserializeAws_restJson1CancelAuditTaskCommand;
const deserializeAws_restJson1CancelAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CancelCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelCertificateTransferCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CancelCertificateTransferCommand = deserializeAws_restJson1CancelCertificateTransferCommand;
const deserializeAws_restJson1CancelCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            response = {
                ...(await deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CancelJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        description: undefined,
        jobArn: undefined,
        jobId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.description !== undefined && data.description !== null) {
        contents.description = data.description;
    }
    if (data.jobArn !== undefined && data.jobArn !== null) {
        contents.jobArn = data.jobArn;
    }
    if (data.jobId !== undefined && data.jobId !== null) {
        contents.jobId = data.jobId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CancelJobCommand = deserializeAws_restJson1CancelJobCommand;
const deserializeAws_restJson1CancelJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CancelJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelJobExecutionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CancelJobExecutionCommand = deserializeAws_restJson1CancelJobExecutionCommand;
const deserializeAws_restJson1CancelJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            response = {
                ...(await deserializeAws_restJson1InvalidStateTransitionExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ClearDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ClearDefaultAuthorizerCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ClearDefaultAuthorizerCommand = deserializeAws_restJson1ClearDefaultAuthorizerCommand;
const deserializeAws_restJson1ClearDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ConfirmTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ConfirmTopicRuleDestinationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ConfirmTopicRuleDestinationCommand = deserializeAws_restJson1ConfirmTopicRuleDestinationCommand;
const deserializeAws_restJson1ConfirmTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateAuditSuppressionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateAuditSuppressionCommand = deserializeAws_restJson1CreateAuditSuppressionCommand;
const deserializeAws_restJson1CreateAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateAuthorizerCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        authorizerArn: undefined,
        authorizerName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.authorizerArn !== undefined && data.authorizerArn !== null) {
        contents.authorizerArn = data.authorizerArn;
    }
    if (data.authorizerName !== undefined && data.authorizerName !== null) {
        contents.authorizerName = data.authorizerName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateAuthorizerCommand = deserializeAws_restJson1CreateAuthorizerCommand;
const deserializeAws_restJson1CreateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateBillingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        billingGroupArn: undefined,
        billingGroupId: undefined,
        billingGroupName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.billingGroupArn !== undefined && data.billingGroupArn !== null) {
        contents.billingGroupArn = data.billingGroupArn;
    }
    if (data.billingGroupId !== undefined && data.billingGroupId !== null) {
        contents.billingGroupId = data.billingGroupId;
    }
    if (data.billingGroupName !== undefined && data.billingGroupName !== null) {
        contents.billingGroupName = data.billingGroupName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateBillingGroupCommand = deserializeAws_restJson1CreateBillingGroupCommand;
const deserializeAws_restJson1CreateBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateCertificateFromCsrCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateCertificateFromCsrCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificateArn: undefined,
        certificateId: undefined,
        certificatePem: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificateArn !== undefined && data.certificateArn !== null) {
        contents.certificateArn = data.certificateArn;
    }
    if (data.certificateId !== undefined && data.certificateId !== null) {
        contents.certificateId = data.certificateId;
    }
    if (data.certificatePem !== undefined && data.certificatePem !== null) {
        contents.certificatePem = data.certificatePem;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateCertificateFromCsrCommand = deserializeAws_restJson1CreateCertificateFromCsrCommand;
const deserializeAws_restJson1CreateCertificateFromCsrCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateDimensionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        arn: undefined,
        name: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.arn !== undefined && data.arn !== null) {
        contents.arn = data.arn;
    }
    if (data.name !== undefined && data.name !== null) {
        contents.name = data.name;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateDimensionCommand = deserializeAws_restJson1CreateDimensionCommand;
const deserializeAws_restJson1CreateDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateDomainConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        domainConfigurationArn: undefined,
        domainConfigurationName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.domainConfigurationArn !== undefined && data.domainConfigurationArn !== null) {
        contents.domainConfigurationArn = data.domainConfigurationArn;
    }
    if (data.domainConfigurationName !== undefined && data.domainConfigurationName !== null) {
        contents.domainConfigurationName = data.domainConfigurationName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateDomainConfigurationCommand = deserializeAws_restJson1CreateDomainConfigurationCommand;
const deserializeAws_restJson1CreateDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            response = {
                ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateDynamicThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        indexName: undefined,
        queryString: undefined,
        queryVersion: undefined,
        thingGroupArn: undefined,
        thingGroupId: undefined,
        thingGroupName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.indexName !== undefined && data.indexName !== null) {
        contents.indexName = data.indexName;
    }
    if (data.queryString !== undefined && data.queryString !== null) {
        contents.queryString = data.queryString;
    }
    if (data.queryVersion !== undefined && data.queryVersion !== null) {
        contents.queryVersion = data.queryVersion;
    }
    if (data.thingGroupArn !== undefined && data.thingGroupArn !== null) {
        contents.thingGroupArn = data.thingGroupArn;
    }
    if (data.thingGroupId !== undefined && data.thingGroupId !== null) {
        contents.thingGroupId = data.thingGroupId;
    }
    if (data.thingGroupName !== undefined && data.thingGroupName !== null) {
        contents.thingGroupName = data.thingGroupName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateDynamicThingGroupCommand = deserializeAws_restJson1CreateDynamicThingGroupCommand;
const deserializeAws_restJson1CreateDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            response = {
                ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        description: undefined,
        jobArn: undefined,
        jobId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.description !== undefined && data.description !== null) {
        contents.description = data.description;
    }
    if (data.jobArn !== undefined && data.jobArn !== null) {
        contents.jobArn = data.jobArn;
    }
    if (data.jobId !== undefined && data.jobId !== null) {
        contents.jobId = data.jobId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateJobCommand = deserializeAws_restJson1CreateJobCommand;
const deserializeAws_restJson1CreateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateKeysAndCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateKeysAndCertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificateArn: undefined,
        certificateId: undefined,
        certificatePem: undefined,
        keyPair: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificateArn !== undefined && data.certificateArn !== null) {
        contents.certificateArn = data.certificateArn;
    }
    if (data.certificateId !== undefined && data.certificateId !== null) {
        contents.certificateId = data.certificateId;
    }
    if (data.certificatePem !== undefined && data.certificatePem !== null) {
        contents.certificatePem = data.certificatePem;
    }
    if (data.keyPair !== undefined && data.keyPair !== null) {
        contents.keyPair = deserializeAws_restJson1KeyPair(data.keyPair, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateKeysAndCertificateCommand = deserializeAws_restJson1CreateKeysAndCertificateCommand;
const deserializeAws_restJson1CreateKeysAndCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateMitigationActionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        actionArn: undefined,
        actionId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.actionArn !== undefined && data.actionArn !== null) {
        contents.actionArn = data.actionArn;
    }
    if (data.actionId !== undefined && data.actionId !== null) {
        contents.actionId = data.actionId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateMitigationActionCommand = deserializeAws_restJson1CreateMitigationActionCommand;
const deserializeAws_restJson1CreateMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateOTAUpdateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        awsIotJobArn: undefined,
        awsIotJobId: undefined,
        otaUpdateArn: undefined,
        otaUpdateId: undefined,
        otaUpdateStatus: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.awsIotJobArn !== undefined && data.awsIotJobArn !== null) {
        contents.awsIotJobArn = data.awsIotJobArn;
    }
    if (data.awsIotJobId !== undefined && data.awsIotJobId !== null) {
        contents.awsIotJobId = data.awsIotJobId;
    }
    if (data.otaUpdateArn !== undefined && data.otaUpdateArn !== null) {
        contents.otaUpdateArn = data.otaUpdateArn;
    }
    if (data.otaUpdateId !== undefined && data.otaUpdateId !== null) {
        contents.otaUpdateId = data.otaUpdateId;
    }
    if (data.otaUpdateStatus !== undefined && data.otaUpdateStatus !== null) {
        contents.otaUpdateStatus = data.otaUpdateStatus;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateOTAUpdateCommand = deserializeAws_restJson1CreateOTAUpdateCommand;
const deserializeAws_restJson1CreateOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreatePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreatePolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        policyArn: undefined,
        policyDocument: undefined,
        policyName: undefined,
        policyVersionId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.policyArn !== undefined && data.policyArn !== null) {
        contents.policyArn = data.policyArn;
    }
    if (data.policyDocument !== undefined && data.policyDocument !== null) {
        contents.policyDocument = data.policyDocument;
    }
    if (data.policyName !== undefined && data.policyName !== null) {
        contents.policyName = data.policyName;
    }
    if (data.policyVersionId !== undefined && data.policyVersionId !== null) {
        contents.policyVersionId = data.policyVersionId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreatePolicyCommand = deserializeAws_restJson1CreatePolicyCommand;
const deserializeAws_restJson1CreatePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "MalformedPolicyException":
        case "com.amazonaws.iot#MalformedPolicyException":
            response = {
                ...(await deserializeAws_restJson1MalformedPolicyExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreatePolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreatePolicyVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        isDefaultVersion: undefined,
        policyArn: undefined,
        policyDocument: undefined,
        policyVersionId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
        contents.isDefaultVersion = data.isDefaultVersion;
    }
    if (data.policyArn !== undefined && data.policyArn !== null) {
        contents.policyArn = data.policyArn;
    }
    if (data.policyDocument !== undefined && data.policyDocument !== null) {
        contents.policyDocument = data.policyDocument;
    }
    if (data.policyVersionId !== undefined && data.policyVersionId !== null) {
        contents.policyVersionId = data.policyVersionId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreatePolicyVersionCommand = deserializeAws_restJson1CreatePolicyVersionCommand;
const deserializeAws_restJson1CreatePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "MalformedPolicyException":
        case "com.amazonaws.iot#MalformedPolicyException":
            response = {
                ...(await deserializeAws_restJson1MalformedPolicyExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionsLimitExceededException":
        case "com.amazonaws.iot#VersionsLimitExceededException":
            response = {
                ...(await deserializeAws_restJson1VersionsLimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateProvisioningClaimCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateProvisioningClaimCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificateId: undefined,
        certificatePem: undefined,
        expiration: undefined,
        keyPair: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificateId !== undefined && data.certificateId !== null) {
        contents.certificateId = data.certificateId;
    }
    if (data.certificatePem !== undefined && data.certificatePem !== null) {
        contents.certificatePem = data.certificatePem;
    }
    if (data.expiration !== undefined && data.expiration !== null) {
        contents.expiration = new Date(Math.round(data.expiration * 1000));
    }
    if (data.keyPair !== undefined && data.keyPair !== null) {
        contents.keyPair = deserializeAws_restJson1KeyPair(data.keyPair, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateProvisioningClaimCommand = deserializeAws_restJson1CreateProvisioningClaimCommand;
const deserializeAws_restJson1CreateProvisioningClaimCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateProvisioningTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        defaultVersionId: undefined,
        templateArn: undefined,
        templateName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.defaultVersionId !== undefined && data.defaultVersionId !== null) {
        contents.defaultVersionId = data.defaultVersionId;
    }
    if (data.templateArn !== undefined && data.templateArn !== null) {
        contents.templateArn = data.templateArn;
    }
    if (data.templateName !== undefined && data.templateName !== null) {
        contents.templateName = data.templateName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateProvisioningTemplateCommand = deserializeAws_restJson1CreateProvisioningTemplateCommand;
const deserializeAws_restJson1CreateProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        isDefaultVersion: undefined,
        templateArn: undefined,
        templateName: undefined,
        versionId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
        contents.isDefaultVersion = data.isDefaultVersion;
    }
    if (data.templateArn !== undefined && data.templateArn !== null) {
        contents.templateArn = data.templateArn;
    }
    if (data.templateName !== undefined && data.templateName !== null) {
        contents.templateName = data.templateName;
    }
    if (data.versionId !== undefined && data.versionId !== null) {
        contents.versionId = data.versionId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateProvisioningTemplateVersionCommand = deserializeAws_restJson1CreateProvisioningTemplateVersionCommand;
const deserializeAws_restJson1CreateProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionsLimitExceededException":
        case "com.amazonaws.iot#VersionsLimitExceededException":
            response = {
                ...(await deserializeAws_restJson1VersionsLimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateRoleAliasCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        roleAlias: undefined,
        roleAliasArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.roleAlias !== undefined && data.roleAlias !== null) {
        contents.roleAlias = data.roleAlias;
    }
    if (data.roleAliasArn !== undefined && data.roleAliasArn !== null) {
        contents.roleAliasArn = data.roleAliasArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateRoleAliasCommand = deserializeAws_restJson1CreateRoleAliasCommand;
const deserializeAws_restJson1CreateRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateScheduledAuditCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        scheduledAuditArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.scheduledAuditArn !== undefined && data.scheduledAuditArn !== null) {
        contents.scheduledAuditArn = data.scheduledAuditArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateScheduledAuditCommand = deserializeAws_restJson1CreateScheduledAuditCommand;
const deserializeAws_restJson1CreateScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateSecurityProfileCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        securityProfileArn: undefined,
        securityProfileName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.securityProfileArn !== undefined && data.securityProfileArn !== null) {
        contents.securityProfileArn = data.securityProfileArn;
    }
    if (data.securityProfileName !== undefined && data.securityProfileName !== null) {
        contents.securityProfileName = data.securityProfileName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateSecurityProfileCommand = deserializeAws_restJson1CreateSecurityProfileCommand;
const deserializeAws_restJson1CreateSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateStreamCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        description: undefined,
        streamArn: undefined,
        streamId: undefined,
        streamVersion: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.description !== undefined && data.description !== null) {
        contents.description = data.description;
    }
    if (data.streamArn !== undefined && data.streamArn !== null) {
        contents.streamArn = data.streamArn;
    }
    if (data.streamId !== undefined && data.streamId !== null) {
        contents.streamId = data.streamId;
    }
    if (data.streamVersion !== undefined && data.streamVersion !== null) {
        contents.streamVersion = data.streamVersion;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateStreamCommand = deserializeAws_restJson1CreateStreamCommand;
const deserializeAws_restJson1CreateStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateThingCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        thingArn: undefined,
        thingId: undefined,
        thingName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.thingArn !== undefined && data.thingArn !== null) {
        contents.thingArn = data.thingArn;
    }
    if (data.thingId !== undefined && data.thingId !== null) {
        contents.thingId = data.thingId;
    }
    if (data.thingName !== undefined && data.thingName !== null) {
        contents.thingName = data.thingName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateThingCommand = deserializeAws_restJson1CreateThingCommand;
const deserializeAws_restJson1CreateThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        thingGroupArn: undefined,
        thingGroupId: undefined,
        thingGroupName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.thingGroupArn !== undefined && data.thingGroupArn !== null) {
        contents.thingGroupArn = data.thingGroupArn;
    }
    if (data.thingGroupId !== undefined && data.thingGroupId !== null) {
        contents.thingGroupId = data.thingGroupId;
    }
    if (data.thingGroupName !== undefined && data.thingGroupName !== null) {
        contents.thingGroupName = data.thingGroupName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateThingGroupCommand = deserializeAws_restJson1CreateThingGroupCommand;
const deserializeAws_restJson1CreateThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateThingTypeCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        thingTypeArn: undefined,
        thingTypeId: undefined,
        thingTypeName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.thingTypeArn !== undefined && data.thingTypeArn !== null) {
        contents.thingTypeArn = data.thingTypeArn;
    }
    if (data.thingTypeId !== undefined && data.thingTypeId !== null) {
        contents.thingTypeId = data.thingTypeId;
    }
    if (data.thingTypeName !== undefined && data.thingTypeName !== null) {
        contents.thingTypeName = data.thingTypeName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateThingTypeCommand = deserializeAws_restJson1CreateThingTypeCommand;
const deserializeAws_restJson1CreateThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateTopicRuleCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateTopicRuleCommand = deserializeAws_restJson1CreateTopicRuleCommand;
const deserializeAws_restJson1CreateTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "SqlParseException":
        case "com.amazonaws.iot#SqlParseException":
            response = {
                ...(await deserializeAws_restJson1SqlParseExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateTopicRuleDestinationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        topicRuleDestination: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.topicRuleDestination !== undefined && data.topicRuleDestination !== null) {
        contents.topicRuleDestination = deserializeAws_restJson1TopicRuleDestination(data.topicRuleDestination, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateTopicRuleDestinationCommand = deserializeAws_restJson1CreateTopicRuleDestinationCommand;
const deserializeAws_restJson1CreateTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteAccountAuditConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteAccountAuditConfigurationCommand = deserializeAws_restJson1DeleteAccountAuditConfigurationCommand;
const deserializeAws_restJson1DeleteAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteAuditSuppressionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteAuditSuppressionCommand = deserializeAws_restJson1DeleteAuditSuppressionCommand;
const deserializeAws_restJson1DeleteAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteAuthorizerCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteAuthorizerCommand = deserializeAws_restJson1DeleteAuthorizerCommand;
const deserializeAws_restJson1DeleteAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            response = {
                ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteBillingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteBillingGroupCommand = deserializeAws_restJson1DeleteBillingGroupCommand;
const deserializeAws_restJson1DeleteBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteCACertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteCACertificateCommand = deserializeAws_restJson1DeleteCACertificateCommand;
const deserializeAws_restJson1DeleteCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            response = {
                ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteCertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteCertificateCommand = deserializeAws_restJson1DeleteCertificateCommand;
const deserializeAws_restJson1DeleteCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            response = {
                ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            response = {
                ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteDimensionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteDimensionCommand = deserializeAws_restJson1DeleteDimensionCommand;
const deserializeAws_restJson1DeleteDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteDomainConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteDomainConfigurationCommand = deserializeAws_restJson1DeleteDomainConfigurationCommand;
const deserializeAws_restJson1DeleteDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteDynamicThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteDynamicThingGroupCommand = deserializeAws_restJson1DeleteDynamicThingGroupCommand;
const deserializeAws_restJson1DeleteDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteJobCommand = deserializeAws_restJson1DeleteJobCommand;
const deserializeAws_restJson1DeleteJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            response = {
                ...(await deserializeAws_restJson1InvalidStateTransitionExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteJobExecutionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteJobExecutionCommand = deserializeAws_restJson1DeleteJobExecutionCommand;
const deserializeAws_restJson1DeleteJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            response = {
                ...(await deserializeAws_restJson1InvalidStateTransitionExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteMitigationActionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteMitigationActionCommand = deserializeAws_restJson1DeleteMitigationActionCommand;
const deserializeAws_restJson1DeleteMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteOTAUpdateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteOTAUpdateCommand = deserializeAws_restJson1DeleteOTAUpdateCommand;
const deserializeAws_restJson1DeleteOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeletePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeletePolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeletePolicyCommand = deserializeAws_restJson1DeletePolicyCommand;
const deserializeAws_restJson1DeletePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            response = {
                ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeletePolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeletePolicyVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeletePolicyVersionCommand = deserializeAws_restJson1DeletePolicyVersionCommand;
const deserializeAws_restJson1DeletePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            response = {
                ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteProvisioningTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteProvisioningTemplateCommand = deserializeAws_restJson1DeleteProvisioningTemplateCommand;
const deserializeAws_restJson1DeleteProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            response = {
                ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteProvisioningTemplateVersionCommand = deserializeAws_restJson1DeleteProvisioningTemplateVersionCommand;
const deserializeAws_restJson1DeleteProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            response = {
                ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteRegistrationCodeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteRegistrationCodeCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteRegistrationCodeCommand = deserializeAws_restJson1DeleteRegistrationCodeCommand;
const deserializeAws_restJson1DeleteRegistrationCodeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteRoleAliasCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteRoleAliasCommand = deserializeAws_restJson1DeleteRoleAliasCommand;
const deserializeAws_restJson1DeleteRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            response = {
                ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteScheduledAuditCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteScheduledAuditCommand = deserializeAws_restJson1DeleteScheduledAuditCommand;
const deserializeAws_restJson1DeleteScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteSecurityProfileCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteSecurityProfileCommand = deserializeAws_restJson1DeleteSecurityProfileCommand;
const deserializeAws_restJson1DeleteSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteStreamCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteStreamCommand = deserializeAws_restJson1DeleteStreamCommand;
const deserializeAws_restJson1DeleteStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            response = {
                ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteThingCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteThingCommand = deserializeAws_restJson1DeleteThingCommand;
const deserializeAws_restJson1DeleteThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteThingGroupCommand = deserializeAws_restJson1DeleteThingGroupCommand;
const deserializeAws_restJson1DeleteThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteThingTypeCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteThingTypeCommand = deserializeAws_restJson1DeleteThingTypeCommand;
const deserializeAws_restJson1DeleteThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteTopicRuleCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteTopicRuleCommand = deserializeAws_restJson1DeleteTopicRuleCommand;
const deserializeAws_restJson1DeleteTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteTopicRuleDestinationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteTopicRuleDestinationCommand = deserializeAws_restJson1DeleteTopicRuleDestinationCommand;
const deserializeAws_restJson1DeleteTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteV2LoggingLevelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteV2LoggingLevelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteV2LoggingLevelCommand = deserializeAws_restJson1DeleteV2LoggingLevelCommand;
const deserializeAws_restJson1DeleteV2LoggingLevelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeprecateThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeprecateThingTypeCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeprecateThingTypeCommand = deserializeAws_restJson1DeprecateThingTypeCommand;
const deserializeAws_restJson1DeprecateThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAccountAuditConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        auditCheckConfigurations: undefined,
        auditNotificationTargetConfigurations: undefined,
        roleArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.auditCheckConfigurations !== undefined && data.auditCheckConfigurations !== null) {
        contents.auditCheckConfigurations = deserializeAws_restJson1AuditCheckConfigurations(data.auditCheckConfigurations, context);
    }
    if (data.auditNotificationTargetConfigurations !== undefined && data.auditNotificationTargetConfigurations !== null) {
        contents.auditNotificationTargetConfigurations = deserializeAws_restJson1AuditNotificationTargetConfigurations(data.auditNotificationTargetConfigurations, context);
    }
    if (data.roleArn !== undefined && data.roleArn !== null) {
        contents.roleArn = data.roleArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeAccountAuditConfigurationCommand = deserializeAws_restJson1DescribeAccountAuditConfigurationCommand;
const deserializeAws_restJson1DescribeAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeAuditFindingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuditFindingCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        finding: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.finding !== undefined && data.finding !== null) {
        contents.finding = deserializeAws_restJson1AuditFinding(data.finding, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeAuditFindingCommand = deserializeAws_restJson1DescribeAuditFindingCommand;
const deserializeAws_restJson1DescribeAuditFindingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        actionsDefinition: undefined,
        auditCheckToActionsMapping: undefined,
        endTime: undefined,
        startTime: undefined,
        target: undefined,
        taskStatistics: undefined,
        taskStatus: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.actionsDefinition !== undefined && data.actionsDefinition !== null) {
        contents.actionsDefinition = deserializeAws_restJson1MitigationActionList(data.actionsDefinition, context);
    }
    if (data.auditCheckToActionsMapping !== undefined && data.auditCheckToActionsMapping !== null) {
        contents.auditCheckToActionsMapping = deserializeAws_restJson1AuditCheckToActionsMapping(data.auditCheckToActionsMapping, context);
    }
    if (data.endTime !== undefined && data.endTime !== null) {
        contents.endTime = new Date(Math.round(data.endTime * 1000));
    }
    if (data.startTime !== undefined && data.startTime !== null) {
        contents.startTime = new Date(Math.round(data.startTime * 1000));
    }
    if (data.target !== undefined && data.target !== null) {
        contents.target = deserializeAws_restJson1AuditMitigationActionsTaskTarget(data.target, context);
    }
    if (data.taskStatistics !== undefined && data.taskStatistics !== null) {
        contents.taskStatistics = deserializeAws_restJson1AuditMitigationActionsTaskStatistics(data.taskStatistics, context);
    }
    if (data.taskStatus !== undefined && data.taskStatus !== null) {
        contents.taskStatus = data.taskStatus;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommand;
const deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuditSuppressionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        checkName: undefined,
        description: undefined,
        expirationDate: undefined,
        resourceIdentifier: undefined,
        suppressIndefinitely: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.checkName !== undefined && data.checkName !== null) {
        contents.checkName = data.checkName;
    }
    if (data.description !== undefined && data.description !== null) {
        contents.description = data.description;
    }
    if (data.expirationDate !== undefined && data.expirationDate !== null) {
        contents.expirationDate = new Date(Math.round(data.expirationDate * 1000));
    }
    if (data.resourceIdentifier !== undefined && data.resourceIdentifier !== null) {
        contents.resourceIdentifier = deserializeAws_restJson1ResourceIdentifier(data.resourceIdentifier, context);
    }
    if (data.suppressIndefinitely !== undefined && data.suppressIndefinitely !== null) {
        contents.suppressIndefinitely = data.suppressIndefinitely;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeAuditSuppressionCommand = deserializeAws_restJson1DescribeAuditSuppressionCommand;
const deserializeAws_restJson1DescribeAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuditTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        auditDetails: undefined,
        scheduledAuditName: undefined,
        taskStartTime: undefined,
        taskStatistics: undefined,
        taskStatus: undefined,
        taskType: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.auditDetails !== undefined && data.auditDetails !== null) {
        contents.auditDetails = deserializeAws_restJson1AuditDetails(data.auditDetails, context);
    }
    if (data.scheduledAuditName !== undefined && data.scheduledAuditName !== null) {
        contents.scheduledAuditName = data.scheduledAuditName;
    }
    if (data.taskStartTime !== undefined && data.taskStartTime !== null) {
        contents.taskStartTime = new Date(Math.round(data.taskStartTime * 1000));
    }
    if (data.taskStatistics !== undefined && data.taskStatistics !== null) {
        contents.taskStatistics = deserializeAws_restJson1TaskStatistics(data.taskStatistics, context);
    }
    if (data.taskStatus !== undefined && data.taskStatus !== null) {
        contents.taskStatus = data.taskStatus;
    }
    if (data.taskType !== undefined && data.taskType !== null) {
        contents.taskType = data.taskType;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeAuditTaskCommand = deserializeAws_restJson1DescribeAuditTaskCommand;
const deserializeAws_restJson1DescribeAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuthorizerCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        authorizerDescription: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.authorizerDescription !== undefined && data.authorizerDescription !== null) {
        contents.authorizerDescription = deserializeAws_restJson1AuthorizerDescription(data.authorizerDescription, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeAuthorizerCommand = deserializeAws_restJson1DescribeAuthorizerCommand;
const deserializeAws_restJson1DescribeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeBillingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        billingGroupArn: undefined,
        billingGroupId: undefined,
        billingGroupMetadata: undefined,
        billingGroupName: undefined,
        billingGroupProperties: undefined,
        version: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.billingGroupArn !== undefined && data.billingGroupArn !== null) {
        contents.billingGroupArn = data.billingGroupArn;
    }
    if (data.billingGroupId !== undefined && data.billingGroupId !== null) {
        contents.billingGroupId = data.billingGroupId;
    }
    if (data.billingGroupMetadata !== undefined && data.billingGroupMetadata !== null) {
        contents.billingGroupMetadata = deserializeAws_restJson1BillingGroupMetadata(data.billingGroupMetadata, context);
    }
    if (data.billingGroupName !== undefined && data.billingGroupName !== null) {
        contents.billingGroupName = data.billingGroupName;
    }
    if (data.billingGroupProperties !== undefined && data.billingGroupProperties !== null) {
        contents.billingGroupProperties = deserializeAws_restJson1BillingGroupProperties(data.billingGroupProperties, context);
    }
    if (data.version !== undefined && data.version !== null) {
        contents.version = data.version;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeBillingGroupCommand = deserializeAws_restJson1DescribeBillingGroupCommand;
const deserializeAws_restJson1DescribeBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeCACertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificateDescription: undefined,
        registrationConfig: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificateDescription !== undefined && data.certificateDescription !== null) {
        contents.certificateDescription = deserializeAws_restJson1CACertificateDescription(data.certificateDescription, context);
    }
    if (data.registrationConfig !== undefined && data.registrationConfig !== null) {
        contents.registrationConfig = deserializeAws_restJson1RegistrationConfig(data.registrationConfig, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeCACertificateCommand = deserializeAws_restJson1DescribeCACertificateCommand;
const deserializeAws_restJson1DescribeCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeCertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificateDescription: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificateDescription !== undefined && data.certificateDescription !== null) {
        contents.certificateDescription = deserializeAws_restJson1CertificateDescription(data.certificateDescription, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeCertificateCommand = deserializeAws_restJson1DescribeCertificateCommand;
const deserializeAws_restJson1DescribeCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDefaultAuthorizerCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        authorizerDescription: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.authorizerDescription !== undefined && data.authorizerDescription !== null) {
        contents.authorizerDescription = deserializeAws_restJson1AuthorizerDescription(data.authorizerDescription, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeDefaultAuthorizerCommand = deserializeAws_restJson1DescribeDefaultAuthorizerCommand;
const deserializeAws_restJson1DescribeDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDimensionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        arn: undefined,
        creationDate: undefined,
        lastModifiedDate: undefined,
        name: undefined,
        stringValues: undefined,
        type: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.arn !== undefined && data.arn !== null) {
        contents.arn = data.arn;
    }
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    if (data.name !== undefined && data.name !== null) {
        contents.name = data.name;
    }
    if (data.stringValues !== undefined && data.stringValues !== null) {
        contents.stringValues = deserializeAws_restJson1DimensionStringValues(data.stringValues, context);
    }
    if (data.type !== undefined && data.type !== null) {
        contents.type = data.type;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeDimensionCommand = deserializeAws_restJson1DescribeDimensionCommand;
const deserializeAws_restJson1DescribeDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDomainConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        authorizerConfig: undefined,
        domainConfigurationArn: undefined,
        domainConfigurationName: undefined,
        domainConfigurationStatus: undefined,
        domainName: undefined,
        domainType: undefined,
        lastStatusChangeDate: undefined,
        serverCertificates: undefined,
        serviceType: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.authorizerConfig !== undefined && data.authorizerConfig !== null) {
        contents.authorizerConfig = deserializeAws_restJson1AuthorizerConfig(data.authorizerConfig, context);
    }
    if (data.domainConfigurationArn !== undefined && data.domainConfigurationArn !== null) {
        contents.domainConfigurationArn = data.domainConfigurationArn;
    }
    if (data.domainConfigurationName !== undefined && data.domainConfigurationName !== null) {
        contents.domainConfigurationName = data.domainConfigurationName;
    }
    if (data.domainConfigurationStatus !== undefined && data.domainConfigurationStatus !== null) {
        contents.domainConfigurationStatus = data.domainConfigurationStatus;
    }
    if (data.domainName !== undefined && data.domainName !== null) {
        contents.domainName = data.domainName;
    }
    if (data.domainType !== undefined && data.domainType !== null) {
        contents.domainType = data.domainType;
    }
    if (data.lastStatusChangeDate !== undefined && data.lastStatusChangeDate !== null) {
        contents.lastStatusChangeDate = new Date(Math.round(data.lastStatusChangeDate * 1000));
    }
    if (data.serverCertificates !== undefined && data.serverCertificates !== null) {
        contents.serverCertificates = deserializeAws_restJson1ServerCertificates(data.serverCertificates, context);
    }
    if (data.serviceType !== undefined && data.serviceType !== null) {
        contents.serviceType = data.serviceType;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeDomainConfigurationCommand = deserializeAws_restJson1DescribeDomainConfigurationCommand;
const deserializeAws_restJson1DescribeDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeEndpointCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        endpointAddress: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.endpointAddress !== undefined && data.endpointAddress !== null) {
        contents.endpointAddress = data.endpointAddress;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeEndpointCommand = deserializeAws_restJson1DescribeEndpointCommand;
const deserializeAws_restJson1DescribeEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeEventConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeEventConfigurationsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        creationDate: undefined,
        eventConfigurations: undefined,
        lastModifiedDate: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.eventConfigurations !== undefined && data.eventConfigurations !== null) {
        contents.eventConfigurations = deserializeAws_restJson1EventConfigurations(data.eventConfigurations, context);
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeEventConfigurationsCommand = deserializeAws_restJson1DescribeEventConfigurationsCommand;
const deserializeAws_restJson1DescribeEventConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeIndexCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        indexName: undefined,
        indexStatus: undefined,
        schema: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.indexName !== undefined && data.indexName !== null) {
        contents.indexName = data.indexName;
    }
    if (data.indexStatus !== undefined && data.indexStatus !== null) {
        contents.indexStatus = data.indexStatus;
    }
    if (data.schema !== undefined && data.schema !== null) {
        contents.schema = data.schema;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeIndexCommand = deserializeAws_restJson1DescribeIndexCommand;
const deserializeAws_restJson1DescribeIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        documentSource: undefined,
        job: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.documentSource !== undefined && data.documentSource !== null) {
        contents.documentSource = data.documentSource;
    }
    if (data.job !== undefined && data.job !== null) {
        contents.job = deserializeAws_restJson1Job(data.job, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeJobCommand = deserializeAws_restJson1DescribeJobCommand;
const deserializeAws_restJson1DescribeJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeJobExecutionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        execution: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.execution !== undefined && data.execution !== null) {
        contents.execution = deserializeAws_restJson1JobExecution(data.execution, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeJobExecutionCommand = deserializeAws_restJson1DescribeJobExecutionCommand;
const deserializeAws_restJson1DescribeJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeMitigationActionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        actionArn: undefined,
        actionId: undefined,
        actionName: undefined,
        actionParams: undefined,
        actionType: undefined,
        creationDate: undefined,
        lastModifiedDate: undefined,
        roleArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.actionArn !== undefined && data.actionArn !== null) {
        contents.actionArn = data.actionArn;
    }
    if (data.actionId !== undefined && data.actionId !== null) {
        contents.actionId = data.actionId;
    }
    if (data.actionName !== undefined && data.actionName !== null) {
        contents.actionName = data.actionName;
    }
    if (data.actionParams !== undefined && data.actionParams !== null) {
        contents.actionParams = deserializeAws_restJson1MitigationActionParams(data.actionParams, context);
    }
    if (data.actionType !== undefined && data.actionType !== null) {
        contents.actionType = data.actionType;
    }
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    if (data.roleArn !== undefined && data.roleArn !== null) {
        contents.roleArn = data.roleArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeMitigationActionCommand = deserializeAws_restJson1DescribeMitigationActionCommand;
const deserializeAws_restJson1DescribeMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeProvisioningTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        creationDate: undefined,
        defaultVersionId: undefined,
        description: undefined,
        enabled: undefined,
        lastModifiedDate: undefined,
        preProvisioningHook: undefined,
        provisioningRoleArn: undefined,
        templateArn: undefined,
        templateBody: undefined,
        templateName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.defaultVersionId !== undefined && data.defaultVersionId !== null) {
        contents.defaultVersionId = data.defaultVersionId;
    }
    if (data.description !== undefined && data.description !== null) {
        contents.description = data.description;
    }
    if (data.enabled !== undefined && data.enabled !== null) {
        contents.enabled = data.enabled;
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    if (data.preProvisioningHook !== undefined && data.preProvisioningHook !== null) {
        contents.preProvisioningHook = deserializeAws_restJson1ProvisioningHook(data.preProvisioningHook, context);
    }
    if (data.provisioningRoleArn !== undefined && data.provisioningRoleArn !== null) {
        contents.provisioningRoleArn = data.provisioningRoleArn;
    }
    if (data.templateArn !== undefined && data.templateArn !== null) {
        contents.templateArn = data.templateArn;
    }
    if (data.templateBody !== undefined && data.templateBody !== null) {
        contents.templateBody = data.templateBody;
    }
    if (data.templateName !== undefined && data.templateName !== null) {
        contents.templateName = data.templateName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeProvisioningTemplateCommand = deserializeAws_restJson1DescribeProvisioningTemplateCommand;
const deserializeAws_restJson1DescribeProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        creationDate: undefined,
        isDefaultVersion: undefined,
        templateBody: undefined,
        versionId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
        contents.isDefaultVersion = data.isDefaultVersion;
    }
    if (data.templateBody !== undefined && data.templateBody !== null) {
        contents.templateBody = data.templateBody;
    }
    if (data.versionId !== undefined && data.versionId !== null) {
        contents.versionId = data.versionId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeProvisioningTemplateVersionCommand = deserializeAws_restJson1DescribeProvisioningTemplateVersionCommand;
const deserializeAws_restJson1DescribeProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeRoleAliasCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        roleAliasDescription: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.roleAliasDescription !== undefined && data.roleAliasDescription !== null) {
        contents.roleAliasDescription = deserializeAws_restJson1RoleAliasDescription(data.roleAliasDescription, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeRoleAliasCommand = deserializeAws_restJson1DescribeRoleAliasCommand;
const deserializeAws_restJson1DescribeRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeScheduledAuditCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        dayOfMonth: undefined,
        dayOfWeek: undefined,
        frequency: undefined,
        scheduledAuditArn: undefined,
        scheduledAuditName: undefined,
        targetCheckNames: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.dayOfMonth !== undefined && data.dayOfMonth !== null) {
        contents.dayOfMonth = data.dayOfMonth;
    }
    if (data.dayOfWeek !== undefined && data.dayOfWeek !== null) {
        contents.dayOfWeek = data.dayOfWeek;
    }
    if (data.frequency !== undefined && data.frequency !== null) {
        contents.frequency = data.frequency;
    }
    if (data.scheduledAuditArn !== undefined && data.scheduledAuditArn !== null) {
        contents.scheduledAuditArn = data.scheduledAuditArn;
    }
    if (data.scheduledAuditName !== undefined && data.scheduledAuditName !== null) {
        contents.scheduledAuditName = data.scheduledAuditName;
    }
    if (data.targetCheckNames !== undefined && data.targetCheckNames !== null) {
        contents.targetCheckNames = deserializeAws_restJson1TargetAuditCheckNames(data.targetCheckNames, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeScheduledAuditCommand = deserializeAws_restJson1DescribeScheduledAuditCommand;
const deserializeAws_restJson1DescribeScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeSecurityProfileCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        additionalMetricsToRetain: undefined,
        additionalMetricsToRetainV2: undefined,
        alertTargets: undefined,
        behaviors: undefined,
        creationDate: undefined,
        lastModifiedDate: undefined,
        securityProfileArn: undefined,
        securityProfileDescription: undefined,
        securityProfileName: undefined,
        version: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.additionalMetricsToRetain !== undefined && data.additionalMetricsToRetain !== null) {
        contents.additionalMetricsToRetain = deserializeAws_restJson1AdditionalMetricsToRetainList(data.additionalMetricsToRetain, context);
    }
    if (data.additionalMetricsToRetainV2 !== undefined && data.additionalMetricsToRetainV2 !== null) {
        contents.additionalMetricsToRetainV2 = deserializeAws_restJson1AdditionalMetricsToRetainV2List(data.additionalMetricsToRetainV2, context);
    }
    if (data.alertTargets !== undefined && data.alertTargets !== null) {
        contents.alertTargets = deserializeAws_restJson1AlertTargets(data.alertTargets, context);
    }
    if (data.behaviors !== undefined && data.behaviors !== null) {
        contents.behaviors = deserializeAws_restJson1Behaviors(data.behaviors, context);
    }
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    if (data.securityProfileArn !== undefined && data.securityProfileArn !== null) {
        contents.securityProfileArn = data.securityProfileArn;
    }
    if (data.securityProfileDescription !== undefined && data.securityProfileDescription !== null) {
        contents.securityProfileDescription = data.securityProfileDescription;
    }
    if (data.securityProfileName !== undefined && data.securityProfileName !== null) {
        contents.securityProfileName = data.securityProfileName;
    }
    if (data.version !== undefined && data.version !== null) {
        contents.version = data.version;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeSecurityProfileCommand = deserializeAws_restJson1DescribeSecurityProfileCommand;
const deserializeAws_restJson1DescribeSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeStreamCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        streamInfo: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.streamInfo !== undefined && data.streamInfo !== null) {
        contents.streamInfo = deserializeAws_restJson1StreamInfo(data.streamInfo, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeStreamCommand = deserializeAws_restJson1DescribeStreamCommand;
const deserializeAws_restJson1DescribeStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeThingCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        attributes: undefined,
        billingGroupName: undefined,
        defaultClientId: undefined,
        thingArn: undefined,
        thingId: undefined,
        thingName: undefined,
        thingTypeName: undefined,
        version: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.attributes !== undefined && data.attributes !== null) {
        contents.attributes = deserializeAws_restJson1Attributes(data.attributes, context);
    }
    if (data.billingGroupName !== undefined && data.billingGroupName !== null) {
        contents.billingGroupName = data.billingGroupName;
    }
    if (data.defaultClientId !== undefined && data.defaultClientId !== null) {
        contents.defaultClientId = data.defaultClientId;
    }
    if (data.thingArn !== undefined && data.thingArn !== null) {
        contents.thingArn = data.thingArn;
    }
    if (data.thingId !== undefined && data.thingId !== null) {
        contents.thingId = data.thingId;
    }
    if (data.thingName !== undefined && data.thingName !== null) {
        contents.thingName = data.thingName;
    }
    if (data.thingTypeName !== undefined && data.thingTypeName !== null) {
        contents.thingTypeName = data.thingTypeName;
    }
    if (data.version !== undefined && data.version !== null) {
        contents.version = data.version;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeThingCommand = deserializeAws_restJson1DescribeThingCommand;
const deserializeAws_restJson1DescribeThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        indexName: undefined,
        queryString: undefined,
        queryVersion: undefined,
        status: undefined,
        thingGroupArn: undefined,
        thingGroupId: undefined,
        thingGroupMetadata: undefined,
        thingGroupName: undefined,
        thingGroupProperties: undefined,
        version: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.indexName !== undefined && data.indexName !== null) {
        contents.indexName = data.indexName;
    }
    if (data.queryString !== undefined && data.queryString !== null) {
        contents.queryString = data.queryString;
    }
    if (data.queryVersion !== undefined && data.queryVersion !== null) {
        contents.queryVersion = data.queryVersion;
    }
    if (data.status !== undefined && data.status !== null) {
        contents.status = data.status;
    }
    if (data.thingGroupArn !== undefined && data.thingGroupArn !== null) {
        contents.thingGroupArn = data.thingGroupArn;
    }
    if (data.thingGroupId !== undefined && data.thingGroupId !== null) {
        contents.thingGroupId = data.thingGroupId;
    }
    if (data.thingGroupMetadata !== undefined && data.thingGroupMetadata !== null) {
        contents.thingGroupMetadata = deserializeAws_restJson1ThingGroupMetadata(data.thingGroupMetadata, context);
    }
    if (data.thingGroupName !== undefined && data.thingGroupName !== null) {
        contents.thingGroupName = data.thingGroupName;
    }
    if (data.thingGroupProperties !== undefined && data.thingGroupProperties !== null) {
        contents.thingGroupProperties = deserializeAws_restJson1ThingGroupProperties(data.thingGroupProperties, context);
    }
    if (data.version !== undefined && data.version !== null) {
        contents.version = data.version;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeThingGroupCommand = deserializeAws_restJson1DescribeThingGroupCommand;
const deserializeAws_restJson1DescribeThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeThingRegistrationTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        creationDate: undefined,
        failureCount: undefined,
        inputFileBucket: undefined,
        inputFileKey: undefined,
        lastModifiedDate: undefined,
        message: undefined,
        percentageProgress: undefined,
        roleArn: undefined,
        status: undefined,
        successCount: undefined,
        taskId: undefined,
        templateBody: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.failureCount !== undefined && data.failureCount !== null) {
        contents.failureCount = data.failureCount;
    }
    if (data.inputFileBucket !== undefined && data.inputFileBucket !== null) {
        contents.inputFileBucket = data.inputFileBucket;
    }
    if (data.inputFileKey !== undefined && data.inputFileKey !== null) {
        contents.inputFileKey = data.inputFileKey;
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    if (data.percentageProgress !== undefined && data.percentageProgress !== null) {
        contents.percentageProgress = data.percentageProgress;
    }
    if (data.roleArn !== undefined && data.roleArn !== null) {
        contents.roleArn = data.roleArn;
    }
    if (data.status !== undefined && data.status !== null) {
        contents.status = data.status;
    }
    if (data.successCount !== undefined && data.successCount !== null) {
        contents.successCount = data.successCount;
    }
    if (data.taskId !== undefined && data.taskId !== null) {
        contents.taskId = data.taskId;
    }
    if (data.templateBody !== undefined && data.templateBody !== null) {
        contents.templateBody = data.templateBody;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeThingRegistrationTaskCommand = deserializeAws_restJson1DescribeThingRegistrationTaskCommand;
const deserializeAws_restJson1DescribeThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeThingTypeCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        thingTypeArn: undefined,
        thingTypeId: undefined,
        thingTypeMetadata: undefined,
        thingTypeName: undefined,
        thingTypeProperties: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.thingTypeArn !== undefined && data.thingTypeArn !== null) {
        contents.thingTypeArn = data.thingTypeArn;
    }
    if (data.thingTypeId !== undefined && data.thingTypeId !== null) {
        contents.thingTypeId = data.thingTypeId;
    }
    if (data.thingTypeMetadata !== undefined && data.thingTypeMetadata !== null) {
        contents.thingTypeMetadata = deserializeAws_restJson1ThingTypeMetadata(data.thingTypeMetadata, context);
    }
    if (data.thingTypeName !== undefined && data.thingTypeName !== null) {
        contents.thingTypeName = data.thingTypeName;
    }
    if (data.thingTypeProperties !== undefined && data.thingTypeProperties !== null) {
        contents.thingTypeProperties = deserializeAws_restJson1ThingTypeProperties(data.thingTypeProperties, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeThingTypeCommand = deserializeAws_restJson1DescribeThingTypeCommand;
const deserializeAws_restJson1DescribeThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DetachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DetachPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DetachPolicyCommand = deserializeAws_restJson1DetachPolicyCommand;
const deserializeAws_restJson1DetachPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DetachPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DetachPrincipalPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DetachPrincipalPolicyCommand = deserializeAws_restJson1DetachPrincipalPolicyCommand;
const deserializeAws_restJson1DetachPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DetachSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DetachSecurityProfileCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DetachSecurityProfileCommand = deserializeAws_restJson1DetachSecurityProfileCommand;
const deserializeAws_restJson1DetachSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DetachThingPrincipalCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DetachThingPrincipalCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DetachThingPrincipalCommand = deserializeAws_restJson1DetachThingPrincipalCommand;
const deserializeAws_restJson1DetachThingPrincipalCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DisableTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DisableTopicRuleCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DisableTopicRuleCommand = deserializeAws_restJson1DisableTopicRuleCommand;
const deserializeAws_restJson1DisableTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1EnableTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1EnableTopicRuleCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1EnableTopicRuleCommand = deserializeAws_restJson1EnableTopicRuleCommand;
const deserializeAws_restJson1EnableTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetCardinalityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetCardinalityCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        cardinality: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.cardinality !== undefined && data.cardinality !== null) {
        contents.cardinality = data.cardinality;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetCardinalityCommand = deserializeAws_restJson1GetCardinalityCommand;
const deserializeAws_restJson1GetCardinalityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            response = {
                ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            response = {
                ...(await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            response = {
                ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetEffectivePoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetEffectivePoliciesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        effectivePolicies: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.effectivePolicies !== undefined && data.effectivePolicies !== null) {
        contents.effectivePolicies = deserializeAws_restJson1EffectivePolicies(data.effectivePolicies, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetEffectivePoliciesCommand = deserializeAws_restJson1GetEffectivePoliciesCommand;
const deserializeAws_restJson1GetEffectivePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetIndexingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetIndexingConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        thingGroupIndexingConfiguration: undefined,
        thingIndexingConfiguration: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.thingGroupIndexingConfiguration !== undefined && data.thingGroupIndexingConfiguration !== null) {
        contents.thingGroupIndexingConfiguration = deserializeAws_restJson1ThingGroupIndexingConfiguration(data.thingGroupIndexingConfiguration, context);
    }
    if (data.thingIndexingConfiguration !== undefined && data.thingIndexingConfiguration !== null) {
        contents.thingIndexingConfiguration = deserializeAws_restJson1ThingIndexingConfiguration(data.thingIndexingConfiguration, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetIndexingConfigurationCommand = deserializeAws_restJson1GetIndexingConfigurationCommand;
const deserializeAws_restJson1GetIndexingConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetJobDocumentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetJobDocumentCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        document: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.document !== undefined && data.document !== null) {
        contents.document = data.document;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetJobDocumentCommand = deserializeAws_restJson1GetJobDocumentCommand;
const deserializeAws_restJson1GetJobDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetLoggingOptionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        logLevel: undefined,
        roleArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.logLevel !== undefined && data.logLevel !== null) {
        contents.logLevel = data.logLevel;
    }
    if (data.roleArn !== undefined && data.roleArn !== null) {
        contents.roleArn = data.roleArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetLoggingOptionsCommand = deserializeAws_restJson1GetLoggingOptionsCommand;
const deserializeAws_restJson1GetLoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetOTAUpdateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        otaUpdateInfo: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.otaUpdateInfo !== undefined && data.otaUpdateInfo !== null) {
        contents.otaUpdateInfo = deserializeAws_restJson1OTAUpdateInfo(data.otaUpdateInfo, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetOTAUpdateCommand = deserializeAws_restJson1GetOTAUpdateCommand;
const deserializeAws_restJson1GetOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetPercentilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetPercentilesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        percentiles: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.percentiles !== undefined && data.percentiles !== null) {
        contents.percentiles = deserializeAws_restJson1Percentiles(data.percentiles, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetPercentilesCommand = deserializeAws_restJson1GetPercentilesCommand;
const deserializeAws_restJson1GetPercentilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            response = {
                ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            response = {
                ...(await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            response = {
                ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        creationDate: undefined,
        defaultVersionId: undefined,
        generationId: undefined,
        lastModifiedDate: undefined,
        policyArn: undefined,
        policyDocument: undefined,
        policyName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.defaultVersionId !== undefined && data.defaultVersionId !== null) {
        contents.defaultVersionId = data.defaultVersionId;
    }
    if (data.generationId !== undefined && data.generationId !== null) {
        contents.generationId = data.generationId;
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    if (data.policyArn !== undefined && data.policyArn !== null) {
        contents.policyArn = data.policyArn;
    }
    if (data.policyDocument !== undefined && data.policyDocument !== null) {
        contents.policyDocument = data.policyDocument;
    }
    if (data.policyName !== undefined && data.policyName !== null) {
        contents.policyName = data.policyName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetPolicyCommand = deserializeAws_restJson1GetPolicyCommand;
const deserializeAws_restJson1GetPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetPolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetPolicyVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        creationDate: undefined,
        generationId: undefined,
        isDefaultVersion: undefined,
        lastModifiedDate: undefined,
        policyArn: undefined,
        policyDocument: undefined,
        policyName: undefined,
        policyVersionId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.generationId !== undefined && data.generationId !== null) {
        contents.generationId = data.generationId;
    }
    if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
        contents.isDefaultVersion = data.isDefaultVersion;
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    if (data.policyArn !== undefined && data.policyArn !== null) {
        contents.policyArn = data.policyArn;
    }
    if (data.policyDocument !== undefined && data.policyDocument !== null) {
        contents.policyDocument = data.policyDocument;
    }
    if (data.policyName !== undefined && data.policyName !== null) {
        contents.policyName = data.policyName;
    }
    if (data.policyVersionId !== undefined && data.policyVersionId !== null) {
        contents.policyVersionId = data.policyVersionId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetPolicyVersionCommand = deserializeAws_restJson1GetPolicyVersionCommand;
const deserializeAws_restJson1GetPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetRegistrationCodeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetRegistrationCodeCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        registrationCode: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.registrationCode !== undefined && data.registrationCode !== null) {
        contents.registrationCode = data.registrationCode;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetRegistrationCodeCommand = deserializeAws_restJson1GetRegistrationCodeCommand;
const deserializeAws_restJson1GetRegistrationCodeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetStatisticsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetStatisticsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        statistics: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.statistics !== undefined && data.statistics !== null) {
        contents.statistics = deserializeAws_restJson1Statistics(data.statistics, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetStatisticsCommand = deserializeAws_restJson1GetStatisticsCommand;
const deserializeAws_restJson1GetStatisticsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            response = {
                ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            response = {
                ...(await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            response = {
                ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetTopicRuleCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        rule: undefined,
        ruleArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.rule !== undefined && data.rule !== null) {
        contents.rule = deserializeAws_restJson1TopicRule(data.rule, context);
    }
    if (data.ruleArn !== undefined && data.ruleArn !== null) {
        contents.ruleArn = data.ruleArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetTopicRuleCommand = deserializeAws_restJson1GetTopicRuleCommand;
const deserializeAws_restJson1GetTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetTopicRuleDestinationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        topicRuleDestination: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.topicRuleDestination !== undefined && data.topicRuleDestination !== null) {
        contents.topicRuleDestination = deserializeAws_restJson1TopicRuleDestination(data.topicRuleDestination, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetTopicRuleDestinationCommand = deserializeAws_restJson1GetTopicRuleDestinationCommand;
const deserializeAws_restJson1GetTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetV2LoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetV2LoggingOptionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        defaultLogLevel: undefined,
        disableAllLogs: undefined,
        roleArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.defaultLogLevel !== undefined && data.defaultLogLevel !== null) {
        contents.defaultLogLevel = data.defaultLogLevel;
    }
    if (data.disableAllLogs !== undefined && data.disableAllLogs !== null) {
        contents.disableAllLogs = data.disableAllLogs;
    }
    if (data.roleArn !== undefined && data.roleArn !== null) {
        contents.roleArn = data.roleArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetV2LoggingOptionsCommand = deserializeAws_restJson1GetV2LoggingOptionsCommand;
const deserializeAws_restJson1GetV2LoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            response = {
                ...(await deserializeAws_restJson1NotConfiguredExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListActiveViolationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListActiveViolationsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        activeViolations: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.activeViolations !== undefined && data.activeViolations !== null) {
        contents.activeViolations = deserializeAws_restJson1ActiveViolations(data.activeViolations, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListActiveViolationsCommand = deserializeAws_restJson1ListActiveViolationsCommand;
const deserializeAws_restJson1ListActiveViolationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAttachedPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAttachedPoliciesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextMarker: undefined,
        policies: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    if (data.policies !== undefined && data.policies !== null) {
        contents.policies = deserializeAws_restJson1Policies(data.policies, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAttachedPoliciesCommand = deserializeAws_restJson1ListAttachedPoliciesCommand;
const deserializeAws_restJson1ListAttachedPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAuditFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditFindingsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        findings: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.findings !== undefined && data.findings !== null) {
        contents.findings = deserializeAws_restJson1AuditFindings(data.findings, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAuditFindingsCommand = deserializeAws_restJson1ListAuditFindingsCommand;
const deserializeAws_restJson1ListAuditFindingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        actionsExecutions: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.actionsExecutions !== undefined && data.actionsExecutions !== null) {
        contents.actionsExecutions = deserializeAws_restJson1AuditMitigationActionExecutionMetadataList(data.actionsExecutions, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommand;
const deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAuditMitigationActionsTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditMitigationActionsTasksCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        tasks: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.tasks !== undefined && data.tasks !== null) {
        contents.tasks = deserializeAws_restJson1AuditMitigationActionsTaskMetadataList(data.tasks, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAuditMitigationActionsTasksCommand = deserializeAws_restJson1ListAuditMitigationActionsTasksCommand;
const deserializeAws_restJson1ListAuditMitigationActionsTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAuditSuppressionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditSuppressionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        suppressions: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.suppressions !== undefined && data.suppressions !== null) {
        contents.suppressions = deserializeAws_restJson1AuditSuppressionList(data.suppressions, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAuditSuppressionsCommand = deserializeAws_restJson1ListAuditSuppressionsCommand;
const deserializeAws_restJson1ListAuditSuppressionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAuditTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditTasksCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        tasks: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.tasks !== undefined && data.tasks !== null) {
        contents.tasks = deserializeAws_restJson1AuditTaskMetadataList(data.tasks, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAuditTasksCommand = deserializeAws_restJson1ListAuditTasksCommand;
const deserializeAws_restJson1ListAuditTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAuthorizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuthorizersCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        authorizers: undefined,
        nextMarker: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.authorizers !== undefined && data.authorizers !== null) {
        contents.authorizers = deserializeAws_restJson1Authorizers(data.authorizers, context);
    }
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAuthorizersCommand = deserializeAws_restJson1ListAuthorizersCommand;
const deserializeAws_restJson1ListAuthorizersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListBillingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListBillingGroupsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        billingGroups: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.billingGroups !== undefined && data.billingGroups !== null) {
        contents.billingGroups = deserializeAws_restJson1BillingGroupNameAndArnList(data.billingGroups, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListBillingGroupsCommand = deserializeAws_restJson1ListBillingGroupsCommand;
const deserializeAws_restJson1ListBillingGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListCACertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListCACertificatesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificates: undefined,
        nextMarker: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificates !== undefined && data.certificates !== null) {
        contents.certificates = deserializeAws_restJson1CACertificates(data.certificates, context);
    }
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListCACertificatesCommand = deserializeAws_restJson1ListCACertificatesCommand;
const deserializeAws_restJson1ListCACertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListCertificatesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificates: undefined,
        nextMarker: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificates !== undefined && data.certificates !== null) {
        contents.certificates = deserializeAws_restJson1Certificates(data.certificates, context);
    }
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListCertificatesCommand = deserializeAws_restJson1ListCertificatesCommand;
const deserializeAws_restJson1ListCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListCertificatesByCACommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListCertificatesByCACommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificates: undefined,
        nextMarker: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificates !== undefined && data.certificates !== null) {
        contents.certificates = deserializeAws_restJson1Certificates(data.certificates, context);
    }
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListCertificatesByCACommand = deserializeAws_restJson1ListCertificatesByCACommand;
const deserializeAws_restJson1ListCertificatesByCACommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListDimensionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListDimensionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        dimensionNames: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.dimensionNames !== undefined && data.dimensionNames !== null) {
        contents.dimensionNames = deserializeAws_restJson1DimensionNames(data.dimensionNames, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListDimensionsCommand = deserializeAws_restJson1ListDimensionsCommand;
const deserializeAws_restJson1ListDimensionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListDomainConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListDomainConfigurationsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        domainConfigurations: undefined,
        nextMarker: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.domainConfigurations !== undefined && data.domainConfigurations !== null) {
        contents.domainConfigurations = deserializeAws_restJson1DomainConfigurations(data.domainConfigurations, context);
    }
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListDomainConfigurationsCommand = deserializeAws_restJson1ListDomainConfigurationsCommand;
const deserializeAws_restJson1ListDomainConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListIndicesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListIndicesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        indexNames: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.indexNames !== undefined && data.indexNames !== null) {
        contents.indexNames = deserializeAws_restJson1IndexNamesList(data.indexNames, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListIndicesCommand = deserializeAws_restJson1ListIndicesCommand;
const deserializeAws_restJson1ListIndicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListJobExecutionsForJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListJobExecutionsForJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        executionSummaries: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.executionSummaries !== undefined && data.executionSummaries !== null) {
        contents.executionSummaries = deserializeAws_restJson1JobExecutionSummaryForJobList(data.executionSummaries, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListJobExecutionsForJobCommand = deserializeAws_restJson1ListJobExecutionsForJobCommand;
const deserializeAws_restJson1ListJobExecutionsForJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListJobExecutionsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListJobExecutionsForThingCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        executionSummaries: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.executionSummaries !== undefined && data.executionSummaries !== null) {
        contents.executionSummaries = deserializeAws_restJson1JobExecutionSummaryForThingList(data.executionSummaries, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListJobExecutionsForThingCommand = deserializeAws_restJson1ListJobExecutionsForThingCommand;
const deserializeAws_restJson1ListJobExecutionsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListJobsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        jobs: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.jobs !== undefined && data.jobs !== null) {
        contents.jobs = deserializeAws_restJson1JobSummaryList(data.jobs, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListJobsCommand = deserializeAws_restJson1ListJobsCommand;
const deserializeAws_restJson1ListJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListMitigationActionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListMitigationActionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        actionIdentifiers: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.actionIdentifiers !== undefined && data.actionIdentifiers !== null) {
        contents.actionIdentifiers = deserializeAws_restJson1MitigationActionIdentifierList(data.actionIdentifiers, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListMitigationActionsCommand = deserializeAws_restJson1ListMitigationActionsCommand;
const deserializeAws_restJson1ListMitigationActionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListOTAUpdatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListOTAUpdatesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        otaUpdates: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.otaUpdates !== undefined && data.otaUpdates !== null) {
        contents.otaUpdates = deserializeAws_restJson1OTAUpdatesSummary(data.otaUpdates, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListOTAUpdatesCommand = deserializeAws_restJson1ListOTAUpdatesCommand;
const deserializeAws_restJson1ListOTAUpdatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListOutgoingCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListOutgoingCertificatesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextMarker: undefined,
        outgoingCertificates: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    if (data.outgoingCertificates !== undefined && data.outgoingCertificates !== null) {
        contents.outgoingCertificates = deserializeAws_restJson1OutgoingCertificates(data.outgoingCertificates, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListOutgoingCertificatesCommand = deserializeAws_restJson1ListOutgoingCertificatesCommand;
const deserializeAws_restJson1ListOutgoingCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPoliciesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextMarker: undefined,
        policies: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    if (data.policies !== undefined && data.policies !== null) {
        contents.policies = deserializeAws_restJson1Policies(data.policies, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPoliciesCommand = deserializeAws_restJson1ListPoliciesCommand;
const deserializeAws_restJson1ListPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListPolicyPrincipalsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPolicyPrincipalsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextMarker: undefined,
        principals: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    if (data.principals !== undefined && data.principals !== null) {
        contents.principals = deserializeAws_restJson1Principals(data.principals, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPolicyPrincipalsCommand = deserializeAws_restJson1ListPolicyPrincipalsCommand;
const deserializeAws_restJson1ListPolicyPrincipalsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListPolicyVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPolicyVersionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        policyVersions: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.policyVersions !== undefined && data.policyVersions !== null) {
        contents.policyVersions = deserializeAws_restJson1PolicyVersions(data.policyVersions, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPolicyVersionsCommand = deserializeAws_restJson1ListPolicyVersionsCommand;
const deserializeAws_restJson1ListPolicyVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListPrincipalPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPrincipalPoliciesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextMarker: undefined,
        policies: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    if (data.policies !== undefined && data.policies !== null) {
        contents.policies = deserializeAws_restJson1Policies(data.policies, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPrincipalPoliciesCommand = deserializeAws_restJson1ListPrincipalPoliciesCommand;
const deserializeAws_restJson1ListPrincipalPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListPrincipalThingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPrincipalThingsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        things: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.things !== undefined && data.things !== null) {
        contents.things = deserializeAws_restJson1ThingNameList(data.things, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPrincipalThingsCommand = deserializeAws_restJson1ListPrincipalThingsCommand;
const deserializeAws_restJson1ListPrincipalThingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListProvisioningTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListProvisioningTemplatesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        templates: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.templates !== undefined && data.templates !== null) {
        contents.templates = deserializeAws_restJson1ProvisioningTemplateListing(data.templates, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListProvisioningTemplatesCommand = deserializeAws_restJson1ListProvisioningTemplatesCommand;
const deserializeAws_restJson1ListProvisioningTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListProvisioningTemplateVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListProvisioningTemplateVersionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        versions: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.versions !== undefined && data.versions !== null) {
        contents.versions = deserializeAws_restJson1ProvisioningTemplateVersionListing(data.versions, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListProvisioningTemplateVersionsCommand = deserializeAws_restJson1ListProvisioningTemplateVersionsCommand;
const deserializeAws_restJson1ListProvisioningTemplateVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListRoleAliasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListRoleAliasesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextMarker: undefined,
        roleAliases: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    if (data.roleAliases !== undefined && data.roleAliases !== null) {
        contents.roleAliases = deserializeAws_restJson1RoleAliases(data.roleAliases, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListRoleAliasesCommand = deserializeAws_restJson1ListRoleAliasesCommand;
const deserializeAws_restJson1ListRoleAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListScheduledAuditsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListScheduledAuditsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        scheduledAudits: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.scheduledAudits !== undefined && data.scheduledAudits !== null) {
        contents.scheduledAudits = deserializeAws_restJson1ScheduledAuditMetadataList(data.scheduledAudits, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListScheduledAuditsCommand = deserializeAws_restJson1ListScheduledAuditsCommand;
const deserializeAws_restJson1ListScheduledAuditsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListSecurityProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListSecurityProfilesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        securityProfileIdentifiers: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.securityProfileIdentifiers !== undefined && data.securityProfileIdentifiers !== null) {
        contents.securityProfileIdentifiers = deserializeAws_restJson1SecurityProfileIdentifiers(data.securityProfileIdentifiers, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListSecurityProfilesCommand = deserializeAws_restJson1ListSecurityProfilesCommand;
const deserializeAws_restJson1ListSecurityProfilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListSecurityProfilesForTargetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListSecurityProfilesForTargetCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        securityProfileTargetMappings: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.securityProfileTargetMappings !== undefined && data.securityProfileTargetMappings !== null) {
        contents.securityProfileTargetMappings = deserializeAws_restJson1SecurityProfileTargetMappings(data.securityProfileTargetMappings, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListSecurityProfilesForTargetCommand = deserializeAws_restJson1ListSecurityProfilesForTargetCommand;
const deserializeAws_restJson1ListSecurityProfilesForTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListStreamsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListStreamsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        streams: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.streams !== undefined && data.streams !== null) {
        contents.streams = deserializeAws_restJson1StreamsSummary(data.streams, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListStreamsCommand = deserializeAws_restJson1ListStreamsCommand;
const deserializeAws_restJson1ListStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTagsForResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        tags: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.tags !== undefined && data.tags !== null) {
        contents.tags = deserializeAws_restJson1TagList(data.tags, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListTagsForResourceCommand = deserializeAws_restJson1ListTagsForResourceCommand;
const deserializeAws_restJson1ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListTargetsForPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTargetsForPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextMarker: undefined,
        targets: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextMarker !== undefined && data.nextMarker !== null) {
        contents.nextMarker = data.nextMarker;
    }
    if (data.targets !== undefined && data.targets !== null) {
        contents.targets = deserializeAws_restJson1PolicyTargets(data.targets, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListTargetsForPolicyCommand = deserializeAws_restJson1ListTargetsForPolicyCommand;
const deserializeAws_restJson1ListTargetsForPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListTargetsForSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTargetsForSecurityProfileCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        securityProfileTargets: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.securityProfileTargets !== undefined && data.securityProfileTargets !== null) {
        contents.securityProfileTargets = deserializeAws_restJson1SecurityProfileTargets(data.securityProfileTargets, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListTargetsForSecurityProfileCommand = deserializeAws_restJson1ListTargetsForSecurityProfileCommand;
const deserializeAws_restJson1ListTargetsForSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListThingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingGroupsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        thingGroups: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.thingGroups !== undefined && data.thingGroups !== null) {
        contents.thingGroups = deserializeAws_restJson1ThingGroupNameAndArnList(data.thingGroups, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListThingGroupsCommand = deserializeAws_restJson1ListThingGroupsCommand;
const deserializeAws_restJson1ListThingGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListThingGroupsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingGroupsForThingCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        thingGroups: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.thingGroups !== undefined && data.thingGroups !== null) {
        contents.thingGroups = deserializeAws_restJson1ThingGroupNameAndArnList(data.thingGroups, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListThingGroupsForThingCommand = deserializeAws_restJson1ListThingGroupsForThingCommand;
const deserializeAws_restJson1ListThingGroupsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListThingPrincipalsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingPrincipalsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        principals: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.principals !== undefined && data.principals !== null) {
        contents.principals = deserializeAws_restJson1Principals(data.principals, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListThingPrincipalsCommand = deserializeAws_restJson1ListThingPrincipalsCommand;
const deserializeAws_restJson1ListThingPrincipalsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListThingRegistrationTaskReportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingRegistrationTaskReportsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        reportType: undefined,
        resourceLinks: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.reportType !== undefined && data.reportType !== null) {
        contents.reportType = data.reportType;
    }
    if (data.resourceLinks !== undefined && data.resourceLinks !== null) {
        contents.resourceLinks = deserializeAws_restJson1S3FileUrlList(data.resourceLinks, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListThingRegistrationTaskReportsCommand = deserializeAws_restJson1ListThingRegistrationTaskReportsCommand;
const deserializeAws_restJson1ListThingRegistrationTaskReportsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListThingRegistrationTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingRegistrationTasksCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        taskIds: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.taskIds !== undefined && data.taskIds !== null) {
        contents.taskIds = deserializeAws_restJson1TaskIdList(data.taskIds, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListThingRegistrationTasksCommand = deserializeAws_restJson1ListThingRegistrationTasksCommand;
const deserializeAws_restJson1ListThingRegistrationTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListThingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        things: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.things !== undefined && data.things !== null) {
        contents.things = deserializeAws_restJson1ThingAttributeList(data.things, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListThingsCommand = deserializeAws_restJson1ListThingsCommand;
const deserializeAws_restJson1ListThingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListThingsInBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingsInBillingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        things: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.things !== undefined && data.things !== null) {
        contents.things = deserializeAws_restJson1ThingNameList(data.things, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListThingsInBillingGroupCommand = deserializeAws_restJson1ListThingsInBillingGroupCommand;
const deserializeAws_restJson1ListThingsInBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListThingsInThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingsInThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        things: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.things !== undefined && data.things !== null) {
        contents.things = deserializeAws_restJson1ThingNameList(data.things, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListThingsInThingGroupCommand = deserializeAws_restJson1ListThingsInThingGroupCommand;
const deserializeAws_restJson1ListThingsInThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListThingTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingTypesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        thingTypes: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.thingTypes !== undefined && data.thingTypes !== null) {
        contents.thingTypes = deserializeAws_restJson1ThingTypeList(data.thingTypes, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListThingTypesCommand = deserializeAws_restJson1ListThingTypesCommand;
const deserializeAws_restJson1ListThingTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListTopicRuleDestinationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTopicRuleDestinationsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        destinationSummaries: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.destinationSummaries !== undefined && data.destinationSummaries !== null) {
        contents.destinationSummaries = deserializeAws_restJson1TopicRuleDestinationSummaries(data.destinationSummaries, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListTopicRuleDestinationsCommand = deserializeAws_restJson1ListTopicRuleDestinationsCommand;
const deserializeAws_restJson1ListTopicRuleDestinationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListTopicRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTopicRulesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        rules: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.rules !== undefined && data.rules !== null) {
        contents.rules = deserializeAws_restJson1TopicRuleList(data.rules, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListTopicRulesCommand = deserializeAws_restJson1ListTopicRulesCommand;
const deserializeAws_restJson1ListTopicRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListV2LoggingLevelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListV2LoggingLevelsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        logTargetConfigurations: undefined,
        nextToken: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.logTargetConfigurations !== undefined && data.logTargetConfigurations !== null) {
        contents.logTargetConfigurations = deserializeAws_restJson1LogTargetConfigurations(data.logTargetConfigurations, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListV2LoggingLevelsCommand = deserializeAws_restJson1ListV2LoggingLevelsCommand;
const deserializeAws_restJson1ListV2LoggingLevelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            response = {
                ...(await deserializeAws_restJson1NotConfiguredExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListViolationEventsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListViolationEventsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        violationEvents: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.violationEvents !== undefined && data.violationEvents !== null) {
        contents.violationEvents = deserializeAws_restJson1ViolationEvents(data.violationEvents, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListViolationEventsCommand = deserializeAws_restJson1ListViolationEventsCommand;
const deserializeAws_restJson1ListViolationEventsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RegisterCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RegisterCACertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificateArn: undefined,
        certificateId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificateArn !== undefined && data.certificateArn !== null) {
        contents.certificateArn = data.certificateArn;
    }
    if (data.certificateId !== undefined && data.certificateId !== null) {
        contents.certificateId = data.certificateId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RegisterCACertificateCommand = deserializeAws_restJson1RegisterCACertificateCommand;
const deserializeAws_restJson1RegisterCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            response = {
                ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "RegistrationCodeValidationException":
        case "com.amazonaws.iot#RegistrationCodeValidationException":
            response = {
                ...(await deserializeAws_restJson1RegistrationCodeValidationExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RegisterCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RegisterCertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificateArn: undefined,
        certificateId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificateArn !== undefined && data.certificateArn !== null) {
        contents.certificateArn = data.certificateArn;
    }
    if (data.certificateId !== undefined && data.certificateId !== null) {
        contents.certificateId = data.certificateId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RegisterCertificateCommand = deserializeAws_restJson1RegisterCertificateCommand;
const deserializeAws_restJson1RegisterCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateConflictException":
        case "com.amazonaws.iot#CertificateConflictException":
            response = {
                ...(await deserializeAws_restJson1CertificateConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            response = {
                ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            response = {
                ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RegisterCertificateWithoutCACommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RegisterCertificateWithoutCACommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificateArn: undefined,
        certificateId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificateArn !== undefined && data.certificateArn !== null) {
        contents.certificateArn = data.certificateArn;
    }
    if (data.certificateId !== undefined && data.certificateId !== null) {
        contents.certificateId = data.certificateId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RegisterCertificateWithoutCACommand = deserializeAws_restJson1RegisterCertificateWithoutCACommand;
const deserializeAws_restJson1RegisterCertificateWithoutCACommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            response = {
                ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            response = {
                ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RegisterThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RegisterThingCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        certificatePem: undefined,
        resourceArns: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.certificatePem !== undefined && data.certificatePem !== null) {
        contents.certificatePem = data.certificatePem;
    }
    if (data.resourceArns !== undefined && data.resourceArns !== null) {
        contents.resourceArns = deserializeAws_restJson1ResourceArns(data.resourceArns, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RegisterThingCommand = deserializeAws_restJson1RegisterThingCommand;
const deserializeAws_restJson1RegisterThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceRegistrationFailureException":
        case "com.amazonaws.iot#ResourceRegistrationFailureException":
            response = {
                ...(await deserializeAws_restJson1ResourceRegistrationFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RejectCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RejectCertificateTransferCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RejectCertificateTransferCommand = deserializeAws_restJson1RejectCertificateTransferCommand;
const deserializeAws_restJson1RejectCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            response = {
                ...(await deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RemoveThingFromBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RemoveThingFromBillingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RemoveThingFromBillingGroupCommand = deserializeAws_restJson1RemoveThingFromBillingGroupCommand;
const deserializeAws_restJson1RemoveThingFromBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RemoveThingFromThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RemoveThingFromThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RemoveThingFromThingGroupCommand = deserializeAws_restJson1RemoveThingFromThingGroupCommand;
const deserializeAws_restJson1RemoveThingFromThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ReplaceTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ReplaceTopicRuleCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ReplaceTopicRuleCommand = deserializeAws_restJson1ReplaceTopicRuleCommand;
const deserializeAws_restJson1ReplaceTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "SqlParseException":
        case "com.amazonaws.iot#SqlParseException":
            response = {
                ...(await deserializeAws_restJson1SqlParseExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1SearchIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SearchIndexCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        thingGroups: undefined,
        things: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = data.nextToken;
    }
    if (data.thingGroups !== undefined && data.thingGroups !== null) {
        contents.thingGroups = deserializeAws_restJson1ThingGroupDocumentList(data.thingGroups, context);
    }
    if (data.things !== undefined && data.things !== null) {
        contents.things = deserializeAws_restJson1ThingDocumentList(data.things, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SearchIndexCommand = deserializeAws_restJson1SearchIndexCommand;
const deserializeAws_restJson1SearchIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            response = {
                ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            response = {
                ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1SetDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetDefaultAuthorizerCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        authorizerArn: undefined,
        authorizerName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.authorizerArn !== undefined && data.authorizerArn !== null) {
        contents.authorizerArn = data.authorizerArn;
    }
    if (data.authorizerName !== undefined && data.authorizerName !== null) {
        contents.authorizerName = data.authorizerName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SetDefaultAuthorizerCommand = deserializeAws_restJson1SetDefaultAuthorizerCommand;
const deserializeAws_restJson1SetDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1SetDefaultPolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetDefaultPolicyVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SetDefaultPolicyVersionCommand = deserializeAws_restJson1SetDefaultPolicyVersionCommand;
const deserializeAws_restJson1SetDefaultPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1SetLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetLoggingOptionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SetLoggingOptionsCommand = deserializeAws_restJson1SetLoggingOptionsCommand;
const deserializeAws_restJson1SetLoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1SetV2LoggingLevelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetV2LoggingLevelCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SetV2LoggingLevelCommand = deserializeAws_restJson1SetV2LoggingLevelCommand;
const deserializeAws_restJson1SetV2LoggingLevelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            response = {
                ...(await deserializeAws_restJson1NotConfiguredExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1SetV2LoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetV2LoggingOptionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SetV2LoggingOptionsCommand = deserializeAws_restJson1SetV2LoggingOptionsCommand;
const deserializeAws_restJson1SetV2LoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1StartAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StartAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        taskId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.taskId !== undefined && data.taskId !== null) {
        contents.taskId = data.taskId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1StartAuditMitigationActionsTaskCommand = deserializeAws_restJson1StartAuditMitigationActionsTaskCommand;
const deserializeAws_restJson1StartAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "TaskAlreadyExistsException":
        case "com.amazonaws.iot#TaskAlreadyExistsException":
            response = {
                ...(await deserializeAws_restJson1TaskAlreadyExistsExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1StartOnDemandAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StartOnDemandAuditTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        taskId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.taskId !== undefined && data.taskId !== null) {
        contents.taskId = data.taskId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1StartOnDemandAuditTaskCommand = deserializeAws_restJson1StartOnDemandAuditTaskCommand;
const deserializeAws_restJson1StartOnDemandAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1StartThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StartThingRegistrationTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        taskId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.taskId !== undefined && data.taskId !== null) {
        contents.taskId = data.taskId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1StartThingRegistrationTaskCommand = deserializeAws_restJson1StartThingRegistrationTaskCommand;
const deserializeAws_restJson1StartThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1StopThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StopThingRegistrationTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1StopThingRegistrationTaskCommand = deserializeAws_restJson1StopThingRegistrationTaskCommand;
const deserializeAws_restJson1StopThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1TagResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1TagResourceCommand = deserializeAws_restJson1TagResourceCommand;
const deserializeAws_restJson1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1TestAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1TestAuthorizationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        authResults: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.authResults !== undefined && data.authResults !== null) {
        contents.authResults = deserializeAws_restJson1AuthResults(data.authResults, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1TestAuthorizationCommand = deserializeAws_restJson1TestAuthorizationCommand;
const deserializeAws_restJson1TestAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1TestInvokeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1TestInvokeAuthorizerCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        disconnectAfterInSeconds: undefined,
        isAuthenticated: undefined,
        policyDocuments: undefined,
        principalId: undefined,
        refreshAfterInSeconds: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.disconnectAfterInSeconds !== undefined && data.disconnectAfterInSeconds !== null) {
        contents.disconnectAfterInSeconds = data.disconnectAfterInSeconds;
    }
    if (data.isAuthenticated !== undefined && data.isAuthenticated !== null) {
        contents.isAuthenticated = data.isAuthenticated;
    }
    if (data.policyDocuments !== undefined && data.policyDocuments !== null) {
        contents.policyDocuments = deserializeAws_restJson1PolicyDocuments(data.policyDocuments, context);
    }
    if (data.principalId !== undefined && data.principalId !== null) {
        contents.principalId = data.principalId;
    }
    if (data.refreshAfterInSeconds !== undefined && data.refreshAfterInSeconds !== null) {
        contents.refreshAfterInSeconds = data.refreshAfterInSeconds;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1TestInvokeAuthorizerCommand = deserializeAws_restJson1TestInvokeAuthorizerCommand;
const deserializeAws_restJson1TestInvokeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidResponseException":
        case "com.amazonaws.iot#InvalidResponseException":
            response = {
                ...(await deserializeAws_restJson1InvalidResponseExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1TransferCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1TransferCertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        transferredCertificateArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.transferredCertificateArn !== undefined && data.transferredCertificateArn !== null) {
        contents.transferredCertificateArn = data.transferredCertificateArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1TransferCertificateCommand = deserializeAws_restJson1TransferCertificateCommand;
const deserializeAws_restJson1TransferCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            response = {
                ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "TransferConflictException":
        case "com.amazonaws.iot#TransferConflictException":
            response = {
                ...(await deserializeAws_restJson1TransferConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UntagResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UntagResourceCommand = deserializeAws_restJson1UntagResourceCommand;
const deserializeAws_restJson1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateAccountAuditConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateAccountAuditConfigurationCommand = deserializeAws_restJson1UpdateAccountAuditConfigurationCommand;
const deserializeAws_restJson1UpdateAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateAuditSuppressionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateAuditSuppressionCommand = deserializeAws_restJson1UpdateAuditSuppressionCommand;
const deserializeAws_restJson1UpdateAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateAuthorizerCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        authorizerArn: undefined,
        authorizerName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.authorizerArn !== undefined && data.authorizerArn !== null) {
        contents.authorizerArn = data.authorizerArn;
    }
    if (data.authorizerName !== undefined && data.authorizerName !== null) {
        contents.authorizerName = data.authorizerName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateAuthorizerCommand = deserializeAws_restJson1UpdateAuthorizerCommand;
const deserializeAws_restJson1UpdateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            response = {
                ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateBillingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        version: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.version !== undefined && data.version !== null) {
        contents.version = data.version;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateBillingGroupCommand = deserializeAws_restJson1UpdateBillingGroupCommand;
const deserializeAws_restJson1UpdateBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateCACertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateCACertificateCommand = deserializeAws_restJson1UpdateCACertificateCommand;
const deserializeAws_restJson1UpdateCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateCertificateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateCertificateCommand = deserializeAws_restJson1UpdateCertificateCommand;
const deserializeAws_restJson1UpdateCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            response = {
                ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateDimensionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        arn: undefined,
        creationDate: undefined,
        lastModifiedDate: undefined,
        name: undefined,
        stringValues: undefined,
        type: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.arn !== undefined && data.arn !== null) {
        contents.arn = data.arn;
    }
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    if (data.name !== undefined && data.name !== null) {
        contents.name = data.name;
    }
    if (data.stringValues !== undefined && data.stringValues !== null) {
        contents.stringValues = deserializeAws_restJson1DimensionStringValues(data.stringValues, context);
    }
    if (data.type !== undefined && data.type !== null) {
        contents.type = data.type;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateDimensionCommand = deserializeAws_restJson1UpdateDimensionCommand;
const deserializeAws_restJson1UpdateDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateDomainConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        domainConfigurationArn: undefined,
        domainConfigurationName: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.domainConfigurationArn !== undefined && data.domainConfigurationArn !== null) {
        contents.domainConfigurationArn = data.domainConfigurationArn;
    }
    if (data.domainConfigurationName !== undefined && data.domainConfigurationName !== null) {
        contents.domainConfigurationName = data.domainConfigurationName;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateDomainConfigurationCommand = deserializeAws_restJson1UpdateDomainConfigurationCommand;
const deserializeAws_restJson1UpdateDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            response = {
                ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateDynamicThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        version: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.version !== undefined && data.version !== null) {
        contents.version = data.version;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateDynamicThingGroupCommand = deserializeAws_restJson1UpdateDynamicThingGroupCommand;
const deserializeAws_restJson1UpdateDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            response = {
                ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateEventConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateEventConfigurationsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateEventConfigurationsCommand = deserializeAws_restJson1UpdateEventConfigurationsCommand;
const deserializeAws_restJson1UpdateEventConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateIndexingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateIndexingConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateIndexingConfigurationCommand = deserializeAws_restJson1UpdateIndexingConfigurationCommand;
const deserializeAws_restJson1UpdateIndexingConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateJobCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateJobCommand = deserializeAws_restJson1UpdateJobCommand;
const deserializeAws_restJson1UpdateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateMitigationActionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        actionArn: undefined,
        actionId: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.actionArn !== undefined && data.actionArn !== null) {
        contents.actionArn = data.actionArn;
    }
    if (data.actionId !== undefined && data.actionId !== null) {
        contents.actionId = data.actionId;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateMitigationActionCommand = deserializeAws_restJson1UpdateMitigationActionCommand;
const deserializeAws_restJson1UpdateMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateProvisioningTemplateCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateProvisioningTemplateCommand = deserializeAws_restJson1UpdateProvisioningTemplateCommand;
const deserializeAws_restJson1UpdateProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateRoleAliasCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        roleAlias: undefined,
        roleAliasArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.roleAlias !== undefined && data.roleAlias !== null) {
        contents.roleAlias = data.roleAlias;
    }
    if (data.roleAliasArn !== undefined && data.roleAliasArn !== null) {
        contents.roleAliasArn = data.roleAliasArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateRoleAliasCommand = deserializeAws_restJson1UpdateRoleAliasCommand;
const deserializeAws_restJson1UpdateRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateScheduledAuditCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        scheduledAuditArn: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.scheduledAuditArn !== undefined && data.scheduledAuditArn !== null) {
        contents.scheduledAuditArn = data.scheduledAuditArn;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateScheduledAuditCommand = deserializeAws_restJson1UpdateScheduledAuditCommand;
const deserializeAws_restJson1UpdateScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateSecurityProfileCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        additionalMetricsToRetain: undefined,
        additionalMetricsToRetainV2: undefined,
        alertTargets: undefined,
        behaviors: undefined,
        creationDate: undefined,
        lastModifiedDate: undefined,
        securityProfileArn: undefined,
        securityProfileDescription: undefined,
        securityProfileName: undefined,
        version: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.additionalMetricsToRetain !== undefined && data.additionalMetricsToRetain !== null) {
        contents.additionalMetricsToRetain = deserializeAws_restJson1AdditionalMetricsToRetainList(data.additionalMetricsToRetain, context);
    }
    if (data.additionalMetricsToRetainV2 !== undefined && data.additionalMetricsToRetainV2 !== null) {
        contents.additionalMetricsToRetainV2 = deserializeAws_restJson1AdditionalMetricsToRetainV2List(data.additionalMetricsToRetainV2, context);
    }
    if (data.alertTargets !== undefined && data.alertTargets !== null) {
        contents.alertTargets = deserializeAws_restJson1AlertTargets(data.alertTargets, context);
    }
    if (data.behaviors !== undefined && data.behaviors !== null) {
        contents.behaviors = deserializeAws_restJson1Behaviors(data.behaviors, context);
    }
    if (data.creationDate !== undefined && data.creationDate !== null) {
        contents.creationDate = new Date(Math.round(data.creationDate * 1000));
    }
    if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
        contents.lastModifiedDate = new Date(Math.round(data.lastModifiedDate * 1000));
    }
    if (data.securityProfileArn !== undefined && data.securityProfileArn !== null) {
        contents.securityProfileArn = data.securityProfileArn;
    }
    if (data.securityProfileDescription !== undefined && data.securityProfileDescription !== null) {
        contents.securityProfileDescription = data.securityProfileDescription;
    }
    if (data.securityProfileName !== undefined && data.securityProfileName !== null) {
        contents.securityProfileName = data.securityProfileName;
    }
    if (data.version !== undefined && data.version !== null) {
        contents.version = data.version;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateSecurityProfileCommand = deserializeAws_restJson1UpdateSecurityProfileCommand;
const deserializeAws_restJson1UpdateSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateStreamCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        description: undefined,
        streamArn: undefined,
        streamId: undefined,
        streamVersion: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.description !== undefined && data.description !== null) {
        contents.description = data.description;
    }
    if (data.streamArn !== undefined && data.streamArn !== null) {
        contents.streamArn = data.streamArn;
    }
    if (data.streamId !== undefined && data.streamId !== null) {
        contents.streamId = data.streamId;
    }
    if (data.streamVersion !== undefined && data.streamVersion !== null) {
        contents.streamVersion = data.streamVersion;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateStreamCommand = deserializeAws_restJson1UpdateStreamCommand;
const deserializeAws_restJson1UpdateStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateThingCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateThingCommand = deserializeAws_restJson1UpdateThingCommand;
const deserializeAws_restJson1UpdateThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateThingGroupCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        version: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.version !== undefined && data.version !== null) {
        contents.version = data.version;
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateThingGroupCommand = deserializeAws_restJson1UpdateThingGroupCommand;
const deserializeAws_restJson1UpdateThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            response = {
                ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateThingGroupsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateThingGroupsForThingCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateThingGroupsForThingCommand = deserializeAws_restJson1UpdateThingGroupsForThingCommand;
const deserializeAws_restJson1UpdateThingGroupsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            response = {
                ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateTopicRuleDestinationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateTopicRuleDestinationCommand = deserializeAws_restJson1UpdateTopicRuleDestinationCommand;
const deserializeAws_restJson1UpdateTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            response = {
                ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            response = {
                ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            response = {
                ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            response = {
                ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        valid: undefined,
        validationErrors: undefined,
    };
    const data = await parseBody(output.body, context);
    if (data.valid !== undefined && data.valid !== null) {
        contents.valid = data.valid;
    }
    if (data.validationErrors !== undefined && data.validationErrors !== null) {
        contents.validationErrors = deserializeAws_restJson1ValidationErrors(data.validationErrors, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommand;
const deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            response = {
                ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            response = {
                ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            response = {
                ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
                name: errorCode,
                $metadata: deserializeMetadata(output),
            };
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = {
                ...parsedBody,
                name: `${errorCode}`,
                message: parsedBody.message || parsedBody.Message || errorCode,
                $fault: "client",
                $metadata: deserializeMetadata(output),
            };
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CertificateConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "CertificateConflictException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1CertificateStateExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "CertificateStateException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1CertificateValidationExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "CertificateValidationException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "ConflictingResourceUpdateException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1DeleteConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "DeleteConflictException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1IndexNotReadyExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "IndexNotReadyException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1InternalExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InternalException",
        $fault: "server",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1InternalFailureExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InternalFailureException",
        $fault: "server",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1InvalidAggregationExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidAggregationException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1InvalidQueryExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidQueryException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1InvalidRequestExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidRequestException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1InvalidResponseExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidResponseException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1InvalidStateTransitionExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidStateTransitionException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1LimitExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "LimitExceededException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1MalformedPolicyExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "MalformedPolicyException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1NotConfiguredExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "NotConfiguredException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1RegistrationCodeValidationExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "RegistrationCodeValidationException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "ResourceAlreadyExistsException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
        resourceArn: undefined,
        resourceId: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    if (data.resourceArn !== undefined && data.resourceArn !== null) {
        contents.resourceArn = data.resourceArn;
    }
    if (data.resourceId !== undefined && data.resourceId !== null) {
        contents.resourceId = data.resourceId;
    }
    return contents;
};
const deserializeAws_restJson1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "ResourceNotFoundException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1ResourceRegistrationFailureExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "ResourceRegistrationFailureException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1ServiceUnavailableExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "ServiceUnavailableException",
        $fault: "server",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1SqlParseExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "SqlParseException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1TaskAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "TaskAlreadyExistsException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1ThrottlingExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "ThrottlingException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "TransferAlreadyCompletedException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1TransferConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "TransferConflictException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1UnauthorizedExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "UnauthorizedException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1VersionConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "VersionConflictException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1VersionsLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "VersionsLimitExceededException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined,
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const serializeAws_restJson1AbortConfig = (input, context) => {
    return {
        ...(input.criteriaList !== undefined &&
            input.criteriaList !== null && {
            criteriaList: serializeAws_restJson1AbortCriteriaList(input.criteriaList, context),
        }),
    };
};
const serializeAws_restJson1AbortCriteria = (input, context) => {
    return {
        ...(input.action !== undefined && input.action !== null && { action: input.action }),
        ...(input.failureType !== undefined && input.failureType !== null && { failureType: input.failureType }),
        ...(input.minNumberOfExecutedThings !== undefined &&
            input.minNumberOfExecutedThings !== null && { minNumberOfExecutedThings: input.minNumberOfExecutedThings }),
        ...(input.thresholdPercentage !== undefined &&
            input.thresholdPercentage !== null && { thresholdPercentage: input.thresholdPercentage }),
    };
};
const serializeAws_restJson1AbortCriteriaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1AbortCriteria(entry, context);
    });
};
const serializeAws_restJson1Action = (input, context) => {
    return {
        ...(input.cloudwatchAlarm !== undefined &&
            input.cloudwatchAlarm !== null && {
            cloudwatchAlarm: serializeAws_restJson1CloudwatchAlarmAction(input.cloudwatchAlarm, context),
        }),
        ...(input.cloudwatchLogs !== undefined &&
            input.cloudwatchLogs !== null && {
            cloudwatchLogs: serializeAws_restJson1CloudwatchLogsAction(input.cloudwatchLogs, context),
        }),
        ...(input.cloudwatchMetric !== undefined &&
            input.cloudwatchMetric !== null && {
            cloudwatchMetric: serializeAws_restJson1CloudwatchMetricAction(input.cloudwatchMetric, context),
        }),
        ...(input.dynamoDB !== undefined &&
            input.dynamoDB !== null && { dynamoDB: serializeAws_restJson1DynamoDBAction(input.dynamoDB, context) }),
        ...(input.dynamoDBv2 !== undefined &&
            input.dynamoDBv2 !== null && { dynamoDBv2: serializeAws_restJson1DynamoDBv2Action(input.dynamoDBv2, context) }),
        ...(input.elasticsearch !== undefined &&
            input.elasticsearch !== null && {
            elasticsearch: serializeAws_restJson1ElasticsearchAction(input.elasticsearch, context),
        }),
        ...(input.firehose !== undefined &&
            input.firehose !== null && { firehose: serializeAws_restJson1FirehoseAction(input.firehose, context) }),
        ...(input.http !== undefined &&
            input.http !== null && { http: serializeAws_restJson1HttpAction(input.http, context) }),
        ...(input.iotAnalytics !== undefined &&
            input.iotAnalytics !== null && {
            iotAnalytics: serializeAws_restJson1IotAnalyticsAction(input.iotAnalytics, context),
        }),
        ...(input.iotEvents !== undefined &&
            input.iotEvents !== null && { iotEvents: serializeAws_restJson1IotEventsAction(input.iotEvents, context) }),
        ...(input.iotSiteWise !== undefined &&
            input.iotSiteWise !== null && {
            iotSiteWise: serializeAws_restJson1IotSiteWiseAction(input.iotSiteWise, context),
        }),
        ...(input.kinesis !== undefined &&
            input.kinesis !== null && { kinesis: serializeAws_restJson1KinesisAction(input.kinesis, context) }),
        ...(input.lambda !== undefined &&
            input.lambda !== null && { lambda: serializeAws_restJson1LambdaAction(input.lambda, context) }),
        ...(input.republish !== undefined &&
            input.republish !== null && { republish: serializeAws_restJson1RepublishAction(input.republish, context) }),
        ...(input.s3 !== undefined && input.s3 !== null && { s3: serializeAws_restJson1S3Action(input.s3, context) }),
        ...(input.salesforce !== undefined &&
            input.salesforce !== null && { salesforce: serializeAws_restJson1SalesforceAction(input.salesforce, context) }),
        ...(input.sns !== undefined && input.sns !== null && { sns: serializeAws_restJson1SnsAction(input.sns, context) }),
        ...(input.sqs !== undefined && input.sqs !== null && { sqs: serializeAws_restJson1SqsAction(input.sqs, context) }),
        ...(input.stepFunctions !== undefined &&
            input.stepFunctions !== null && {
            stepFunctions: serializeAws_restJson1StepFunctionsAction(input.stepFunctions, context),
        }),
        ...(input.timestream !== undefined &&
            input.timestream !== null && { timestream: serializeAws_restJson1TimestreamAction(input.timestream, context) }),
    };
};
const serializeAws_restJson1ActionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1Action(entry, context);
    });
};
const serializeAws_restJson1AdditionalMetricsToRetainList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1AdditionalMetricsToRetainV2List = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1MetricToRetain(entry, context);
    });
};
const serializeAws_restJson1AdditionalParameterMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const serializeAws_restJson1AddThingsToThingGroupParams = (input, context) => {
    return {
        ...(input.overrideDynamicGroups !== undefined &&
            input.overrideDynamicGroups !== null && { overrideDynamicGroups: input.overrideDynamicGroups }),
        ...(input.thingGroupNames !== undefined &&
            input.thingGroupNames !== null && {
            thingGroupNames: serializeAws_restJson1ThingGroupNames(input.thingGroupNames, context),
        }),
    };
};
const serializeAws_restJson1AlertTarget = (input, context) => {
    return {
        ...(input.alertTargetArn !== undefined &&
            input.alertTargetArn !== null && { alertTargetArn: input.alertTargetArn }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1AlertTargets = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: serializeAws_restJson1AlertTarget(value, context),
        };
    }, {});
};
const serializeAws_restJson1AssetPropertyTimestamp = (input, context) => {
    return {
        ...(input.offsetInNanos !== undefined && input.offsetInNanos !== null && { offsetInNanos: input.offsetInNanos }),
        ...(input.timeInSeconds !== undefined && input.timeInSeconds !== null && { timeInSeconds: input.timeInSeconds }),
    };
};
const serializeAws_restJson1AssetPropertyValue = (input, context) => {
    return {
        ...(input.quality !== undefined && input.quality !== null && { quality: input.quality }),
        ...(input.timestamp !== undefined &&
            input.timestamp !== null && {
            timestamp: serializeAws_restJson1AssetPropertyTimestamp(input.timestamp, context),
        }),
        ...(input.value !== undefined &&
            input.value !== null && { value: serializeAws_restJson1AssetPropertyVariant(input.value, context) }),
    };
};
const serializeAws_restJson1AssetPropertyValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1AssetPropertyValue(entry, context);
    });
};
const serializeAws_restJson1AssetPropertyVariant = (input, context) => {
    return models_0_1.AssetPropertyVariant.visit(input, {
        booleanValue: (value) => ({ booleanValue: value }),
        doubleValue: (value) => ({ doubleValue: value }),
        integerValue: (value) => ({ integerValue: value }),
        stringValue: (value) => ({ stringValue: value }),
        _: (name, value) => ({ name: value }),
    });
};
const serializeAws_restJson1AttributePayload = (input, context) => {
    return {
        ...(input.attributes !== undefined &&
            input.attributes !== null && { attributes: serializeAws_restJson1Attributes(input.attributes, context) }),
        ...(input.merge !== undefined && input.merge !== null && { merge: input.merge }),
    };
};
const serializeAws_restJson1Attributes = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const serializeAws_restJson1AttributesMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const serializeAws_restJson1AuditCheckConfiguration = (input, context) => {
    return {
        ...(input.enabled !== undefined && input.enabled !== null && { enabled: input.enabled }),
    };
};
const serializeAws_restJson1AuditCheckConfigurations = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: serializeAws_restJson1AuditCheckConfiguration(value, context),
        };
    }, {});
};
const serializeAws_restJson1AuditCheckToActionsMapping = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: serializeAws_restJson1MitigationActionNameList(value, context),
        };
    }, {});
};
const serializeAws_restJson1AuditCheckToReasonCodeFilter = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: serializeAws_restJson1ReasonForNonComplianceCodes(value, context),
        };
    }, {});
};
const serializeAws_restJson1AuditMitigationActionsTaskTarget = (input, context) => {
    return {
        ...(input.auditCheckToReasonCodeFilter !== undefined &&
            input.auditCheckToReasonCodeFilter !== null && {
            auditCheckToReasonCodeFilter: serializeAws_restJson1AuditCheckToReasonCodeFilter(input.auditCheckToReasonCodeFilter, context),
        }),
        ...(input.auditTaskId !== undefined && input.auditTaskId !== null && { auditTaskId: input.auditTaskId }),
        ...(input.findingIds !== undefined &&
            input.findingIds !== null && { findingIds: serializeAws_restJson1FindingIds(input.findingIds, context) }),
    };
};
const serializeAws_restJson1AuditNotificationTarget = (input, context) => {
    return {
        ...(input.enabled !== undefined && input.enabled !== null && { enabled: input.enabled }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.targetArn !== undefined && input.targetArn !== null && { targetArn: input.targetArn }),
    };
};
const serializeAws_restJson1AuditNotificationTargetConfigurations = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: serializeAws_restJson1AuditNotificationTarget(value, context),
        };
    }, {});
};
const serializeAws_restJson1AuthInfo = (input, context) => {
    return {
        ...(input.actionType !== undefined && input.actionType !== null && { actionType: input.actionType }),
        ...(input.resources !== undefined &&
            input.resources !== null && { resources: serializeAws_restJson1Resources(input.resources, context) }),
    };
};
const serializeAws_restJson1AuthInfos = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1AuthInfo(entry, context);
    });
};
const serializeAws_restJson1AuthorizerConfig = (input, context) => {
    return {
        ...(input.allowAuthorizerOverride !== undefined &&
            input.allowAuthorizerOverride !== null && { allowAuthorizerOverride: input.allowAuthorizerOverride }),
        ...(input.defaultAuthorizerName !== undefined &&
            input.defaultAuthorizerName !== null && { defaultAuthorizerName: input.defaultAuthorizerName }),
    };
};
const serializeAws_restJson1AwsJobAbortConfig = (input, context) => {
    return {
        ...(input.abortCriteriaList !== undefined &&
            input.abortCriteriaList !== null && {
            abortCriteriaList: serializeAws_restJson1AwsJobAbortCriteriaList(input.abortCriteriaList, context),
        }),
    };
};
const serializeAws_restJson1AwsJobAbortCriteria = (input, context) => {
    return {
        ...(input.action !== undefined && input.action !== null && { action: input.action }),
        ...(input.failureType !== undefined && input.failureType !== null && { failureType: input.failureType }),
        ...(input.minNumberOfExecutedThings !== undefined &&
            input.minNumberOfExecutedThings !== null && { minNumberOfExecutedThings: input.minNumberOfExecutedThings }),
        ...(input.thresholdPercentage !== undefined &&
            input.thresholdPercentage !== null && { thresholdPercentage: input.thresholdPercentage }),
    };
};
const serializeAws_restJson1AwsJobAbortCriteriaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1AwsJobAbortCriteria(entry, context);
    });
};
const serializeAws_restJson1AwsJobExecutionsRolloutConfig = (input, context) => {
    return {
        ...(input.exponentialRate !== undefined &&
            input.exponentialRate !== null && {
            exponentialRate: serializeAws_restJson1AwsJobExponentialRolloutRate(input.exponentialRate, context),
        }),
        ...(input.maximumPerMinute !== undefined &&
            input.maximumPerMinute !== null && { maximumPerMinute: input.maximumPerMinute }),
    };
};
const serializeAws_restJson1AwsJobExponentialRolloutRate = (input, context) => {
    return {
        ...(input.baseRatePerMinute !== undefined &&
            input.baseRatePerMinute !== null && { baseRatePerMinute: input.baseRatePerMinute }),
        ...(input.incrementFactor !== undefined &&
            input.incrementFactor !== null && { incrementFactor: input.incrementFactor }),
        ...(input.rateIncreaseCriteria !== undefined &&
            input.rateIncreaseCriteria !== null && {
            rateIncreaseCriteria: serializeAws_restJson1AwsJobRateIncreaseCriteria(input.rateIncreaseCriteria, context),
        }),
    };
};
const serializeAws_restJson1AwsJobPresignedUrlConfig = (input, context) => {
    return {
        ...(input.expiresInSec !== undefined && input.expiresInSec !== null && { expiresInSec: input.expiresInSec }),
    };
};
const serializeAws_restJson1AwsJobRateIncreaseCriteria = (input, context) => {
    return {
        ...(input.numberOfNotifiedThings !== undefined &&
            input.numberOfNotifiedThings !== null && { numberOfNotifiedThings: input.numberOfNotifiedThings }),
        ...(input.numberOfSucceededThings !== undefined &&
            input.numberOfSucceededThings !== null && { numberOfSucceededThings: input.numberOfSucceededThings }),
    };
};
const serializeAws_restJson1AwsJobTimeoutConfig = (input, context) => {
    return {
        ...(input.inProgressTimeoutInMinutes !== undefined &&
            input.inProgressTimeoutInMinutes !== null && { inProgressTimeoutInMinutes: input.inProgressTimeoutInMinutes }),
    };
};
const serializeAws_restJson1Behavior = (input, context) => {
    return {
        ...(input.criteria !== undefined &&
            input.criteria !== null && { criteria: serializeAws_restJson1BehaviorCriteria(input.criteria, context) }),
        ...(input.metric !== undefined && input.metric !== null && { metric: input.metric }),
        ...(input.metricDimension !== undefined &&
            input.metricDimension !== null && {
            metricDimension: serializeAws_restJson1MetricDimension(input.metricDimension, context),
        }),
        ...(input.name !== undefined && input.name !== null && { name: input.name }),
    };
};
const serializeAws_restJson1BehaviorCriteria = (input, context) => {
    return {
        ...(input.comparisonOperator !== undefined &&
            input.comparisonOperator !== null && { comparisonOperator: input.comparisonOperator }),
        ...(input.consecutiveDatapointsToAlarm !== undefined &&
            input.consecutiveDatapointsToAlarm !== null && {
            consecutiveDatapointsToAlarm: input.consecutiveDatapointsToAlarm,
        }),
        ...(input.consecutiveDatapointsToClear !== undefined &&
            input.consecutiveDatapointsToClear !== null && {
            consecutiveDatapointsToClear: input.consecutiveDatapointsToClear,
        }),
        ...(input.durationSeconds !== undefined &&
            input.durationSeconds !== null && { durationSeconds: input.durationSeconds }),
        ...(input.statisticalThreshold !== undefined &&
            input.statisticalThreshold !== null && {
            statisticalThreshold: serializeAws_restJson1StatisticalThreshold(input.statisticalThreshold, context),
        }),
        ...(input.value !== undefined &&
            input.value !== null && { value: serializeAws_restJson1MetricValue(input.value, context) }),
    };
};
const serializeAws_restJson1Behaviors = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1Behavior(entry, context);
    });
};
const serializeAws_restJson1BillingGroupProperties = (input, context) => {
    return {
        ...(input.billingGroupDescription !== undefined &&
            input.billingGroupDescription !== null && { billingGroupDescription: input.billingGroupDescription }),
    };
};
const serializeAws_restJson1Cidrs = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1CloudwatchAlarmAction = (input, context) => {
    return {
        ...(input.alarmName !== undefined && input.alarmName !== null && { alarmName: input.alarmName }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.stateReason !== undefined && input.stateReason !== null && { stateReason: input.stateReason }),
        ...(input.stateValue !== undefined && input.stateValue !== null && { stateValue: input.stateValue }),
    };
};
const serializeAws_restJson1CloudwatchLogsAction = (input, context) => {
    return {
        ...(input.logGroupName !== undefined && input.logGroupName !== null && { logGroupName: input.logGroupName }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1CloudwatchMetricAction = (input, context) => {
    return {
        ...(input.metricName !== undefined && input.metricName !== null && { metricName: input.metricName }),
        ...(input.metricNamespace !== undefined &&
            input.metricNamespace !== null && { metricNamespace: input.metricNamespace }),
        ...(input.metricTimestamp !== undefined &&
            input.metricTimestamp !== null && { metricTimestamp: input.metricTimestamp }),
        ...(input.metricUnit !== undefined && input.metricUnit !== null && { metricUnit: input.metricUnit }),
        ...(input.metricValue !== undefined && input.metricValue !== null && { metricValue: input.metricValue }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1CodeSigning = (input, context) => {
    return {
        ...(input.awsSignerJobId !== undefined &&
            input.awsSignerJobId !== null && { awsSignerJobId: input.awsSignerJobId }),
        ...(input.customCodeSigning !== undefined &&
            input.customCodeSigning !== null && {
            customCodeSigning: serializeAws_restJson1CustomCodeSigning(input.customCodeSigning, context),
        }),
        ...(input.startSigningJobParameter !== undefined &&
            input.startSigningJobParameter !== null && {
            startSigningJobParameter: serializeAws_restJson1StartSigningJobParameter(input.startSigningJobParameter, context),
        }),
    };
};
const serializeAws_restJson1CodeSigningCertificateChain = (input, context) => {
    return {
        ...(input.certificateName !== undefined &&
            input.certificateName !== null && { certificateName: input.certificateName }),
        ...(input.inlineDocument !== undefined &&
            input.inlineDocument !== null && { inlineDocument: input.inlineDocument }),
    };
};
const serializeAws_restJson1CodeSigningSignature = (input, context) => {
    return {
        ...(input.inlineDocument !== undefined &&
            input.inlineDocument !== null && { inlineDocument: context.base64Encoder(input.inlineDocument) }),
    };
};
const serializeAws_restJson1Configuration = (input, context) => {
    return {
        ...(input.Enabled !== undefined && input.Enabled !== null && { Enabled: input.Enabled }),
    };
};
const serializeAws_restJson1CustomCodeSigning = (input, context) => {
    return {
        ...(input.certificateChain !== undefined &&
            input.certificateChain !== null && {
            certificateChain: serializeAws_restJson1CodeSigningCertificateChain(input.certificateChain, context),
        }),
        ...(input.hashAlgorithm !== undefined && input.hashAlgorithm !== null && { hashAlgorithm: input.hashAlgorithm }),
        ...(input.signature !== undefined &&
            input.signature !== null && { signature: serializeAws_restJson1CodeSigningSignature(input.signature, context) }),
        ...(input.signatureAlgorithm !== undefined &&
            input.signatureAlgorithm !== null && { signatureAlgorithm: input.signatureAlgorithm }),
    };
};
const serializeAws_restJson1Destination = (input, context) => {
    return {
        ...(input.s3Destination !== undefined &&
            input.s3Destination !== null && {
            s3Destination: serializeAws_restJson1S3Destination(input.s3Destination, context),
        }),
    };
};
const serializeAws_restJson1DetailsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const serializeAws_restJson1DimensionStringValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1DynamoDBAction = (input, context) => {
    return {
        ...(input.hashKeyField !== undefined && input.hashKeyField !== null && { hashKeyField: input.hashKeyField }),
        ...(input.hashKeyType !== undefined && input.hashKeyType !== null && { hashKeyType: input.hashKeyType }),
        ...(input.hashKeyValue !== undefined && input.hashKeyValue !== null && { hashKeyValue: input.hashKeyValue }),
        ...(input.operation !== undefined && input.operation !== null && { operation: input.operation }),
        ...(input.payloadField !== undefined && input.payloadField !== null && { payloadField: input.payloadField }),
        ...(input.rangeKeyField !== undefined && input.rangeKeyField !== null && { rangeKeyField: input.rangeKeyField }),
        ...(input.rangeKeyType !== undefined && input.rangeKeyType !== null && { rangeKeyType: input.rangeKeyType }),
        ...(input.rangeKeyValue !== undefined && input.rangeKeyValue !== null && { rangeKeyValue: input.rangeKeyValue }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.tableName !== undefined && input.tableName !== null && { tableName: input.tableName }),
    };
};
const serializeAws_restJson1DynamoDBv2Action = (input, context) => {
    return {
        ...(input.putItem !== undefined &&
            input.putItem !== null && { putItem: serializeAws_restJson1PutItemInput(input.putItem, context) }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1ElasticsearchAction = (input, context) => {
    return {
        ...(input.endpoint !== undefined && input.endpoint !== null && { endpoint: input.endpoint }),
        ...(input.id !== undefined && input.id !== null && { id: input.id }),
        ...(input.index !== undefined && input.index !== null && { index: input.index }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.type !== undefined && input.type !== null && { type: input.type }),
    };
};
const serializeAws_restJson1EnableIoTLoggingParams = (input, context) => {
    return {
        ...(input.logLevel !== undefined && input.logLevel !== null && { logLevel: input.logLevel }),
        ...(input.roleArnForLogging !== undefined &&
            input.roleArnForLogging !== null && { roleArnForLogging: input.roleArnForLogging }),
    };
};
const serializeAws_restJson1EventConfigurations = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: serializeAws_restJson1Configuration(value, context),
        };
    }, {});
};
const serializeAws_restJson1ExponentialRolloutRate = (input, context) => {
    return {
        ...(input.baseRatePerMinute !== undefined &&
            input.baseRatePerMinute !== null && { baseRatePerMinute: input.baseRatePerMinute }),
        ...(input.incrementFactor !== undefined &&
            input.incrementFactor !== null && { incrementFactor: input.incrementFactor }),
        ...(input.rateIncreaseCriteria !== undefined &&
            input.rateIncreaseCriteria !== null && {
            rateIncreaseCriteria: serializeAws_restJson1RateIncreaseCriteria(input.rateIncreaseCriteria, context),
        }),
    };
};
const serializeAws_restJson1Field = (input, context) => {
    return {
        ...(input.name !== undefined && input.name !== null && { name: input.name }),
        ...(input.type !== undefined && input.type !== null && { type: input.type }),
    };
};
const serializeAws_restJson1Fields = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1Field(entry, context);
    });
};
const serializeAws_restJson1FileLocation = (input, context) => {
    return {
        ...(input.s3Location !== undefined &&
            input.s3Location !== null && { s3Location: serializeAws_restJson1S3Location(input.s3Location, context) }),
        ...(input.stream !== undefined &&
            input.stream !== null && { stream: serializeAws_restJson1_Stream(input.stream, context) }),
    };
};
const serializeAws_restJson1FindingIds = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1FirehoseAction = (input, context) => {
    return {
        ...(input.batchMode !== undefined && input.batchMode !== null && { batchMode: input.batchMode }),
        ...(input.deliveryStreamName !== undefined &&
            input.deliveryStreamName !== null && { deliveryStreamName: input.deliveryStreamName }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.separator !== undefined && input.separator !== null && { separator: input.separator }),
    };
};
const serializeAws_restJson1HeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1HttpActionHeader(entry, context);
    });
};
const serializeAws_restJson1HttpAction = (input, context) => {
    return {
        ...(input.auth !== undefined &&
            input.auth !== null && { auth: serializeAws_restJson1HttpAuthorization(input.auth, context) }),
        ...(input.confirmationUrl !== undefined &&
            input.confirmationUrl !== null && { confirmationUrl: input.confirmationUrl }),
        ...(input.headers !== undefined &&
            input.headers !== null && { headers: serializeAws_restJson1HeaderList(input.headers, context) }),
        ...(input.url !== undefined && input.url !== null && { url: input.url }),
    };
};
const serializeAws_restJson1HttpActionHeader = (input, context) => {
    return {
        ...(input.key !== undefined && input.key !== null && { key: input.key }),
        ...(input.value !== undefined && input.value !== null && { value: input.value }),
    };
};
const serializeAws_restJson1HttpAuthorization = (input, context) => {
    return {
        ...(input.sigv4 !== undefined &&
            input.sigv4 !== null && { sigv4: serializeAws_restJson1SigV4Authorization(input.sigv4, context) }),
    };
};
const serializeAws_restJson1HttpContext = (input, context) => {
    return {
        ...(input.headers !== undefined &&
            input.headers !== null && { headers: serializeAws_restJson1HttpHeaders(input.headers, context) }),
        ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    };
};
const serializeAws_restJson1HttpHeaders = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const serializeAws_restJson1HttpUrlDestinationConfiguration = (input, context) => {
    return {
        ...(input.confirmationUrl !== undefined &&
            input.confirmationUrl !== null && { confirmationUrl: input.confirmationUrl }),
    };
};
const serializeAws_restJson1IotAnalyticsAction = (input, context) => {
    return {
        ...(input.batchMode !== undefined && input.batchMode !== null && { batchMode: input.batchMode }),
        ...(input.channelArn !== undefined && input.channelArn !== null && { channelArn: input.channelArn }),
        ...(input.channelName !== undefined && input.channelName !== null && { channelName: input.channelName }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1IotEventsAction = (input, context) => {
    return {
        ...(input.batchMode !== undefined && input.batchMode !== null && { batchMode: input.batchMode }),
        ...(input.inputName !== undefined && input.inputName !== null && { inputName: input.inputName }),
        ...(input.messageId !== undefined && input.messageId !== null && { messageId: input.messageId }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1IotSiteWiseAction = (input, context) => {
    return {
        ...(input.putAssetPropertyValueEntries !== undefined &&
            input.putAssetPropertyValueEntries !== null && {
            putAssetPropertyValueEntries: serializeAws_restJson1PutAssetPropertyValueEntryList(input.putAssetPropertyValueEntries, context),
        }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1JobExecutionsRolloutConfig = (input, context) => {
    return {
        ...(input.exponentialRate !== undefined &&
            input.exponentialRate !== null && {
            exponentialRate: serializeAws_restJson1ExponentialRolloutRate(input.exponentialRate, context),
        }),
        ...(input.maximumPerMinute !== undefined &&
            input.maximumPerMinute !== null && { maximumPerMinute: input.maximumPerMinute }),
    };
};
const serializeAws_restJson1JobTargets = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1KinesisAction = (input, context) => {
    return {
        ...(input.partitionKey !== undefined && input.partitionKey !== null && { partitionKey: input.partitionKey }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.streamName !== undefined && input.streamName !== null && { streamName: input.streamName }),
    };
};
const serializeAws_restJson1LambdaAction = (input, context) => {
    return {
        ...(input.functionArn !== undefined && input.functionArn !== null && { functionArn: input.functionArn }),
    };
};
const serializeAws_restJson1LoggingOptionsPayload = (input, context) => {
    return {
        ...(input.logLevel !== undefined && input.logLevel !== null && { logLevel: input.logLevel }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1LogTarget = (input, context) => {
    return {
        ...(input.targetName !== undefined && input.targetName !== null && { targetName: input.targetName }),
        ...(input.targetType !== undefined && input.targetType !== null && { targetType: input.targetType }),
    };
};
const serializeAws_restJson1MetricDimension = (input, context) => {
    return {
        ...(input.dimensionName !== undefined && input.dimensionName !== null && { dimensionName: input.dimensionName }),
        ...(input.operator !== undefined && input.operator !== null && { operator: input.operator }),
    };
};
const serializeAws_restJson1MetricToRetain = (input, context) => {
    return {
        ...(input.metric !== undefined && input.metric !== null && { metric: input.metric }),
        ...(input.metricDimension !== undefined &&
            input.metricDimension !== null && {
            metricDimension: serializeAws_restJson1MetricDimension(input.metricDimension, context),
        }),
    };
};
const serializeAws_restJson1MetricValue = (input, context) => {
    return {
        ...(input.cidrs !== undefined &&
            input.cidrs !== null && { cidrs: serializeAws_restJson1Cidrs(input.cidrs, context) }),
        ...(input.count !== undefined && input.count !== null && { count: input.count }),
        ...(input.ports !== undefined &&
            input.ports !== null && { ports: serializeAws_restJson1Ports(input.ports, context) }),
    };
};
const serializeAws_restJson1MitigationActionNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1MitigationActionParams = (input, context) => {
    return {
        ...(input.addThingsToThingGroupParams !== undefined &&
            input.addThingsToThingGroupParams !== null && {
            addThingsToThingGroupParams: serializeAws_restJson1AddThingsToThingGroupParams(input.addThingsToThingGroupParams, context),
        }),
        ...(input.enableIoTLoggingParams !== undefined &&
            input.enableIoTLoggingParams !== null && {
            enableIoTLoggingParams: serializeAws_restJson1EnableIoTLoggingParams(input.enableIoTLoggingParams, context),
        }),
        ...(input.publishFindingToSnsParams !== undefined &&
            input.publishFindingToSnsParams !== null && {
            publishFindingToSnsParams: serializeAws_restJson1PublishFindingToSnsParams(input.publishFindingToSnsParams, context),
        }),
        ...(input.replaceDefaultPolicyVersionParams !== undefined &&
            input.replaceDefaultPolicyVersionParams !== null && {
            replaceDefaultPolicyVersionParams: serializeAws_restJson1ReplaceDefaultPolicyVersionParams(input.replaceDefaultPolicyVersionParams, context),
        }),
        ...(input.updateCACertificateParams !== undefined &&
            input.updateCACertificateParams !== null && {
            updateCACertificateParams: serializeAws_restJson1UpdateCACertificateParams(input.updateCACertificateParams, context),
        }),
        ...(input.updateDeviceCertificateParams !== undefined &&
            input.updateDeviceCertificateParams !== null && {
            updateDeviceCertificateParams: serializeAws_restJson1UpdateDeviceCertificateParams(input.updateDeviceCertificateParams, context),
        }),
    };
};
const serializeAws_restJson1MqttContext = (input, context) => {
    return {
        ...(input.clientId !== undefined && input.clientId !== null && { clientId: input.clientId }),
        ...(input.password !== undefined && input.password !== null && { password: context.base64Encoder(input.password) }),
        ...(input.username !== undefined && input.username !== null && { username: input.username }),
    };
};
const serializeAws_restJson1OTAUpdateFile = (input, context) => {
    return {
        ...(input.attributes !== undefined &&
            input.attributes !== null && { attributes: serializeAws_restJson1AttributesMap(input.attributes, context) }),
        ...(input.codeSigning !== undefined &&
            input.codeSigning !== null && { codeSigning: serializeAws_restJson1CodeSigning(input.codeSigning, context) }),
        ...(input.fileLocation !== undefined &&
            input.fileLocation !== null && { fileLocation: serializeAws_restJson1FileLocation(input.fileLocation, context) }),
        ...(input.fileName !== undefined && input.fileName !== null && { fileName: input.fileName }),
        ...(input.fileType !== undefined && input.fileType !== null && { fileType: input.fileType }),
        ...(input.fileVersion !== undefined && input.fileVersion !== null && { fileVersion: input.fileVersion }),
    };
};
const serializeAws_restJson1OTAUpdateFiles = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1OTAUpdateFile(entry, context);
    });
};
const serializeAws_restJson1Parameters = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const serializeAws_restJson1PercentList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1PolicyNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1PolicyVersionIdentifier = (input, context) => {
    return {
        ...(input.policyName !== undefined && input.policyName !== null && { policyName: input.policyName }),
        ...(input.policyVersionId !== undefined &&
            input.policyVersionId !== null && { policyVersionId: input.policyVersionId }),
    };
};
const serializeAws_restJson1Ports = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1PresignedUrlConfig = (input, context) => {
    return {
        ...(input.expiresInSec !== undefined && input.expiresInSec !== null && { expiresInSec: input.expiresInSec }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1Protocols = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1ProvisioningHook = (input, context) => {
    return {
        ...(input.payloadVersion !== undefined &&
            input.payloadVersion !== null && { payloadVersion: input.payloadVersion }),
        ...(input.targetArn !== undefined && input.targetArn !== null && { targetArn: input.targetArn }),
    };
};
const serializeAws_restJson1PublicKeyMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const serializeAws_restJson1PublishFindingToSnsParams = (input, context) => {
    return {
        ...(input.topicArn !== undefined && input.topicArn !== null && { topicArn: input.topicArn }),
    };
};
const serializeAws_restJson1PutAssetPropertyValueEntry = (input, context) => {
    return {
        ...(input.assetId !== undefined && input.assetId !== null && { assetId: input.assetId }),
        ...(input.entryId !== undefined && input.entryId !== null && { entryId: input.entryId }),
        ...(input.propertyAlias !== undefined && input.propertyAlias !== null && { propertyAlias: input.propertyAlias }),
        ...(input.propertyId !== undefined && input.propertyId !== null && { propertyId: input.propertyId }),
        ...(input.propertyValues !== undefined &&
            input.propertyValues !== null && {
            propertyValues: serializeAws_restJson1AssetPropertyValueList(input.propertyValues, context),
        }),
    };
};
const serializeAws_restJson1PutAssetPropertyValueEntryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1PutAssetPropertyValueEntry(entry, context);
    });
};
const serializeAws_restJson1PutItemInput = (input, context) => {
    return {
        ...(input.tableName !== undefined && input.tableName !== null && { tableName: input.tableName }),
    };
};
const serializeAws_restJson1RateIncreaseCriteria = (input, context) => {
    return {
        ...(input.numberOfNotifiedThings !== undefined &&
            input.numberOfNotifiedThings !== null && { numberOfNotifiedThings: input.numberOfNotifiedThings }),
        ...(input.numberOfSucceededThings !== undefined &&
            input.numberOfSucceededThings !== null && { numberOfSucceededThings: input.numberOfSucceededThings }),
    };
};
const serializeAws_restJson1ReasonForNonComplianceCodes = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1RegistrationConfig = (input, context) => {
    return {
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
    };
};
const serializeAws_restJson1ReplaceDefaultPolicyVersionParams = (input, context) => {
    return {
        ...(input.templateName !== undefined && input.templateName !== null && { templateName: input.templateName }),
    };
};
const serializeAws_restJson1RepublishAction = (input, context) => {
    return {
        ...(input.qos !== undefined && input.qos !== null && { qos: input.qos }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.topic !== undefined && input.topic !== null && { topic: input.topic }),
    };
};
const serializeAws_restJson1ResourceIdentifier = (input, context) => {
    return {
        ...(input.account !== undefined && input.account !== null && { account: input.account }),
        ...(input.caCertificateId !== undefined &&
            input.caCertificateId !== null && { caCertificateId: input.caCertificateId }),
        ...(input.clientId !== undefined && input.clientId !== null && { clientId: input.clientId }),
        ...(input.cognitoIdentityPoolId !== undefined &&
            input.cognitoIdentityPoolId !== null && { cognitoIdentityPoolId: input.cognitoIdentityPoolId }),
        ...(input.deviceCertificateId !== undefined &&
            input.deviceCertificateId !== null && { deviceCertificateId: input.deviceCertificateId }),
        ...(input.iamRoleArn !== undefined && input.iamRoleArn !== null && { iamRoleArn: input.iamRoleArn }),
        ...(input.policyVersionIdentifier !== undefined &&
            input.policyVersionIdentifier !== null && {
            policyVersionIdentifier: serializeAws_restJson1PolicyVersionIdentifier(input.policyVersionIdentifier, context),
        }),
        ...(input.roleAliasArn !== undefined && input.roleAliasArn !== null && { roleAliasArn: input.roleAliasArn }),
    };
};
const serializeAws_restJson1Resources = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1S3Action = (input, context) => {
    return {
        ...(input.bucketName !== undefined && input.bucketName !== null && { bucketName: input.bucketName }),
        ...(input.cannedAcl !== undefined && input.cannedAcl !== null && { cannedAcl: input.cannedAcl }),
        ...(input.key !== undefined && input.key !== null && { key: input.key }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1S3Destination = (input, context) => {
    return {
        ...(input.bucket !== undefined && input.bucket !== null && { bucket: input.bucket }),
        ...(input.prefix !== undefined && input.prefix !== null && { prefix: input.prefix }),
    };
};
const serializeAws_restJson1S3Location = (input, context) => {
    return {
        ...(input.bucket !== undefined && input.bucket !== null && { bucket: input.bucket }),
        ...(input.key !== undefined && input.key !== null && { key: input.key }),
        ...(input.version !== undefined && input.version !== null && { version: input.version }),
    };
};
const serializeAws_restJson1SalesforceAction = (input, context) => {
    return {
        ...(input.token !== undefined && input.token !== null && { token: input.token }),
        ...(input.url !== undefined && input.url !== null && { url: input.url }),
    };
};
const serializeAws_restJson1SearchableAttributes = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1ServerCertificateArns = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1SigningProfileParameter = (input, context) => {
    return {
        ...(input.certificateArn !== undefined &&
            input.certificateArn !== null && { certificateArn: input.certificateArn }),
        ...(input.certificatePathOnDevice !== undefined &&
            input.certificatePathOnDevice !== null && { certificatePathOnDevice: input.certificatePathOnDevice }),
        ...(input.platform !== undefined && input.platform !== null && { platform: input.platform }),
    };
};
const serializeAws_restJson1SigV4Authorization = (input, context) => {
    return {
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.serviceName !== undefined && input.serviceName !== null && { serviceName: input.serviceName }),
        ...(input.signingRegion !== undefined && input.signingRegion !== null && { signingRegion: input.signingRegion }),
    };
};
const serializeAws_restJson1SnsAction = (input, context) => {
    return {
        ...(input.messageFormat !== undefined && input.messageFormat !== null && { messageFormat: input.messageFormat }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.targetArn !== undefined && input.targetArn !== null && { targetArn: input.targetArn }),
    };
};
const serializeAws_restJson1SqsAction = (input, context) => {
    return {
        ...(input.queueUrl !== undefined && input.queueUrl !== null && { queueUrl: input.queueUrl }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.useBase64 !== undefined && input.useBase64 !== null && { useBase64: input.useBase64 }),
    };
};
const serializeAws_restJson1StartSigningJobParameter = (input, context) => {
    return {
        ...(input.destination !== undefined &&
            input.destination !== null && { destination: serializeAws_restJson1Destination(input.destination, context) }),
        ...(input.signingProfileName !== undefined &&
            input.signingProfileName !== null && { signingProfileName: input.signingProfileName }),
        ...(input.signingProfileParameter !== undefined &&
            input.signingProfileParameter !== null && {
            signingProfileParameter: serializeAws_restJson1SigningProfileParameter(input.signingProfileParameter, context),
        }),
    };
};
const serializeAws_restJson1StatisticalThreshold = (input, context) => {
    return {
        ...(input.statistic !== undefined && input.statistic !== null && { statistic: input.statistic }),
    };
};
const serializeAws_restJson1StepFunctionsAction = (input, context) => {
    return {
        ...(input.executionNamePrefix !== undefined &&
            input.executionNamePrefix !== null && { executionNamePrefix: input.executionNamePrefix }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.stateMachineName !== undefined &&
            input.stateMachineName !== null && { stateMachineName: input.stateMachineName }),
    };
};
const serializeAws_restJson1_Stream = (input, context) => {
    return {
        ...(input.fileId !== undefined && input.fileId !== null && { fileId: input.fileId }),
        ...(input.streamId !== undefined && input.streamId !== null && { streamId: input.streamId }),
    };
};
const serializeAws_restJson1StreamFile = (input, context) => {
    return {
        ...(input.fileId !== undefined && input.fileId !== null && { fileId: input.fileId }),
        ...(input.s3Location !== undefined &&
            input.s3Location !== null && { s3Location: serializeAws_restJson1S3Location(input.s3Location, context) }),
    };
};
const serializeAws_restJson1StreamFiles = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1StreamFile(entry, context);
    });
};
const serializeAws_restJson1Tag = (input, context) => {
    return {
        ...(input.Key !== undefined && input.Key !== null && { Key: input.Key }),
        ...(input.Value !== undefined && input.Value !== null && { Value: input.Value }),
    };
};
const serializeAws_restJson1TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1Tag(entry, context);
    });
};
const serializeAws_restJson1TargetAuditCheckNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1Targets = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1ThingGroupIndexingConfiguration = (input, context) => {
    return {
        ...(input.customFields !== undefined &&
            input.customFields !== null && { customFields: serializeAws_restJson1Fields(input.customFields, context) }),
        ...(input.managedFields !== undefined &&
            input.managedFields !== null && { managedFields: serializeAws_restJson1Fields(input.managedFields, context) }),
        ...(input.thingGroupIndexingMode !== undefined &&
            input.thingGroupIndexingMode !== null && { thingGroupIndexingMode: input.thingGroupIndexingMode }),
    };
};
const serializeAws_restJson1ThingGroupList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1ThingGroupNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1ThingGroupProperties = (input, context) => {
    return {
        ...(input.attributePayload !== undefined &&
            input.attributePayload !== null && {
            attributePayload: serializeAws_restJson1AttributePayload(input.attributePayload, context),
        }),
        ...(input.thingGroupDescription !== undefined &&
            input.thingGroupDescription !== null && { thingGroupDescription: input.thingGroupDescription }),
    };
};
const serializeAws_restJson1ThingIndexingConfiguration = (input, context) => {
    return {
        ...(input.customFields !== undefined &&
            input.customFields !== null && { customFields: serializeAws_restJson1Fields(input.customFields, context) }),
        ...(input.managedFields !== undefined &&
            input.managedFields !== null && { managedFields: serializeAws_restJson1Fields(input.managedFields, context) }),
        ...(input.thingConnectivityIndexingMode !== undefined &&
            input.thingConnectivityIndexingMode !== null && {
            thingConnectivityIndexingMode: input.thingConnectivityIndexingMode,
        }),
        ...(input.thingIndexingMode !== undefined &&
            input.thingIndexingMode !== null && { thingIndexingMode: input.thingIndexingMode }),
    };
};
const serializeAws_restJson1ThingTypeProperties = (input, context) => {
    return {
        ...(input.searchableAttributes !== undefined &&
            input.searchableAttributes !== null && {
            searchableAttributes: serializeAws_restJson1SearchableAttributes(input.searchableAttributes, context),
        }),
        ...(input.thingTypeDescription !== undefined &&
            input.thingTypeDescription !== null && { thingTypeDescription: input.thingTypeDescription }),
    };
};
const serializeAws_restJson1TimeoutConfig = (input, context) => {
    return {
        ...(input.inProgressTimeoutInMinutes !== undefined &&
            input.inProgressTimeoutInMinutes !== null && { inProgressTimeoutInMinutes: input.inProgressTimeoutInMinutes }),
    };
};
const serializeAws_restJson1TimestreamAction = (input, context) => {
    return {
        ...(input.databaseName !== undefined && input.databaseName !== null && { databaseName: input.databaseName }),
        ...(input.dimensions !== undefined &&
            input.dimensions !== null && {
            dimensions: serializeAws_restJson1TimestreamDimensionList(input.dimensions, context),
        }),
        ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
        ...(input.tableName !== undefined && input.tableName !== null && { tableName: input.tableName }),
        ...(input.timestamp !== undefined &&
            input.timestamp !== null && { timestamp: serializeAws_restJson1TimestreamTimestamp(input.timestamp, context) }),
    };
};
const serializeAws_restJson1TimestreamDimension = (input, context) => {
    return {
        ...(input.name !== undefined && input.name !== null && { name: input.name }),
        ...(input.value !== undefined && input.value !== null && { value: input.value }),
    };
};
const serializeAws_restJson1TimestreamDimensionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1TimestreamDimension(entry, context);
    });
};
const serializeAws_restJson1TimestreamTimestamp = (input, context) => {
    return {
        ...(input.unit !== undefined && input.unit !== null && { unit: input.unit }),
        ...(input.value !== undefined && input.value !== null && { value: input.value }),
    };
};
const serializeAws_restJson1TlsContext = (input, context) => {
    return {
        ...(input.serverName !== undefined && input.serverName !== null && { serverName: input.serverName }),
    };
};
const serializeAws_restJson1TopicRuleDestinationConfiguration = (input, context) => {
    return {
        ...(input.httpUrlConfiguration !== undefined &&
            input.httpUrlConfiguration !== null && {
            httpUrlConfiguration: serializeAws_restJson1HttpUrlDestinationConfiguration(input.httpUrlConfiguration, context),
        }),
    };
};
const serializeAws_restJson1TopicRulePayload = (input, context) => {
    return {
        ...(input.actions !== undefined &&
            input.actions !== null && { actions: serializeAws_restJson1ActionList(input.actions, context) }),
        ...(input.awsIotSqlVersion !== undefined &&
            input.awsIotSqlVersion !== null && { awsIotSqlVersion: input.awsIotSqlVersion }),
        ...(input.description !== undefined && input.description !== null && { description: input.description }),
        ...(input.errorAction !== undefined &&
            input.errorAction !== null && { errorAction: serializeAws_restJson1Action(input.errorAction, context) }),
        ...(input.ruleDisabled !== undefined && input.ruleDisabled !== null && { ruleDisabled: input.ruleDisabled }),
        ...(input.sql !== undefined && input.sql !== null && { sql: input.sql }),
    };
};
const serializeAws_restJson1UpdateCACertificateParams = (input, context) => {
    return {
        ...(input.action !== undefined && input.action !== null && { action: input.action }),
    };
};
const serializeAws_restJson1UpdateDeviceCertificateParams = (input, context) => {
    return {
        ...(input.action !== undefined && input.action !== null && { action: input.action }),
    };
};
const deserializeAws_restJson1AbortConfig = (output, context) => {
    return {
        criteriaList: output.criteriaList !== undefined && output.criteriaList !== null
            ? deserializeAws_restJson1AbortCriteriaList(output.criteriaList, context)
            : undefined,
    };
};
const deserializeAws_restJson1AbortCriteria = (output, context) => {
    return {
        action: output.action !== undefined && output.action !== null ? output.action : undefined,
        failureType: output.failureType !== undefined && output.failureType !== null ? output.failureType : undefined,
        minNumberOfExecutedThings: output.minNumberOfExecutedThings !== undefined && output.minNumberOfExecutedThings !== null
            ? output.minNumberOfExecutedThings
            : undefined,
        thresholdPercentage: output.thresholdPercentage !== undefined && output.thresholdPercentage !== null
            ? output.thresholdPercentage
            : undefined,
    };
};
const deserializeAws_restJson1AbortCriteriaList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AbortCriteria(entry, context);
    });
};
const deserializeAws_restJson1Action = (output, context) => {
    return {
        cloudwatchAlarm: output.cloudwatchAlarm !== undefined && output.cloudwatchAlarm !== null
            ? deserializeAws_restJson1CloudwatchAlarmAction(output.cloudwatchAlarm, context)
            : undefined,
        cloudwatchLogs: output.cloudwatchLogs !== undefined && output.cloudwatchLogs !== null
            ? deserializeAws_restJson1CloudwatchLogsAction(output.cloudwatchLogs, context)
            : undefined,
        cloudwatchMetric: output.cloudwatchMetric !== undefined && output.cloudwatchMetric !== null
            ? deserializeAws_restJson1CloudwatchMetricAction(output.cloudwatchMetric, context)
            : undefined,
        dynamoDB: output.dynamoDB !== undefined && output.dynamoDB !== null
            ? deserializeAws_restJson1DynamoDBAction(output.dynamoDB, context)
            : undefined,
        dynamoDBv2: output.dynamoDBv2 !== undefined && output.dynamoDBv2 !== null
            ? deserializeAws_restJson1DynamoDBv2Action(output.dynamoDBv2, context)
            : undefined,
        elasticsearch: output.elasticsearch !== undefined && output.elasticsearch !== null
            ? deserializeAws_restJson1ElasticsearchAction(output.elasticsearch, context)
            : undefined,
        firehose: output.firehose !== undefined && output.firehose !== null
            ? deserializeAws_restJson1FirehoseAction(output.firehose, context)
            : undefined,
        http: output.http !== undefined && output.http !== null
            ? deserializeAws_restJson1HttpAction(output.http, context)
            : undefined,
        iotAnalytics: output.iotAnalytics !== undefined && output.iotAnalytics !== null
            ? deserializeAws_restJson1IotAnalyticsAction(output.iotAnalytics, context)
            : undefined,
        iotEvents: output.iotEvents !== undefined && output.iotEvents !== null
            ? deserializeAws_restJson1IotEventsAction(output.iotEvents, context)
            : undefined,
        iotSiteWise: output.iotSiteWise !== undefined && output.iotSiteWise !== null
            ? deserializeAws_restJson1IotSiteWiseAction(output.iotSiteWise, context)
            : undefined,
        kinesis: output.kinesis !== undefined && output.kinesis !== null
            ? deserializeAws_restJson1KinesisAction(output.kinesis, context)
            : undefined,
        lambda: output.lambda !== undefined && output.lambda !== null
            ? deserializeAws_restJson1LambdaAction(output.lambda, context)
            : undefined,
        republish: output.republish !== undefined && output.republish !== null
            ? deserializeAws_restJson1RepublishAction(output.republish, context)
            : undefined,
        s3: output.s3 !== undefined && output.s3 !== null ? deserializeAws_restJson1S3Action(output.s3, context) : undefined,
        salesforce: output.salesforce !== undefined && output.salesforce !== null
            ? deserializeAws_restJson1SalesforceAction(output.salesforce, context)
            : undefined,
        sns: output.sns !== undefined && output.sns !== null
            ? deserializeAws_restJson1SnsAction(output.sns, context)
            : undefined,
        sqs: output.sqs !== undefined && output.sqs !== null
            ? deserializeAws_restJson1SqsAction(output.sqs, context)
            : undefined,
        stepFunctions: output.stepFunctions !== undefined && output.stepFunctions !== null
            ? deserializeAws_restJson1StepFunctionsAction(output.stepFunctions, context)
            : undefined,
        timestream: output.timestream !== undefined && output.timestream !== null
            ? deserializeAws_restJson1TimestreamAction(output.timestream, context)
            : undefined,
    };
};
const deserializeAws_restJson1ActionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Action(entry, context);
    });
};
const deserializeAws_restJson1ActiveViolation = (output, context) => {
    return {
        behavior: output.behavior !== undefined && output.behavior !== null
            ? deserializeAws_restJson1Behavior(output.behavior, context)
            : undefined,
        lastViolationTime: output.lastViolationTime !== undefined && output.lastViolationTime !== null
            ? new Date(Math.round(output.lastViolationTime * 1000))
            : undefined,
        lastViolationValue: output.lastViolationValue !== undefined && output.lastViolationValue !== null
            ? deserializeAws_restJson1MetricValue(output.lastViolationValue, context)
            : undefined,
        securityProfileName: output.securityProfileName !== undefined && output.securityProfileName !== null
            ? output.securityProfileName
            : undefined,
        thingName: output.thingName !== undefined && output.thingName !== null ? output.thingName : undefined,
        violationId: output.violationId !== undefined && output.violationId !== null ? output.violationId : undefined,
        violationStartTime: output.violationStartTime !== undefined && output.violationStartTime !== null
            ? new Date(Math.round(output.violationStartTime * 1000))
            : undefined,
    };
};
const deserializeAws_restJson1ActiveViolations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ActiveViolation(entry, context);
    });
};
const deserializeAws_restJson1AdditionalMetricsToRetainList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1AdditionalMetricsToRetainV2List = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1MetricToRetain(entry, context);
    });
};
const deserializeAws_restJson1AdditionalParameterMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const deserializeAws_restJson1AddThingsToThingGroupParams = (output, context) => {
    return {
        overrideDynamicGroups: output.overrideDynamicGroups !== undefined && output.overrideDynamicGroups !== null
            ? output.overrideDynamicGroups
            : undefined,
        thingGroupNames: output.thingGroupNames !== undefined && output.thingGroupNames !== null
            ? deserializeAws_restJson1ThingGroupNames(output.thingGroupNames, context)
            : undefined,
    };
};
const deserializeAws_restJson1AlertTarget = (output, context) => {
    return {
        alertTargetArn: output.alertTargetArn !== undefined && output.alertTargetArn !== null ? output.alertTargetArn : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1AlertTargets = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1AlertTarget(value, context),
        };
    }, {});
};
const deserializeAws_restJson1Allowed = (output, context) => {
    return {
        policies: output.policies !== undefined && output.policies !== null
            ? deserializeAws_restJson1Policies(output.policies, context)
            : undefined,
    };
};
const deserializeAws_restJson1AssetPropertyTimestamp = (output, context) => {
    return {
        offsetInNanos: output.offsetInNanos !== undefined && output.offsetInNanos !== null ? output.offsetInNanos : undefined,
        timeInSeconds: output.timeInSeconds !== undefined && output.timeInSeconds !== null ? output.timeInSeconds : undefined,
    };
};
const deserializeAws_restJson1AssetPropertyValue = (output, context) => {
    return {
        quality: output.quality !== undefined && output.quality !== null ? output.quality : undefined,
        timestamp: output.timestamp !== undefined && output.timestamp !== null
            ? deserializeAws_restJson1AssetPropertyTimestamp(output.timestamp, context)
            : undefined,
        value: output.value !== undefined && output.value !== null
            ? deserializeAws_restJson1AssetPropertyVariant(output.value, context)
            : undefined,
    };
};
const deserializeAws_restJson1AssetPropertyValueList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AssetPropertyValue(entry, context);
    });
};
const deserializeAws_restJson1AssetPropertyVariant = (output, context) => {
    if (output.booleanValue !== undefined && output.booleanValue !== null) {
        return {
            booleanValue: output.booleanValue,
        };
    }
    if (output.doubleValue !== undefined && output.doubleValue !== null) {
        return {
            doubleValue: output.doubleValue,
        };
    }
    if (output.integerValue !== undefined && output.integerValue !== null) {
        return {
            integerValue: output.integerValue,
        };
    }
    if (output.stringValue !== undefined && output.stringValue !== null) {
        return {
            stringValue: output.stringValue,
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const deserializeAws_restJson1AttributePayload = (output, context) => {
    return {
        attributes: output.attributes !== undefined && output.attributes !== null
            ? deserializeAws_restJson1Attributes(output.attributes, context)
            : undefined,
        merge: output.merge !== undefined && output.merge !== null ? output.merge : undefined,
    };
};
const deserializeAws_restJson1Attributes = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const deserializeAws_restJson1AttributesMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const deserializeAws_restJson1AuditCheckConfiguration = (output, context) => {
    return {
        enabled: output.enabled !== undefined && output.enabled !== null ? output.enabled : undefined,
    };
};
const deserializeAws_restJson1AuditCheckConfigurations = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1AuditCheckConfiguration(value, context),
        };
    }, {});
};
const deserializeAws_restJson1AuditCheckDetails = (output, context) => {
    return {
        checkCompliant: output.checkCompliant !== undefined && output.checkCompliant !== null ? output.checkCompliant : undefined,
        checkRunStatus: output.checkRunStatus !== undefined && output.checkRunStatus !== null ? output.checkRunStatus : undefined,
        errorCode: output.errorCode !== undefined && output.errorCode !== null ? output.errorCode : undefined,
        message: output.message !== undefined && output.message !== null ? output.message : undefined,
        nonCompliantResourcesCount: output.nonCompliantResourcesCount !== undefined && output.nonCompliantResourcesCount !== null
            ? output.nonCompliantResourcesCount
            : undefined,
        suppressedNonCompliantResourcesCount: output.suppressedNonCompliantResourcesCount !== undefined && output.suppressedNonCompliantResourcesCount !== null
            ? output.suppressedNonCompliantResourcesCount
            : undefined,
        totalResourcesCount: output.totalResourcesCount !== undefined && output.totalResourcesCount !== null
            ? output.totalResourcesCount
            : undefined,
    };
};
const deserializeAws_restJson1AuditCheckToActionsMapping = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1MitigationActionNameList(value, context),
        };
    }, {});
};
const deserializeAws_restJson1AuditCheckToReasonCodeFilter = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1ReasonForNonComplianceCodes(value, context),
        };
    }, {});
};
const deserializeAws_restJson1AuditDetails = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1AuditCheckDetails(value, context),
        };
    }, {});
};
const deserializeAws_restJson1AuditFinding = (output, context) => {
    return {
        checkName: output.checkName !== undefined && output.checkName !== null ? output.checkName : undefined,
        findingId: output.findingId !== undefined && output.findingId !== null ? output.findingId : undefined,
        findingTime: output.findingTime !== undefined && output.findingTime !== null
            ? new Date(Math.round(output.findingTime * 1000))
            : undefined,
        isSuppressed: output.isSuppressed !== undefined && output.isSuppressed !== null ? output.isSuppressed : undefined,
        nonCompliantResource: output.nonCompliantResource !== undefined && output.nonCompliantResource !== null
            ? deserializeAws_restJson1NonCompliantResource(output.nonCompliantResource, context)
            : undefined,
        reasonForNonCompliance: output.reasonForNonCompliance !== undefined && output.reasonForNonCompliance !== null
            ? output.reasonForNonCompliance
            : undefined,
        reasonForNonComplianceCode: output.reasonForNonComplianceCode !== undefined && output.reasonForNonComplianceCode !== null
            ? output.reasonForNonComplianceCode
            : undefined,
        relatedResources: output.relatedResources !== undefined && output.relatedResources !== null
            ? deserializeAws_restJson1RelatedResources(output.relatedResources, context)
            : undefined,
        severity: output.severity !== undefined && output.severity !== null ? output.severity : undefined,
        taskId: output.taskId !== undefined && output.taskId !== null ? output.taskId : undefined,
        taskStartTime: output.taskStartTime !== undefined && output.taskStartTime !== null
            ? new Date(Math.round(output.taskStartTime * 1000))
            : undefined,
    };
};
const deserializeAws_restJson1AuditFindings = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditFinding(entry, context);
    });
};
const deserializeAws_restJson1AuditMitigationActionExecutionMetadata = (output, context) => {
    return {
        actionId: output.actionId !== undefined && output.actionId !== null ? output.actionId : undefined,
        actionName: output.actionName !== undefined && output.actionName !== null ? output.actionName : undefined,
        endTime: output.endTime !== undefined && output.endTime !== null ? new Date(Math.round(output.endTime * 1000)) : undefined,
        errorCode: output.errorCode !== undefined && output.errorCode !== null ? output.errorCode : undefined,
        findingId: output.findingId !== undefined && output.findingId !== null ? output.findingId : undefined,
        message: output.message !== undefined && output.message !== null ? output.message : undefined,
        startTime: output.startTime !== undefined && output.startTime !== null
            ? new Date(Math.round(output.startTime * 1000))
            : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
        taskId: output.taskId !== undefined && output.taskId !== null ? output.taskId : undefined,
    };
};
const deserializeAws_restJson1AuditMitigationActionExecutionMetadataList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditMitigationActionExecutionMetadata(entry, context);
    });
};
const deserializeAws_restJson1AuditMitigationActionsTaskMetadata = (output, context) => {
    return {
        startTime: output.startTime !== undefined && output.startTime !== null
            ? new Date(Math.round(output.startTime * 1000))
            : undefined,
        taskId: output.taskId !== undefined && output.taskId !== null ? output.taskId : undefined,
        taskStatus: output.taskStatus !== undefined && output.taskStatus !== null ? output.taskStatus : undefined,
    };
};
const deserializeAws_restJson1AuditMitigationActionsTaskMetadataList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditMitigationActionsTaskMetadata(entry, context);
    });
};
const deserializeAws_restJson1AuditMitigationActionsTaskStatistics = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1TaskStatisticsForAuditCheck(value, context),
        };
    }, {});
};
const deserializeAws_restJson1AuditMitigationActionsTaskTarget = (output, context) => {
    return {
        auditCheckToReasonCodeFilter: output.auditCheckToReasonCodeFilter !== undefined && output.auditCheckToReasonCodeFilter !== null
            ? deserializeAws_restJson1AuditCheckToReasonCodeFilter(output.auditCheckToReasonCodeFilter, context)
            : undefined,
        auditTaskId: output.auditTaskId !== undefined && output.auditTaskId !== null ? output.auditTaskId : undefined,
        findingIds: output.findingIds !== undefined && output.findingIds !== null
            ? deserializeAws_restJson1FindingIds(output.findingIds, context)
            : undefined,
    };
};
const deserializeAws_restJson1AuditNotificationTarget = (output, context) => {
    return {
        enabled: output.enabled !== undefined && output.enabled !== null ? output.enabled : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        targetArn: output.targetArn !== undefined && output.targetArn !== null ? output.targetArn : undefined,
    };
};
const deserializeAws_restJson1AuditNotificationTargetConfigurations = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1AuditNotificationTarget(value, context),
        };
    }, {});
};
const deserializeAws_restJson1AuditSuppression = (output, context) => {
    return {
        checkName: output.checkName !== undefined && output.checkName !== null ? output.checkName : undefined,
        description: output.description !== undefined && output.description !== null ? output.description : undefined,
        expirationDate: output.expirationDate !== undefined && output.expirationDate !== null
            ? new Date(Math.round(output.expirationDate * 1000))
            : undefined,
        resourceIdentifier: output.resourceIdentifier !== undefined && output.resourceIdentifier !== null
            ? deserializeAws_restJson1ResourceIdentifier(output.resourceIdentifier, context)
            : undefined,
        suppressIndefinitely: output.suppressIndefinitely !== undefined && output.suppressIndefinitely !== null
            ? output.suppressIndefinitely
            : undefined,
    };
};
const deserializeAws_restJson1AuditSuppressionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditSuppression(entry, context);
    });
};
const deserializeAws_restJson1AuditTaskMetadata = (output, context) => {
    return {
        taskId: output.taskId !== undefined && output.taskId !== null ? output.taskId : undefined,
        taskStatus: output.taskStatus !== undefined && output.taskStatus !== null ? output.taskStatus : undefined,
        taskType: output.taskType !== undefined && output.taskType !== null ? output.taskType : undefined,
    };
};
const deserializeAws_restJson1AuditTaskMetadataList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditTaskMetadata(entry, context);
    });
};
const deserializeAws_restJson1AuthInfo = (output, context) => {
    return {
        actionType: output.actionType !== undefined && output.actionType !== null ? output.actionType : undefined,
        resources: output.resources !== undefined && output.resources !== null
            ? deserializeAws_restJson1Resources(output.resources, context)
            : undefined,
    };
};
const deserializeAws_restJson1AuthorizerConfig = (output, context) => {
    return {
        allowAuthorizerOverride: output.allowAuthorizerOverride !== undefined && output.allowAuthorizerOverride !== null
            ? output.allowAuthorizerOverride
            : undefined,
        defaultAuthorizerName: output.defaultAuthorizerName !== undefined && output.defaultAuthorizerName !== null
            ? output.defaultAuthorizerName
            : undefined,
    };
};
const deserializeAws_restJson1AuthorizerDescription = (output, context) => {
    return {
        authorizerArn: output.authorizerArn !== undefined && output.authorizerArn !== null ? output.authorizerArn : undefined,
        authorizerFunctionArn: output.authorizerFunctionArn !== undefined && output.authorizerFunctionArn !== null
            ? output.authorizerFunctionArn
            : undefined,
        authorizerName: output.authorizerName !== undefined && output.authorizerName !== null ? output.authorizerName : undefined,
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        lastModifiedDate: output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
            ? new Date(Math.round(output.lastModifiedDate * 1000))
            : undefined,
        signingDisabled: output.signingDisabled !== undefined && output.signingDisabled !== null ? output.signingDisabled : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
        tokenKeyName: output.tokenKeyName !== undefined && output.tokenKeyName !== null ? output.tokenKeyName : undefined,
        tokenSigningPublicKeys: output.tokenSigningPublicKeys !== undefined && output.tokenSigningPublicKeys !== null
            ? deserializeAws_restJson1PublicKeyMap(output.tokenSigningPublicKeys, context)
            : undefined,
    };
};
const deserializeAws_restJson1Authorizers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuthorizerSummary(entry, context);
    });
};
const deserializeAws_restJson1AuthorizerSummary = (output, context) => {
    return {
        authorizerArn: output.authorizerArn !== undefined && output.authorizerArn !== null ? output.authorizerArn : undefined,
        authorizerName: output.authorizerName !== undefined && output.authorizerName !== null ? output.authorizerName : undefined,
    };
};
const deserializeAws_restJson1AuthResult = (output, context) => {
    return {
        allowed: output.allowed !== undefined && output.allowed !== null
            ? deserializeAws_restJson1Allowed(output.allowed, context)
            : undefined,
        authDecision: output.authDecision !== undefined && output.authDecision !== null ? output.authDecision : undefined,
        authInfo: output.authInfo !== undefined && output.authInfo !== null
            ? deserializeAws_restJson1AuthInfo(output.authInfo, context)
            : undefined,
        denied: output.denied !== undefined && output.denied !== null
            ? deserializeAws_restJson1Denied(output.denied, context)
            : undefined,
        missingContextValues: output.missingContextValues !== undefined && output.missingContextValues !== null
            ? deserializeAws_restJson1MissingContextValues(output.missingContextValues, context)
            : undefined,
    };
};
const deserializeAws_restJson1AuthResults = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuthResult(entry, context);
    });
};
const deserializeAws_restJson1AwsJobExecutionsRolloutConfig = (output, context) => {
    return {
        exponentialRate: output.exponentialRate !== undefined && output.exponentialRate !== null
            ? deserializeAws_restJson1AwsJobExponentialRolloutRate(output.exponentialRate, context)
            : undefined,
        maximumPerMinute: output.maximumPerMinute !== undefined && output.maximumPerMinute !== null ? output.maximumPerMinute : undefined,
    };
};
const deserializeAws_restJson1AwsJobExponentialRolloutRate = (output, context) => {
    return {
        baseRatePerMinute: output.baseRatePerMinute !== undefined && output.baseRatePerMinute !== null
            ? output.baseRatePerMinute
            : undefined,
        incrementFactor: output.incrementFactor !== undefined && output.incrementFactor !== null ? output.incrementFactor : undefined,
        rateIncreaseCriteria: output.rateIncreaseCriteria !== undefined && output.rateIncreaseCriteria !== null
            ? deserializeAws_restJson1AwsJobRateIncreaseCriteria(output.rateIncreaseCriteria, context)
            : undefined,
    };
};
const deserializeAws_restJson1AwsJobPresignedUrlConfig = (output, context) => {
    return {
        expiresInSec: output.expiresInSec !== undefined && output.expiresInSec !== null ? output.expiresInSec : undefined,
    };
};
const deserializeAws_restJson1AwsJobRateIncreaseCriteria = (output, context) => {
    return {
        numberOfNotifiedThings: output.numberOfNotifiedThings !== undefined && output.numberOfNotifiedThings !== null
            ? output.numberOfNotifiedThings
            : undefined,
        numberOfSucceededThings: output.numberOfSucceededThings !== undefined && output.numberOfSucceededThings !== null
            ? output.numberOfSucceededThings
            : undefined,
    };
};
const deserializeAws_restJson1Behavior = (output, context) => {
    return {
        criteria: output.criteria !== undefined && output.criteria !== null
            ? deserializeAws_restJson1BehaviorCriteria(output.criteria, context)
            : undefined,
        metric: output.metric !== undefined && output.metric !== null ? output.metric : undefined,
        metricDimension: output.metricDimension !== undefined && output.metricDimension !== null
            ? deserializeAws_restJson1MetricDimension(output.metricDimension, context)
            : undefined,
        name: output.name !== undefined && output.name !== null ? output.name : undefined,
    };
};
const deserializeAws_restJson1BehaviorCriteria = (output, context) => {
    return {
        comparisonOperator: output.comparisonOperator !== undefined && output.comparisonOperator !== null
            ? output.comparisonOperator
            : undefined,
        consecutiveDatapointsToAlarm: output.consecutiveDatapointsToAlarm !== undefined && output.consecutiveDatapointsToAlarm !== null
            ? output.consecutiveDatapointsToAlarm
            : undefined,
        consecutiveDatapointsToClear: output.consecutiveDatapointsToClear !== undefined && output.consecutiveDatapointsToClear !== null
            ? output.consecutiveDatapointsToClear
            : undefined,
        durationSeconds: output.durationSeconds !== undefined && output.durationSeconds !== null ? output.durationSeconds : undefined,
        statisticalThreshold: output.statisticalThreshold !== undefined && output.statisticalThreshold !== null
            ? deserializeAws_restJson1StatisticalThreshold(output.statisticalThreshold, context)
            : undefined,
        value: output.value !== undefined && output.value !== null
            ? deserializeAws_restJson1MetricValue(output.value, context)
            : undefined,
    };
};
const deserializeAws_restJson1Behaviors = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Behavior(entry, context);
    });
};
const deserializeAws_restJson1BillingGroupMetadata = (output, context) => {
    return {
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
    };
};
const deserializeAws_restJson1BillingGroupNameAndArnList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1GroupNameAndArn(entry, context);
    });
};
const deserializeAws_restJson1BillingGroupProperties = (output, context) => {
    return {
        billingGroupDescription: output.billingGroupDescription !== undefined && output.billingGroupDescription !== null
            ? output.billingGroupDescription
            : undefined,
    };
};
const deserializeAws_restJson1CACertificate = (output, context) => {
    return {
        certificateArn: output.certificateArn !== undefined && output.certificateArn !== null ? output.certificateArn : undefined,
        certificateId: output.certificateId !== undefined && output.certificateId !== null ? output.certificateId : undefined,
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
    };
};
const deserializeAws_restJson1CACertificateDescription = (output, context) => {
    return {
        autoRegistrationStatus: output.autoRegistrationStatus !== undefined && output.autoRegistrationStatus !== null
            ? output.autoRegistrationStatus
            : undefined,
        certificateArn: output.certificateArn !== undefined && output.certificateArn !== null ? output.certificateArn : undefined,
        certificateId: output.certificateId !== undefined && output.certificateId !== null ? output.certificateId : undefined,
        certificatePem: output.certificatePem !== undefined && output.certificatePem !== null ? output.certificatePem : undefined,
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        customerVersion: output.customerVersion !== undefined && output.customerVersion !== null ? output.customerVersion : undefined,
        generationId: output.generationId !== undefined && output.generationId !== null ? output.generationId : undefined,
        lastModifiedDate: output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
            ? new Date(Math.round(output.lastModifiedDate * 1000))
            : undefined,
        ownedBy: output.ownedBy !== undefined && output.ownedBy !== null ? output.ownedBy : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
        validity: output.validity !== undefined && output.validity !== null
            ? deserializeAws_restJson1CertificateValidity(output.validity, context)
            : undefined,
    };
};
const deserializeAws_restJson1CACertificates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1CACertificate(entry, context);
    });
};
const deserializeAws_restJson1Certificate = (output, context) => {
    return {
        certificateArn: output.certificateArn !== undefined && output.certificateArn !== null ? output.certificateArn : undefined,
        certificateId: output.certificateId !== undefined && output.certificateId !== null ? output.certificateId : undefined,
        certificateMode: output.certificateMode !== undefined && output.certificateMode !== null ? output.certificateMode : undefined,
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
    };
};
const deserializeAws_restJson1CertificateDescription = (output, context) => {
    return {
        caCertificateId: output.caCertificateId !== undefined && output.caCertificateId !== null ? output.caCertificateId : undefined,
        certificateArn: output.certificateArn !== undefined && output.certificateArn !== null ? output.certificateArn : undefined,
        certificateId: output.certificateId !== undefined && output.certificateId !== null ? output.certificateId : undefined,
        certificateMode: output.certificateMode !== undefined && output.certificateMode !== null ? output.certificateMode : undefined,
        certificatePem: output.certificatePem !== undefined && output.certificatePem !== null ? output.certificatePem : undefined,
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        customerVersion: output.customerVersion !== undefined && output.customerVersion !== null ? output.customerVersion : undefined,
        generationId: output.generationId !== undefined && output.generationId !== null ? output.generationId : undefined,
        lastModifiedDate: output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
            ? new Date(Math.round(output.lastModifiedDate * 1000))
            : undefined,
        ownedBy: output.ownedBy !== undefined && output.ownedBy !== null ? output.ownedBy : undefined,
        previousOwnedBy: output.previousOwnedBy !== undefined && output.previousOwnedBy !== null ? output.previousOwnedBy : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
        transferData: output.transferData !== undefined && output.transferData !== null
            ? deserializeAws_restJson1TransferData(output.transferData, context)
            : undefined,
        validity: output.validity !== undefined && output.validity !== null
            ? deserializeAws_restJson1CertificateValidity(output.validity, context)
            : undefined,
    };
};
const deserializeAws_restJson1Certificates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Certificate(entry, context);
    });
};
const deserializeAws_restJson1CertificateValidity = (output, context) => {
    return {
        notAfter: output.notAfter !== undefined && output.notAfter !== null
            ? new Date(Math.round(output.notAfter * 1000))
            : undefined,
        notBefore: output.notBefore !== undefined && output.notBefore !== null
            ? new Date(Math.round(output.notBefore * 1000))
            : undefined,
    };
};
const deserializeAws_restJson1Cidrs = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1CloudwatchAlarmAction = (output, context) => {
    return {
        alarmName: output.alarmName !== undefined && output.alarmName !== null ? output.alarmName : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        stateReason: output.stateReason !== undefined && output.stateReason !== null ? output.stateReason : undefined,
        stateValue: output.stateValue !== undefined && output.stateValue !== null ? output.stateValue : undefined,
    };
};
const deserializeAws_restJson1CloudwatchLogsAction = (output, context) => {
    return {
        logGroupName: output.logGroupName !== undefined && output.logGroupName !== null ? output.logGroupName : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1CloudwatchMetricAction = (output, context) => {
    return {
        metricName: output.metricName !== undefined && output.metricName !== null ? output.metricName : undefined,
        metricNamespace: output.metricNamespace !== undefined && output.metricNamespace !== null ? output.metricNamespace : undefined,
        metricTimestamp: output.metricTimestamp !== undefined && output.metricTimestamp !== null ? output.metricTimestamp : undefined,
        metricUnit: output.metricUnit !== undefined && output.metricUnit !== null ? output.metricUnit : undefined,
        metricValue: output.metricValue !== undefined && output.metricValue !== null ? output.metricValue : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1CodeSigning = (output, context) => {
    return {
        awsSignerJobId: output.awsSignerJobId !== undefined && output.awsSignerJobId !== null ? output.awsSignerJobId : undefined,
        customCodeSigning: output.customCodeSigning !== undefined && output.customCodeSigning !== null
            ? deserializeAws_restJson1CustomCodeSigning(output.customCodeSigning, context)
            : undefined,
        startSigningJobParameter: output.startSigningJobParameter !== undefined && output.startSigningJobParameter !== null
            ? deserializeAws_restJson1StartSigningJobParameter(output.startSigningJobParameter, context)
            : undefined,
    };
};
const deserializeAws_restJson1CodeSigningCertificateChain = (output, context) => {
    return {
        certificateName: output.certificateName !== undefined && output.certificateName !== null ? output.certificateName : undefined,
        inlineDocument: output.inlineDocument !== undefined && output.inlineDocument !== null ? output.inlineDocument : undefined,
    };
};
const deserializeAws_restJson1CodeSigningSignature = (output, context) => {
    return {
        inlineDocument: output.inlineDocument !== undefined && output.inlineDocument !== null
            ? context.base64Decoder(output.inlineDocument)
            : undefined,
    };
};
const deserializeAws_restJson1Configuration = (output, context) => {
    return {
        Enabled: output.Enabled !== undefined && output.Enabled !== null ? output.Enabled : undefined,
    };
};
const deserializeAws_restJson1CustomCodeSigning = (output, context) => {
    return {
        certificateChain: output.certificateChain !== undefined && output.certificateChain !== null
            ? deserializeAws_restJson1CodeSigningCertificateChain(output.certificateChain, context)
            : undefined,
        hashAlgorithm: output.hashAlgorithm !== undefined && output.hashAlgorithm !== null ? output.hashAlgorithm : undefined,
        signature: output.signature !== undefined && output.signature !== null
            ? deserializeAws_restJson1CodeSigningSignature(output.signature, context)
            : undefined,
        signatureAlgorithm: output.signatureAlgorithm !== undefined && output.signatureAlgorithm !== null
            ? output.signatureAlgorithm
            : undefined,
    };
};
const deserializeAws_restJson1Denied = (output, context) => {
    return {
        explicitDeny: output.explicitDeny !== undefined && output.explicitDeny !== null
            ? deserializeAws_restJson1ExplicitDeny(output.explicitDeny, context)
            : undefined,
        implicitDeny: output.implicitDeny !== undefined && output.implicitDeny !== null
            ? deserializeAws_restJson1ImplicitDeny(output.implicitDeny, context)
            : undefined,
    };
};
const deserializeAws_restJson1Destination = (output, context) => {
    return {
        s3Destination: output.s3Destination !== undefined && output.s3Destination !== null
            ? deserializeAws_restJson1S3Destination(output.s3Destination, context)
            : undefined,
    };
};
const deserializeAws_restJson1DetailsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const deserializeAws_restJson1DimensionNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1DimensionStringValues = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1DomainConfigurations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1DomainConfigurationSummary(entry, context);
    });
};
const deserializeAws_restJson1DomainConfigurationSummary = (output, context) => {
    return {
        domainConfigurationArn: output.domainConfigurationArn !== undefined && output.domainConfigurationArn !== null
            ? output.domainConfigurationArn
            : undefined,
        domainConfigurationName: output.domainConfigurationName !== undefined && output.domainConfigurationName !== null
            ? output.domainConfigurationName
            : undefined,
        serviceType: output.serviceType !== undefined && output.serviceType !== null ? output.serviceType : undefined,
    };
};
const deserializeAws_restJson1DynamoDBAction = (output, context) => {
    return {
        hashKeyField: output.hashKeyField !== undefined && output.hashKeyField !== null ? output.hashKeyField : undefined,
        hashKeyType: output.hashKeyType !== undefined && output.hashKeyType !== null ? output.hashKeyType : undefined,
        hashKeyValue: output.hashKeyValue !== undefined && output.hashKeyValue !== null ? output.hashKeyValue : undefined,
        operation: output.operation !== undefined && output.operation !== null ? output.operation : undefined,
        payloadField: output.payloadField !== undefined && output.payloadField !== null ? output.payloadField : undefined,
        rangeKeyField: output.rangeKeyField !== undefined && output.rangeKeyField !== null ? output.rangeKeyField : undefined,
        rangeKeyType: output.rangeKeyType !== undefined && output.rangeKeyType !== null ? output.rangeKeyType : undefined,
        rangeKeyValue: output.rangeKeyValue !== undefined && output.rangeKeyValue !== null ? output.rangeKeyValue : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        tableName: output.tableName !== undefined && output.tableName !== null ? output.tableName : undefined,
    };
};
const deserializeAws_restJson1DynamoDBv2Action = (output, context) => {
    return {
        putItem: output.putItem !== undefined && output.putItem !== null
            ? deserializeAws_restJson1PutItemInput(output.putItem, context)
            : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1EffectivePolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1EffectivePolicy(entry, context);
    });
};
const deserializeAws_restJson1EffectivePolicy = (output, context) => {
    return {
        policyArn: output.policyArn !== undefined && output.policyArn !== null ? output.policyArn : undefined,
        policyDocument: output.policyDocument !== undefined && output.policyDocument !== null ? output.policyDocument : undefined,
        policyName: output.policyName !== undefined && output.policyName !== null ? output.policyName : undefined,
    };
};
const deserializeAws_restJson1ElasticsearchAction = (output, context) => {
    return {
        endpoint: output.endpoint !== undefined && output.endpoint !== null ? output.endpoint : undefined,
        id: output.id !== undefined && output.id !== null ? output.id : undefined,
        index: output.index !== undefined && output.index !== null ? output.index : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        type: output.type !== undefined && output.type !== null ? output.type : undefined,
    };
};
const deserializeAws_restJson1EnableIoTLoggingParams = (output, context) => {
    return {
        logLevel: output.logLevel !== undefined && output.logLevel !== null ? output.logLevel : undefined,
        roleArnForLogging: output.roleArnForLogging !== undefined && output.roleArnForLogging !== null
            ? output.roleArnForLogging
            : undefined,
    };
};
const deserializeAws_restJson1ErrorInfo = (output, context) => {
    return {
        code: output.code !== undefined && output.code !== null ? output.code : undefined,
        message: output.message !== undefined && output.message !== null ? output.message : undefined,
    };
};
const deserializeAws_restJson1EventConfigurations = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1Configuration(value, context),
        };
    }, {});
};
const deserializeAws_restJson1ExplicitDeny = (output, context) => {
    return {
        policies: output.policies !== undefined && output.policies !== null
            ? deserializeAws_restJson1Policies(output.policies, context)
            : undefined,
    };
};
const deserializeAws_restJson1ExponentialRolloutRate = (output, context) => {
    return {
        baseRatePerMinute: output.baseRatePerMinute !== undefined && output.baseRatePerMinute !== null
            ? output.baseRatePerMinute
            : undefined,
        incrementFactor: output.incrementFactor !== undefined && output.incrementFactor !== null ? output.incrementFactor : undefined,
        rateIncreaseCriteria: output.rateIncreaseCriteria !== undefined && output.rateIncreaseCriteria !== null
            ? deserializeAws_restJson1RateIncreaseCriteria(output.rateIncreaseCriteria, context)
            : undefined,
    };
};
const deserializeAws_restJson1Field = (output, context) => {
    return {
        name: output.name !== undefined && output.name !== null ? output.name : undefined,
        type: output.type !== undefined && output.type !== null ? output.type : undefined,
    };
};
const deserializeAws_restJson1Fields = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Field(entry, context);
    });
};
const deserializeAws_restJson1FileLocation = (output, context) => {
    return {
        s3Location: output.s3Location !== undefined && output.s3Location !== null
            ? deserializeAws_restJson1S3Location(output.s3Location, context)
            : undefined,
        stream: output.stream !== undefined && output.stream !== null
            ? deserializeAws_restJson1_Stream(output.stream, context)
            : undefined,
    };
};
const deserializeAws_restJson1FindingIds = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1FirehoseAction = (output, context) => {
    return {
        batchMode: output.batchMode !== undefined && output.batchMode !== null ? output.batchMode : undefined,
        deliveryStreamName: output.deliveryStreamName !== undefined && output.deliveryStreamName !== null
            ? output.deliveryStreamName
            : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        separator: output.separator !== undefined && output.separator !== null ? output.separator : undefined,
    };
};
const deserializeAws_restJson1GroupNameAndArn = (output, context) => {
    return {
        groupArn: output.groupArn !== undefined && output.groupArn !== null ? output.groupArn : undefined,
        groupName: output.groupName !== undefined && output.groupName !== null ? output.groupName : undefined,
    };
};
const deserializeAws_restJson1HeaderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1HttpActionHeader(entry, context);
    });
};
const deserializeAws_restJson1HttpAction = (output, context) => {
    return {
        auth: output.auth !== undefined && output.auth !== null
            ? deserializeAws_restJson1HttpAuthorization(output.auth, context)
            : undefined,
        confirmationUrl: output.confirmationUrl !== undefined && output.confirmationUrl !== null ? output.confirmationUrl : undefined,
        headers: output.headers !== undefined && output.headers !== null
            ? deserializeAws_restJson1HeaderList(output.headers, context)
            : undefined,
        url: output.url !== undefined && output.url !== null ? output.url : undefined,
    };
};
const deserializeAws_restJson1HttpActionHeader = (output, context) => {
    return {
        key: output.key !== undefined && output.key !== null ? output.key : undefined,
        value: output.value !== undefined && output.value !== null ? output.value : undefined,
    };
};
const deserializeAws_restJson1HttpAuthorization = (output, context) => {
    return {
        sigv4: output.sigv4 !== undefined && output.sigv4 !== null
            ? deserializeAws_restJson1SigV4Authorization(output.sigv4, context)
            : undefined,
    };
};
const deserializeAws_restJson1HttpUrlDestinationProperties = (output, context) => {
    return {
        confirmationUrl: output.confirmationUrl !== undefined && output.confirmationUrl !== null ? output.confirmationUrl : undefined,
    };
};
const deserializeAws_restJson1HttpUrlDestinationSummary = (output, context) => {
    return {
        confirmationUrl: output.confirmationUrl !== undefined && output.confirmationUrl !== null ? output.confirmationUrl : undefined,
    };
};
const deserializeAws_restJson1ImplicitDeny = (output, context) => {
    return {
        policies: output.policies !== undefined && output.policies !== null
            ? deserializeAws_restJson1Policies(output.policies, context)
            : undefined,
    };
};
const deserializeAws_restJson1IndexNamesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1IotAnalyticsAction = (output, context) => {
    return {
        batchMode: output.batchMode !== undefined && output.batchMode !== null ? output.batchMode : undefined,
        channelArn: output.channelArn !== undefined && output.channelArn !== null ? output.channelArn : undefined,
        channelName: output.channelName !== undefined && output.channelName !== null ? output.channelName : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1IotEventsAction = (output, context) => {
    return {
        batchMode: output.batchMode !== undefined && output.batchMode !== null ? output.batchMode : undefined,
        inputName: output.inputName !== undefined && output.inputName !== null ? output.inputName : undefined,
        messageId: output.messageId !== undefined && output.messageId !== null ? output.messageId : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1IotSiteWiseAction = (output, context) => {
    return {
        putAssetPropertyValueEntries: output.putAssetPropertyValueEntries !== undefined && output.putAssetPropertyValueEntries !== null
            ? deserializeAws_restJson1PutAssetPropertyValueEntryList(output.putAssetPropertyValueEntries, context)
            : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1Job = (output, context) => {
    return {
        abortConfig: output.abortConfig !== undefined && output.abortConfig !== null
            ? deserializeAws_restJson1AbortConfig(output.abortConfig, context)
            : undefined,
        comment: output.comment !== undefined && output.comment !== null ? output.comment : undefined,
        completedAt: output.completedAt !== undefined && output.completedAt !== null
            ? new Date(Math.round(output.completedAt * 1000))
            : undefined,
        createdAt: output.createdAt !== undefined && output.createdAt !== null
            ? new Date(Math.round(output.createdAt * 1000))
            : undefined,
        description: output.description !== undefined && output.description !== null ? output.description : undefined,
        forceCanceled: output.forceCanceled !== undefined && output.forceCanceled !== null ? output.forceCanceled : undefined,
        jobArn: output.jobArn !== undefined && output.jobArn !== null ? output.jobArn : undefined,
        jobExecutionsRolloutConfig: output.jobExecutionsRolloutConfig !== undefined && output.jobExecutionsRolloutConfig !== null
            ? deserializeAws_restJson1JobExecutionsRolloutConfig(output.jobExecutionsRolloutConfig, context)
            : undefined,
        jobId: output.jobId !== undefined && output.jobId !== null ? output.jobId : undefined,
        jobProcessDetails: output.jobProcessDetails !== undefined && output.jobProcessDetails !== null
            ? deserializeAws_restJson1JobProcessDetails(output.jobProcessDetails, context)
            : undefined,
        lastUpdatedAt: output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
            ? new Date(Math.round(output.lastUpdatedAt * 1000))
            : undefined,
        namespaceId: output.namespaceId !== undefined && output.namespaceId !== null ? output.namespaceId : undefined,
        presignedUrlConfig: output.presignedUrlConfig !== undefined && output.presignedUrlConfig !== null
            ? deserializeAws_restJson1PresignedUrlConfig(output.presignedUrlConfig, context)
            : undefined,
        reasonCode: output.reasonCode !== undefined && output.reasonCode !== null ? output.reasonCode : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
        targetSelection: output.targetSelection !== undefined && output.targetSelection !== null ? output.targetSelection : undefined,
        targets: output.targets !== undefined && output.targets !== null
            ? deserializeAws_restJson1JobTargets(output.targets, context)
            : undefined,
        timeoutConfig: output.timeoutConfig !== undefined && output.timeoutConfig !== null
            ? deserializeAws_restJson1TimeoutConfig(output.timeoutConfig, context)
            : undefined,
    };
};
const deserializeAws_restJson1JobExecution = (output, context) => {
    return {
        approximateSecondsBeforeTimedOut: output.approximateSecondsBeforeTimedOut !== undefined && output.approximateSecondsBeforeTimedOut !== null
            ? output.approximateSecondsBeforeTimedOut
            : undefined,
        executionNumber: output.executionNumber !== undefined && output.executionNumber !== null ? output.executionNumber : undefined,
        forceCanceled: output.forceCanceled !== undefined && output.forceCanceled !== null ? output.forceCanceled : undefined,
        jobId: output.jobId !== undefined && output.jobId !== null ? output.jobId : undefined,
        lastUpdatedAt: output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
            ? new Date(Math.round(output.lastUpdatedAt * 1000))
            : undefined,
        queuedAt: output.queuedAt !== undefined && output.queuedAt !== null
            ? new Date(Math.round(output.queuedAt * 1000))
            : undefined,
        startedAt: output.startedAt !== undefined && output.startedAt !== null
            ? new Date(Math.round(output.startedAt * 1000))
            : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
        statusDetails: output.statusDetails !== undefined && output.statusDetails !== null
            ? deserializeAws_restJson1JobExecutionStatusDetails(output.statusDetails, context)
            : undefined,
        thingArn: output.thingArn !== undefined && output.thingArn !== null ? output.thingArn : undefined,
        versionNumber: output.versionNumber !== undefined && output.versionNumber !== null ? output.versionNumber : undefined,
    };
};
const deserializeAws_restJson1JobExecutionsRolloutConfig = (output, context) => {
    return {
        exponentialRate: output.exponentialRate !== undefined && output.exponentialRate !== null
            ? deserializeAws_restJson1ExponentialRolloutRate(output.exponentialRate, context)
            : undefined,
        maximumPerMinute: output.maximumPerMinute !== undefined && output.maximumPerMinute !== null ? output.maximumPerMinute : undefined,
    };
};
const deserializeAws_restJson1JobExecutionStatusDetails = (output, context) => {
    return {
        detailsMap: output.detailsMap !== undefined && output.detailsMap !== null
            ? deserializeAws_restJson1DetailsMap(output.detailsMap, context)
            : undefined,
    };
};
const deserializeAws_restJson1JobExecutionSummary = (output, context) => {
    return {
        executionNumber: output.executionNumber !== undefined && output.executionNumber !== null ? output.executionNumber : undefined,
        lastUpdatedAt: output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
            ? new Date(Math.round(output.lastUpdatedAt * 1000))
            : undefined,
        queuedAt: output.queuedAt !== undefined && output.queuedAt !== null
            ? new Date(Math.round(output.queuedAt * 1000))
            : undefined,
        startedAt: output.startedAt !== undefined && output.startedAt !== null
            ? new Date(Math.round(output.startedAt * 1000))
            : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
    };
};
const deserializeAws_restJson1JobExecutionSummaryForJob = (output, context) => {
    return {
        jobExecutionSummary: output.jobExecutionSummary !== undefined && output.jobExecutionSummary !== null
            ? deserializeAws_restJson1JobExecutionSummary(output.jobExecutionSummary, context)
            : undefined,
        thingArn: output.thingArn !== undefined && output.thingArn !== null ? output.thingArn : undefined,
    };
};
const deserializeAws_restJson1JobExecutionSummaryForJobList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1JobExecutionSummaryForJob(entry, context);
    });
};
const deserializeAws_restJson1JobExecutionSummaryForThing = (output, context) => {
    return {
        jobExecutionSummary: output.jobExecutionSummary !== undefined && output.jobExecutionSummary !== null
            ? deserializeAws_restJson1JobExecutionSummary(output.jobExecutionSummary, context)
            : undefined,
        jobId: output.jobId !== undefined && output.jobId !== null ? output.jobId : undefined,
    };
};
const deserializeAws_restJson1JobExecutionSummaryForThingList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1JobExecutionSummaryForThing(entry, context);
    });
};
const deserializeAws_restJson1JobProcessDetails = (output, context) => {
    return {
        numberOfCanceledThings: output.numberOfCanceledThings !== undefined && output.numberOfCanceledThings !== null
            ? output.numberOfCanceledThings
            : undefined,
        numberOfFailedThings: output.numberOfFailedThings !== undefined && output.numberOfFailedThings !== null
            ? output.numberOfFailedThings
            : undefined,
        numberOfInProgressThings: output.numberOfInProgressThings !== undefined && output.numberOfInProgressThings !== null
            ? output.numberOfInProgressThings
            : undefined,
        numberOfQueuedThings: output.numberOfQueuedThings !== undefined && output.numberOfQueuedThings !== null
            ? output.numberOfQueuedThings
            : undefined,
        numberOfRejectedThings: output.numberOfRejectedThings !== undefined && output.numberOfRejectedThings !== null
            ? output.numberOfRejectedThings
            : undefined,
        numberOfRemovedThings: output.numberOfRemovedThings !== undefined && output.numberOfRemovedThings !== null
            ? output.numberOfRemovedThings
            : undefined,
        numberOfSucceededThings: output.numberOfSucceededThings !== undefined && output.numberOfSucceededThings !== null
            ? output.numberOfSucceededThings
            : undefined,
        numberOfTimedOutThings: output.numberOfTimedOutThings !== undefined && output.numberOfTimedOutThings !== null
            ? output.numberOfTimedOutThings
            : undefined,
        processingTargets: output.processingTargets !== undefined && output.processingTargets !== null
            ? deserializeAws_restJson1ProcessingTargetNameList(output.processingTargets, context)
            : undefined,
    };
};
const deserializeAws_restJson1JobSummary = (output, context) => {
    return {
        completedAt: output.completedAt !== undefined && output.completedAt !== null
            ? new Date(Math.round(output.completedAt * 1000))
            : undefined,
        createdAt: output.createdAt !== undefined && output.createdAt !== null
            ? new Date(Math.round(output.createdAt * 1000))
            : undefined,
        jobArn: output.jobArn !== undefined && output.jobArn !== null ? output.jobArn : undefined,
        jobId: output.jobId !== undefined && output.jobId !== null ? output.jobId : undefined,
        lastUpdatedAt: output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
            ? new Date(Math.round(output.lastUpdatedAt * 1000))
            : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
        targetSelection: output.targetSelection !== undefined && output.targetSelection !== null ? output.targetSelection : undefined,
        thingGroupId: output.thingGroupId !== undefined && output.thingGroupId !== null ? output.thingGroupId : undefined,
    };
};
const deserializeAws_restJson1JobSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1JobSummary(entry, context);
    });
};
const deserializeAws_restJson1JobTargets = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1KeyPair = (output, context) => {
    return {
        PrivateKey: output.PrivateKey !== undefined && output.PrivateKey !== null ? output.PrivateKey : undefined,
        PublicKey: output.PublicKey !== undefined && output.PublicKey !== null ? output.PublicKey : undefined,
    };
};
const deserializeAws_restJson1KinesisAction = (output, context) => {
    return {
        partitionKey: output.partitionKey !== undefined && output.partitionKey !== null ? output.partitionKey : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        streamName: output.streamName !== undefined && output.streamName !== null ? output.streamName : undefined,
    };
};
const deserializeAws_restJson1LambdaAction = (output, context) => {
    return {
        functionArn: output.functionArn !== undefined && output.functionArn !== null ? output.functionArn : undefined,
    };
};
const deserializeAws_restJson1LogTarget = (output, context) => {
    return {
        targetName: output.targetName !== undefined && output.targetName !== null ? output.targetName : undefined,
        targetType: output.targetType !== undefined && output.targetType !== null ? output.targetType : undefined,
    };
};
const deserializeAws_restJson1LogTargetConfiguration = (output, context) => {
    return {
        logLevel: output.logLevel !== undefined && output.logLevel !== null ? output.logLevel : undefined,
        logTarget: output.logTarget !== undefined && output.logTarget !== null
            ? deserializeAws_restJson1LogTarget(output.logTarget, context)
            : undefined,
    };
};
const deserializeAws_restJson1LogTargetConfigurations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1LogTargetConfiguration(entry, context);
    });
};
const deserializeAws_restJson1MetricDimension = (output, context) => {
    return {
        dimensionName: output.dimensionName !== undefined && output.dimensionName !== null ? output.dimensionName : undefined,
        operator: output.operator !== undefined && output.operator !== null ? output.operator : undefined,
    };
};
const deserializeAws_restJson1MetricToRetain = (output, context) => {
    return {
        metric: output.metric !== undefined && output.metric !== null ? output.metric : undefined,
        metricDimension: output.metricDimension !== undefined && output.metricDimension !== null
            ? deserializeAws_restJson1MetricDimension(output.metricDimension, context)
            : undefined,
    };
};
const deserializeAws_restJson1MetricValue = (output, context) => {
    return {
        cidrs: output.cidrs !== undefined && output.cidrs !== null
            ? deserializeAws_restJson1Cidrs(output.cidrs, context)
            : undefined,
        count: output.count !== undefined && output.count !== null ? output.count : undefined,
        ports: output.ports !== undefined && output.ports !== null
            ? deserializeAws_restJson1Ports(output.ports, context)
            : undefined,
    };
};
const deserializeAws_restJson1MissingContextValues = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1MitigationAction = (output, context) => {
    return {
        actionParams: output.actionParams !== undefined && output.actionParams !== null
            ? deserializeAws_restJson1MitigationActionParams(output.actionParams, context)
            : undefined,
        id: output.id !== undefined && output.id !== null ? output.id : undefined,
        name: output.name !== undefined && output.name !== null ? output.name : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1MitigationActionIdentifier = (output, context) => {
    return {
        actionArn: output.actionArn !== undefined && output.actionArn !== null ? output.actionArn : undefined,
        actionName: output.actionName !== undefined && output.actionName !== null ? output.actionName : undefined,
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
    };
};
const deserializeAws_restJson1MitigationActionIdentifierList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1MitigationActionIdentifier(entry, context);
    });
};
const deserializeAws_restJson1MitigationActionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1MitigationAction(entry, context);
    });
};
const deserializeAws_restJson1MitigationActionNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1MitigationActionParams = (output, context) => {
    return {
        addThingsToThingGroupParams: output.addThingsToThingGroupParams !== undefined && output.addThingsToThingGroupParams !== null
            ? deserializeAws_restJson1AddThingsToThingGroupParams(output.addThingsToThingGroupParams, context)
            : undefined,
        enableIoTLoggingParams: output.enableIoTLoggingParams !== undefined && output.enableIoTLoggingParams !== null
            ? deserializeAws_restJson1EnableIoTLoggingParams(output.enableIoTLoggingParams, context)
            : undefined,
        publishFindingToSnsParams: output.publishFindingToSnsParams !== undefined && output.publishFindingToSnsParams !== null
            ? deserializeAws_restJson1PublishFindingToSnsParams(output.publishFindingToSnsParams, context)
            : undefined,
        replaceDefaultPolicyVersionParams: output.replaceDefaultPolicyVersionParams !== undefined && output.replaceDefaultPolicyVersionParams !== null
            ? deserializeAws_restJson1ReplaceDefaultPolicyVersionParams(output.replaceDefaultPolicyVersionParams, context)
            : undefined,
        updateCACertificateParams: output.updateCACertificateParams !== undefined && output.updateCACertificateParams !== null
            ? deserializeAws_restJson1UpdateCACertificateParams(output.updateCACertificateParams, context)
            : undefined,
        updateDeviceCertificateParams: output.updateDeviceCertificateParams !== undefined && output.updateDeviceCertificateParams !== null
            ? deserializeAws_restJson1UpdateDeviceCertificateParams(output.updateDeviceCertificateParams, context)
            : undefined,
    };
};
const deserializeAws_restJson1NonCompliantResource = (output, context) => {
    return {
        additionalInfo: output.additionalInfo !== undefined && output.additionalInfo !== null
            ? deserializeAws_restJson1StringMap(output.additionalInfo, context)
            : undefined,
        resourceIdentifier: output.resourceIdentifier !== undefined && output.resourceIdentifier !== null
            ? deserializeAws_restJson1ResourceIdentifier(output.resourceIdentifier, context)
            : undefined,
        resourceType: output.resourceType !== undefined && output.resourceType !== null ? output.resourceType : undefined,
    };
};
const deserializeAws_restJson1OTAUpdateFile = (output, context) => {
    return {
        attributes: output.attributes !== undefined && output.attributes !== null
            ? deserializeAws_restJson1AttributesMap(output.attributes, context)
            : undefined,
        codeSigning: output.codeSigning !== undefined && output.codeSigning !== null
            ? deserializeAws_restJson1CodeSigning(output.codeSigning, context)
            : undefined,
        fileLocation: output.fileLocation !== undefined && output.fileLocation !== null
            ? deserializeAws_restJson1FileLocation(output.fileLocation, context)
            : undefined,
        fileName: output.fileName !== undefined && output.fileName !== null ? output.fileName : undefined,
        fileType: output.fileType !== undefined && output.fileType !== null ? output.fileType : undefined,
        fileVersion: output.fileVersion !== undefined && output.fileVersion !== null ? output.fileVersion : undefined,
    };
};
const deserializeAws_restJson1OTAUpdateFiles = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1OTAUpdateFile(entry, context);
    });
};
const deserializeAws_restJson1OTAUpdateInfo = (output, context) => {
    return {
        additionalParameters: output.additionalParameters !== undefined && output.additionalParameters !== null
            ? deserializeAws_restJson1AdditionalParameterMap(output.additionalParameters, context)
            : undefined,
        awsIotJobArn: output.awsIotJobArn !== undefined && output.awsIotJobArn !== null ? output.awsIotJobArn : undefined,
        awsIotJobId: output.awsIotJobId !== undefined && output.awsIotJobId !== null ? output.awsIotJobId : undefined,
        awsJobExecutionsRolloutConfig: output.awsJobExecutionsRolloutConfig !== undefined && output.awsJobExecutionsRolloutConfig !== null
            ? deserializeAws_restJson1AwsJobExecutionsRolloutConfig(output.awsJobExecutionsRolloutConfig, context)
            : undefined,
        awsJobPresignedUrlConfig: output.awsJobPresignedUrlConfig !== undefined && output.awsJobPresignedUrlConfig !== null
            ? deserializeAws_restJson1AwsJobPresignedUrlConfig(output.awsJobPresignedUrlConfig, context)
            : undefined,
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        description: output.description !== undefined && output.description !== null ? output.description : undefined,
        errorInfo: output.errorInfo !== undefined && output.errorInfo !== null
            ? deserializeAws_restJson1ErrorInfo(output.errorInfo, context)
            : undefined,
        lastModifiedDate: output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
            ? new Date(Math.round(output.lastModifiedDate * 1000))
            : undefined,
        otaUpdateArn: output.otaUpdateArn !== undefined && output.otaUpdateArn !== null ? output.otaUpdateArn : undefined,
        otaUpdateFiles: output.otaUpdateFiles !== undefined && output.otaUpdateFiles !== null
            ? deserializeAws_restJson1OTAUpdateFiles(output.otaUpdateFiles, context)
            : undefined,
        otaUpdateId: output.otaUpdateId !== undefined && output.otaUpdateId !== null ? output.otaUpdateId : undefined,
        otaUpdateStatus: output.otaUpdateStatus !== undefined && output.otaUpdateStatus !== null ? output.otaUpdateStatus : undefined,
        protocols: output.protocols !== undefined && output.protocols !== null
            ? deserializeAws_restJson1Protocols(output.protocols, context)
            : undefined,
        targetSelection: output.targetSelection !== undefined && output.targetSelection !== null ? output.targetSelection : undefined,
        targets: output.targets !== undefined && output.targets !== null
            ? deserializeAws_restJson1Targets(output.targets, context)
            : undefined,
    };
};
const deserializeAws_restJson1OTAUpdatesSummary = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1OTAUpdateSummary(entry, context);
    });
};
const deserializeAws_restJson1OTAUpdateSummary = (output, context) => {
    return {
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        otaUpdateArn: output.otaUpdateArn !== undefined && output.otaUpdateArn !== null ? output.otaUpdateArn : undefined,
        otaUpdateId: output.otaUpdateId !== undefined && output.otaUpdateId !== null ? output.otaUpdateId : undefined,
    };
};
const deserializeAws_restJson1OutgoingCertificate = (output, context) => {
    return {
        certificateArn: output.certificateArn !== undefined && output.certificateArn !== null ? output.certificateArn : undefined,
        certificateId: output.certificateId !== undefined && output.certificateId !== null ? output.certificateId : undefined,
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        transferDate: output.transferDate !== undefined && output.transferDate !== null
            ? new Date(Math.round(output.transferDate * 1000))
            : undefined,
        transferMessage: output.transferMessage !== undefined && output.transferMessage !== null ? output.transferMessage : undefined,
        transferredTo: output.transferredTo !== undefined && output.transferredTo !== null ? output.transferredTo : undefined,
    };
};
const deserializeAws_restJson1OutgoingCertificates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1OutgoingCertificate(entry, context);
    });
};
const deserializeAws_restJson1Percentiles = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PercentPair(entry, context);
    });
};
const deserializeAws_restJson1PercentPair = (output, context) => {
    return {
        percent: output.percent !== undefined && output.percent !== null ? output.percent : undefined,
        value: output.value !== undefined && output.value !== null ? output.value : undefined,
    };
};
const deserializeAws_restJson1Policies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Policy(entry, context);
    });
};
const deserializeAws_restJson1Policy = (output, context) => {
    return {
        policyArn: output.policyArn !== undefined && output.policyArn !== null ? output.policyArn : undefined,
        policyName: output.policyName !== undefined && output.policyName !== null ? output.policyName : undefined,
    };
};
const deserializeAws_restJson1PolicyDocuments = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1PolicyTargets = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1PolicyVersion = (output, context) => {
    return {
        createDate: output.createDate !== undefined && output.createDate !== null
            ? new Date(Math.round(output.createDate * 1000))
            : undefined,
        isDefaultVersion: output.isDefaultVersion !== undefined && output.isDefaultVersion !== null ? output.isDefaultVersion : undefined,
        versionId: output.versionId !== undefined && output.versionId !== null ? output.versionId : undefined,
    };
};
const deserializeAws_restJson1PolicyVersionIdentifier = (output, context) => {
    return {
        policyName: output.policyName !== undefined && output.policyName !== null ? output.policyName : undefined,
        policyVersionId: output.policyVersionId !== undefined && output.policyVersionId !== null ? output.policyVersionId : undefined,
    };
};
const deserializeAws_restJson1PolicyVersions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PolicyVersion(entry, context);
    });
};
const deserializeAws_restJson1Ports = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1PresignedUrlConfig = (output, context) => {
    return {
        expiresInSec: output.expiresInSec !== undefined && output.expiresInSec !== null ? output.expiresInSec : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1Principals = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1ProcessingTargetNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1Protocols = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1ProvisioningHook = (output, context) => {
    return {
        payloadVersion: output.payloadVersion !== undefined && output.payloadVersion !== null ? output.payloadVersion : undefined,
        targetArn: output.targetArn !== undefined && output.targetArn !== null ? output.targetArn : undefined,
    };
};
const deserializeAws_restJson1ProvisioningTemplateListing = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ProvisioningTemplateSummary(entry, context);
    });
};
const deserializeAws_restJson1ProvisioningTemplateSummary = (output, context) => {
    return {
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        description: output.description !== undefined && output.description !== null ? output.description : undefined,
        enabled: output.enabled !== undefined && output.enabled !== null ? output.enabled : undefined,
        lastModifiedDate: output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
            ? new Date(Math.round(output.lastModifiedDate * 1000))
            : undefined,
        templateArn: output.templateArn !== undefined && output.templateArn !== null ? output.templateArn : undefined,
        templateName: output.templateName !== undefined && output.templateName !== null ? output.templateName : undefined,
    };
};
const deserializeAws_restJson1ProvisioningTemplateVersionListing = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ProvisioningTemplateVersionSummary(entry, context);
    });
};
const deserializeAws_restJson1ProvisioningTemplateVersionSummary = (output, context) => {
    return {
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        isDefaultVersion: output.isDefaultVersion !== undefined && output.isDefaultVersion !== null ? output.isDefaultVersion : undefined,
        versionId: output.versionId !== undefined && output.versionId !== null ? output.versionId : undefined,
    };
};
const deserializeAws_restJson1PublicKeyMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const deserializeAws_restJson1PublishFindingToSnsParams = (output, context) => {
    return {
        topicArn: output.topicArn !== undefined && output.topicArn !== null ? output.topicArn : undefined,
    };
};
const deserializeAws_restJson1PutAssetPropertyValueEntry = (output, context) => {
    return {
        assetId: output.assetId !== undefined && output.assetId !== null ? output.assetId : undefined,
        entryId: output.entryId !== undefined && output.entryId !== null ? output.entryId : undefined,
        propertyAlias: output.propertyAlias !== undefined && output.propertyAlias !== null ? output.propertyAlias : undefined,
        propertyId: output.propertyId !== undefined && output.propertyId !== null ? output.propertyId : undefined,
        propertyValues: output.propertyValues !== undefined && output.propertyValues !== null
            ? deserializeAws_restJson1AssetPropertyValueList(output.propertyValues, context)
            : undefined,
    };
};
const deserializeAws_restJson1PutAssetPropertyValueEntryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PutAssetPropertyValueEntry(entry, context);
    });
};
const deserializeAws_restJson1PutItemInput = (output, context) => {
    return {
        tableName: output.tableName !== undefined && output.tableName !== null ? output.tableName : undefined,
    };
};
const deserializeAws_restJson1RateIncreaseCriteria = (output, context) => {
    return {
        numberOfNotifiedThings: output.numberOfNotifiedThings !== undefined && output.numberOfNotifiedThings !== null
            ? output.numberOfNotifiedThings
            : undefined,
        numberOfSucceededThings: output.numberOfSucceededThings !== undefined && output.numberOfSucceededThings !== null
            ? output.numberOfSucceededThings
            : undefined,
    };
};
const deserializeAws_restJson1ReasonForNonComplianceCodes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1RegistrationConfig = (output, context) => {
    return {
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        templateBody: output.templateBody !== undefined && output.templateBody !== null ? output.templateBody : undefined,
    };
};
const deserializeAws_restJson1RelatedResource = (output, context) => {
    return {
        additionalInfo: output.additionalInfo !== undefined && output.additionalInfo !== null
            ? deserializeAws_restJson1StringMap(output.additionalInfo, context)
            : undefined,
        resourceIdentifier: output.resourceIdentifier !== undefined && output.resourceIdentifier !== null
            ? deserializeAws_restJson1ResourceIdentifier(output.resourceIdentifier, context)
            : undefined,
        resourceType: output.resourceType !== undefined && output.resourceType !== null ? output.resourceType : undefined,
    };
};
const deserializeAws_restJson1RelatedResources = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1RelatedResource(entry, context);
    });
};
const deserializeAws_restJson1ReplaceDefaultPolicyVersionParams = (output, context) => {
    return {
        templateName: output.templateName !== undefined && output.templateName !== null ? output.templateName : undefined,
    };
};
const deserializeAws_restJson1RepublishAction = (output, context) => {
    return {
        qos: output.qos !== undefined && output.qos !== null ? output.qos : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        topic: output.topic !== undefined && output.topic !== null ? output.topic : undefined,
    };
};
const deserializeAws_restJson1ResourceArns = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const deserializeAws_restJson1ResourceIdentifier = (output, context) => {
    return {
        account: output.account !== undefined && output.account !== null ? output.account : undefined,
        caCertificateId: output.caCertificateId !== undefined && output.caCertificateId !== null ? output.caCertificateId : undefined,
        clientId: output.clientId !== undefined && output.clientId !== null ? output.clientId : undefined,
        cognitoIdentityPoolId: output.cognitoIdentityPoolId !== undefined && output.cognitoIdentityPoolId !== null
            ? output.cognitoIdentityPoolId
            : undefined,
        deviceCertificateId: output.deviceCertificateId !== undefined && output.deviceCertificateId !== null
            ? output.deviceCertificateId
            : undefined,
        iamRoleArn: output.iamRoleArn !== undefined && output.iamRoleArn !== null ? output.iamRoleArn : undefined,
        policyVersionIdentifier: output.policyVersionIdentifier !== undefined && output.policyVersionIdentifier !== null
            ? deserializeAws_restJson1PolicyVersionIdentifier(output.policyVersionIdentifier, context)
            : undefined,
        roleAliasArn: output.roleAliasArn !== undefined && output.roleAliasArn !== null ? output.roleAliasArn : undefined,
    };
};
const deserializeAws_restJson1Resources = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1RoleAliasDescription = (output, context) => {
    return {
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        credentialDurationSeconds: output.credentialDurationSeconds !== undefined && output.credentialDurationSeconds !== null
            ? output.credentialDurationSeconds
            : undefined,
        lastModifiedDate: output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
            ? new Date(Math.round(output.lastModifiedDate * 1000))
            : undefined,
        owner: output.owner !== undefined && output.owner !== null ? output.owner : undefined,
        roleAlias: output.roleAlias !== undefined && output.roleAlias !== null ? output.roleAlias : undefined,
        roleAliasArn: output.roleAliasArn !== undefined && output.roleAliasArn !== null ? output.roleAliasArn : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1RoleAliases = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1S3Action = (output, context) => {
    return {
        bucketName: output.bucketName !== undefined && output.bucketName !== null ? output.bucketName : undefined,
        cannedAcl: output.cannedAcl !== undefined && output.cannedAcl !== null ? output.cannedAcl : undefined,
        key: output.key !== undefined && output.key !== null ? output.key : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
    };
};
const deserializeAws_restJson1S3Destination = (output, context) => {
    return {
        bucket: output.bucket !== undefined && output.bucket !== null ? output.bucket : undefined,
        prefix: output.prefix !== undefined && output.prefix !== null ? output.prefix : undefined,
    };
};
const deserializeAws_restJson1S3FileUrlList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1S3Location = (output, context) => {
    return {
        bucket: output.bucket !== undefined && output.bucket !== null ? output.bucket : undefined,
        key: output.key !== undefined && output.key !== null ? output.key : undefined,
        version: output.version !== undefined && output.version !== null ? output.version : undefined,
    };
};
const deserializeAws_restJson1SalesforceAction = (output, context) => {
    return {
        token: output.token !== undefined && output.token !== null ? output.token : undefined,
        url: output.url !== undefined && output.url !== null ? output.url : undefined,
    };
};
const deserializeAws_restJson1ScheduledAuditMetadata = (output, context) => {
    return {
        dayOfMonth: output.dayOfMonth !== undefined && output.dayOfMonth !== null ? output.dayOfMonth : undefined,
        dayOfWeek: output.dayOfWeek !== undefined && output.dayOfWeek !== null ? output.dayOfWeek : undefined,
        frequency: output.frequency !== undefined && output.frequency !== null ? output.frequency : undefined,
        scheduledAuditArn: output.scheduledAuditArn !== undefined && output.scheduledAuditArn !== null
            ? output.scheduledAuditArn
            : undefined,
        scheduledAuditName: output.scheduledAuditName !== undefined && output.scheduledAuditName !== null
            ? output.scheduledAuditName
            : undefined,
    };
};
const deserializeAws_restJson1ScheduledAuditMetadataList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ScheduledAuditMetadata(entry, context);
    });
};
const deserializeAws_restJson1SearchableAttributes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1SecurityProfileIdentifier = (output, context) => {
    return {
        arn: output.arn !== undefined && output.arn !== null ? output.arn : undefined,
        name: output.name !== undefined && output.name !== null ? output.name : undefined,
    };
};
const deserializeAws_restJson1SecurityProfileIdentifiers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1SecurityProfileIdentifier(entry, context);
    });
};
const deserializeAws_restJson1SecurityProfileTarget = (output, context) => {
    return {
        arn: output.arn !== undefined && output.arn !== null ? output.arn : undefined,
    };
};
const deserializeAws_restJson1SecurityProfileTargetMapping = (output, context) => {
    return {
        securityProfileIdentifier: output.securityProfileIdentifier !== undefined && output.securityProfileIdentifier !== null
            ? deserializeAws_restJson1SecurityProfileIdentifier(output.securityProfileIdentifier, context)
            : undefined,
        target: output.target !== undefined && output.target !== null
            ? deserializeAws_restJson1SecurityProfileTarget(output.target, context)
            : undefined,
    };
};
const deserializeAws_restJson1SecurityProfileTargetMappings = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1SecurityProfileTargetMapping(entry, context);
    });
};
const deserializeAws_restJson1SecurityProfileTargets = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1SecurityProfileTarget(entry, context);
    });
};
const deserializeAws_restJson1ServerCertificates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ServerCertificateSummary(entry, context);
    });
};
const deserializeAws_restJson1ServerCertificateSummary = (output, context) => {
    return {
        serverCertificateArn: output.serverCertificateArn !== undefined && output.serverCertificateArn !== null
            ? output.serverCertificateArn
            : undefined,
        serverCertificateStatus: output.serverCertificateStatus !== undefined && output.serverCertificateStatus !== null
            ? output.serverCertificateStatus
            : undefined,
        serverCertificateStatusDetail: output.serverCertificateStatusDetail !== undefined && output.serverCertificateStatusDetail !== null
            ? output.serverCertificateStatusDetail
            : undefined,
    };
};
const deserializeAws_restJson1SigningProfileParameter = (output, context) => {
    return {
        certificateArn: output.certificateArn !== undefined && output.certificateArn !== null ? output.certificateArn : undefined,
        certificatePathOnDevice: output.certificatePathOnDevice !== undefined && output.certificatePathOnDevice !== null
            ? output.certificatePathOnDevice
            : undefined,
        platform: output.platform !== undefined && output.platform !== null ? output.platform : undefined,
    };
};
const deserializeAws_restJson1SigV4Authorization = (output, context) => {
    return {
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        serviceName: output.serviceName !== undefined && output.serviceName !== null ? output.serviceName : undefined,
        signingRegion: output.signingRegion !== undefined && output.signingRegion !== null ? output.signingRegion : undefined,
    };
};
const deserializeAws_restJson1SnsAction = (output, context) => {
    return {
        messageFormat: output.messageFormat !== undefined && output.messageFormat !== null ? output.messageFormat : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        targetArn: output.targetArn !== undefined && output.targetArn !== null ? output.targetArn : undefined,
    };
};
const deserializeAws_restJson1SqsAction = (output, context) => {
    return {
        queueUrl: output.queueUrl !== undefined && output.queueUrl !== null ? output.queueUrl : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        useBase64: output.useBase64 !== undefined && output.useBase64 !== null ? output.useBase64 : undefined,
    };
};
const deserializeAws_restJson1StartSigningJobParameter = (output, context) => {
    return {
        destination: output.destination !== undefined && output.destination !== null
            ? deserializeAws_restJson1Destination(output.destination, context)
            : undefined,
        signingProfileName: output.signingProfileName !== undefined && output.signingProfileName !== null
            ? output.signingProfileName
            : undefined,
        signingProfileParameter: output.signingProfileParameter !== undefined && output.signingProfileParameter !== null
            ? deserializeAws_restJson1SigningProfileParameter(output.signingProfileParameter, context)
            : undefined,
    };
};
const deserializeAws_restJson1StatisticalThreshold = (output, context) => {
    return {
        statistic: output.statistic !== undefined && output.statistic !== null ? output.statistic : undefined,
    };
};
const deserializeAws_restJson1Statistics = (output, context) => {
    return {
        average: output.average !== undefined && output.average !== null ? output.average : undefined,
        count: output.count !== undefined && output.count !== null ? output.count : undefined,
        maximum: output.maximum !== undefined && output.maximum !== null ? output.maximum : undefined,
        minimum: output.minimum !== undefined && output.minimum !== null ? output.minimum : undefined,
        stdDeviation: output.stdDeviation !== undefined && output.stdDeviation !== null ? output.stdDeviation : undefined,
        sum: output.sum !== undefined && output.sum !== null ? output.sum : undefined,
        sumOfSquares: output.sumOfSquares !== undefined && output.sumOfSquares !== null ? output.sumOfSquares : undefined,
        variance: output.variance !== undefined && output.variance !== null ? output.variance : undefined,
    };
};
const deserializeAws_restJson1StepFunctionsAction = (output, context) => {
    return {
        executionNamePrefix: output.executionNamePrefix !== undefined && output.executionNamePrefix !== null
            ? output.executionNamePrefix
            : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        stateMachineName: output.stateMachineName !== undefined && output.stateMachineName !== null ? output.stateMachineName : undefined,
    };
};
const deserializeAws_restJson1_Stream = (output, context) => {
    return {
        fileId: output.fileId !== undefined && output.fileId !== null ? output.fileId : undefined,
        streamId: output.streamId !== undefined && output.streamId !== null ? output.streamId : undefined,
    };
};
const deserializeAws_restJson1StreamFile = (output, context) => {
    return {
        fileId: output.fileId !== undefined && output.fileId !== null ? output.fileId : undefined,
        s3Location: output.s3Location !== undefined && output.s3Location !== null
            ? deserializeAws_restJson1S3Location(output.s3Location, context)
            : undefined,
    };
};
const deserializeAws_restJson1StreamFiles = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1StreamFile(entry, context);
    });
};
const deserializeAws_restJson1StreamInfo = (output, context) => {
    return {
        createdAt: output.createdAt !== undefined && output.createdAt !== null
            ? new Date(Math.round(output.createdAt * 1000))
            : undefined,
        description: output.description !== undefined && output.description !== null ? output.description : undefined,
        files: output.files !== undefined && output.files !== null
            ? deserializeAws_restJson1StreamFiles(output.files, context)
            : undefined,
        lastUpdatedAt: output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
            ? new Date(Math.round(output.lastUpdatedAt * 1000))
            : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        streamArn: output.streamArn !== undefined && output.streamArn !== null ? output.streamArn : undefined,
        streamId: output.streamId !== undefined && output.streamId !== null ? output.streamId : undefined,
        streamVersion: output.streamVersion !== undefined && output.streamVersion !== null ? output.streamVersion : undefined,
    };
};
const deserializeAws_restJson1StreamsSummary = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1StreamSummary(entry, context);
    });
};
const deserializeAws_restJson1StreamSummary = (output, context) => {
    return {
        description: output.description !== undefined && output.description !== null ? output.description : undefined,
        streamArn: output.streamArn !== undefined && output.streamArn !== null ? output.streamArn : undefined,
        streamId: output.streamId !== undefined && output.streamId !== null ? output.streamId : undefined,
        streamVersion: output.streamVersion !== undefined && output.streamVersion !== null ? output.streamVersion : undefined,
    };
};
const deserializeAws_restJson1StringMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const deserializeAws_restJson1Tag = (output, context) => {
    return {
        Key: output.Key !== undefined && output.Key !== null ? output.Key : undefined,
        Value: output.Value !== undefined && output.Value !== null ? output.Value : undefined,
    };
};
const deserializeAws_restJson1TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Tag(entry, context);
    });
};
const deserializeAws_restJson1TargetAuditCheckNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1Targets = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1TaskIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1TaskStatistics = (output, context) => {
    return {
        canceledChecks: output.canceledChecks !== undefined && output.canceledChecks !== null ? output.canceledChecks : undefined,
        compliantChecks: output.compliantChecks !== undefined && output.compliantChecks !== null ? output.compliantChecks : undefined,
        failedChecks: output.failedChecks !== undefined && output.failedChecks !== null ? output.failedChecks : undefined,
        inProgressChecks: output.inProgressChecks !== undefined && output.inProgressChecks !== null ? output.inProgressChecks : undefined,
        nonCompliantChecks: output.nonCompliantChecks !== undefined && output.nonCompliantChecks !== null
            ? output.nonCompliantChecks
            : undefined,
        totalChecks: output.totalChecks !== undefined && output.totalChecks !== null ? output.totalChecks : undefined,
        waitingForDataCollectionChecks: output.waitingForDataCollectionChecks !== undefined && output.waitingForDataCollectionChecks !== null
            ? output.waitingForDataCollectionChecks
            : undefined,
    };
};
const deserializeAws_restJson1TaskStatisticsForAuditCheck = (output, context) => {
    return {
        canceledFindingsCount: output.canceledFindingsCount !== undefined && output.canceledFindingsCount !== null
            ? output.canceledFindingsCount
            : undefined,
        failedFindingsCount: output.failedFindingsCount !== undefined && output.failedFindingsCount !== null
            ? output.failedFindingsCount
            : undefined,
        skippedFindingsCount: output.skippedFindingsCount !== undefined && output.skippedFindingsCount !== null
            ? output.skippedFindingsCount
            : undefined,
        succeededFindingsCount: output.succeededFindingsCount !== undefined && output.succeededFindingsCount !== null
            ? output.succeededFindingsCount
            : undefined,
        totalFindingsCount: output.totalFindingsCount !== undefined && output.totalFindingsCount !== null
            ? output.totalFindingsCount
            : undefined,
    };
};
const deserializeAws_restJson1ThingAttribute = (output, context) => {
    return {
        attributes: output.attributes !== undefined && output.attributes !== null
            ? deserializeAws_restJson1Attributes(output.attributes, context)
            : undefined,
        thingArn: output.thingArn !== undefined && output.thingArn !== null ? output.thingArn : undefined,
        thingName: output.thingName !== undefined && output.thingName !== null ? output.thingName : undefined,
        thingTypeName: output.thingTypeName !== undefined && output.thingTypeName !== null ? output.thingTypeName : undefined,
        version: output.version !== undefined && output.version !== null ? output.version : undefined,
    };
};
const deserializeAws_restJson1ThingAttributeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ThingAttribute(entry, context);
    });
};
const deserializeAws_restJson1ThingConnectivity = (output, context) => {
    return {
        connected: output.connected !== undefined && output.connected !== null ? output.connected : undefined,
        timestamp: output.timestamp !== undefined && output.timestamp !== null ? output.timestamp : undefined,
    };
};
const deserializeAws_restJson1ThingDocument = (output, context) => {
    return {
        attributes: output.attributes !== undefined && output.attributes !== null
            ? deserializeAws_restJson1Attributes(output.attributes, context)
            : undefined,
        connectivity: output.connectivity !== undefined && output.connectivity !== null
            ? deserializeAws_restJson1ThingConnectivity(output.connectivity, context)
            : undefined,
        shadow: output.shadow !== undefined && output.shadow !== null ? output.shadow : undefined,
        thingGroupNames: output.thingGroupNames !== undefined && output.thingGroupNames !== null
            ? deserializeAws_restJson1ThingGroupNameList(output.thingGroupNames, context)
            : undefined,
        thingId: output.thingId !== undefined && output.thingId !== null ? output.thingId : undefined,
        thingName: output.thingName !== undefined && output.thingName !== null ? output.thingName : undefined,
        thingTypeName: output.thingTypeName !== undefined && output.thingTypeName !== null ? output.thingTypeName : undefined,
    };
};
const deserializeAws_restJson1ThingDocumentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ThingDocument(entry, context);
    });
};
const deserializeAws_restJson1ThingGroupDocument = (output, context) => {
    return {
        attributes: output.attributes !== undefined && output.attributes !== null
            ? deserializeAws_restJson1Attributes(output.attributes, context)
            : undefined,
        parentGroupNames: output.parentGroupNames !== undefined && output.parentGroupNames !== null
            ? deserializeAws_restJson1ThingGroupNameList(output.parentGroupNames, context)
            : undefined,
        thingGroupDescription: output.thingGroupDescription !== undefined && output.thingGroupDescription !== null
            ? output.thingGroupDescription
            : undefined,
        thingGroupId: output.thingGroupId !== undefined && output.thingGroupId !== null ? output.thingGroupId : undefined,
        thingGroupName: output.thingGroupName !== undefined && output.thingGroupName !== null ? output.thingGroupName : undefined,
    };
};
const deserializeAws_restJson1ThingGroupDocumentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ThingGroupDocument(entry, context);
    });
};
const deserializeAws_restJson1ThingGroupIndexingConfiguration = (output, context) => {
    return {
        customFields: output.customFields !== undefined && output.customFields !== null
            ? deserializeAws_restJson1Fields(output.customFields, context)
            : undefined,
        managedFields: output.managedFields !== undefined && output.managedFields !== null
            ? deserializeAws_restJson1Fields(output.managedFields, context)
            : undefined,
        thingGroupIndexingMode: output.thingGroupIndexingMode !== undefined && output.thingGroupIndexingMode !== null
            ? output.thingGroupIndexingMode
            : undefined,
    };
};
const deserializeAws_restJson1ThingGroupMetadata = (output, context) => {
    return {
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        parentGroupName: output.parentGroupName !== undefined && output.parentGroupName !== null ? output.parentGroupName : undefined,
        rootToParentThingGroups: output.rootToParentThingGroups !== undefined && output.rootToParentThingGroups !== null
            ? deserializeAws_restJson1ThingGroupNameAndArnList(output.rootToParentThingGroups, context)
            : undefined,
    };
};
const deserializeAws_restJson1ThingGroupNameAndArnList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1GroupNameAndArn(entry, context);
    });
};
const deserializeAws_restJson1ThingGroupNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1ThingGroupNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1ThingGroupProperties = (output, context) => {
    return {
        attributePayload: output.attributePayload !== undefined && output.attributePayload !== null
            ? deserializeAws_restJson1AttributePayload(output.attributePayload, context)
            : undefined,
        thingGroupDescription: output.thingGroupDescription !== undefined && output.thingGroupDescription !== null
            ? output.thingGroupDescription
            : undefined,
    };
};
const deserializeAws_restJson1ThingIndexingConfiguration = (output, context) => {
    return {
        customFields: output.customFields !== undefined && output.customFields !== null
            ? deserializeAws_restJson1Fields(output.customFields, context)
            : undefined,
        managedFields: output.managedFields !== undefined && output.managedFields !== null
            ? deserializeAws_restJson1Fields(output.managedFields, context)
            : undefined,
        thingConnectivityIndexingMode: output.thingConnectivityIndexingMode !== undefined && output.thingConnectivityIndexingMode !== null
            ? output.thingConnectivityIndexingMode
            : undefined,
        thingIndexingMode: output.thingIndexingMode !== undefined && output.thingIndexingMode !== null
            ? output.thingIndexingMode
            : undefined,
    };
};
const deserializeAws_restJson1ThingNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const deserializeAws_restJson1ThingTypeDefinition = (output, context) => {
    return {
        thingTypeArn: output.thingTypeArn !== undefined && output.thingTypeArn !== null ? output.thingTypeArn : undefined,
        thingTypeMetadata: output.thingTypeMetadata !== undefined && output.thingTypeMetadata !== null
            ? deserializeAws_restJson1ThingTypeMetadata(output.thingTypeMetadata, context)
            : undefined,
        thingTypeName: output.thingTypeName !== undefined && output.thingTypeName !== null ? output.thingTypeName : undefined,
        thingTypeProperties: output.thingTypeProperties !== undefined && output.thingTypeProperties !== null
            ? deserializeAws_restJson1ThingTypeProperties(output.thingTypeProperties, context)
            : undefined,
    };
};
const deserializeAws_restJson1ThingTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ThingTypeDefinition(entry, context);
    });
};
const deserializeAws_restJson1ThingTypeMetadata = (output, context) => {
    return {
        creationDate: output.creationDate !== undefined && output.creationDate !== null
            ? new Date(Math.round(output.creationDate * 1000))
            : undefined,
        deprecated: output.deprecated !== undefined && output.deprecated !== null ? output.deprecated : undefined,
        deprecationDate: output.deprecationDate !== undefined && output.deprecationDate !== null
            ? new Date(Math.round(output.deprecationDate * 1000))
            : undefined,
    };
};
const deserializeAws_restJson1ThingTypeProperties = (output, context) => {
    return {
        searchableAttributes: output.searchableAttributes !== undefined && output.searchableAttributes !== null
            ? deserializeAws_restJson1SearchableAttributes(output.searchableAttributes, context)
            : undefined,
        thingTypeDescription: output.thingTypeDescription !== undefined && output.thingTypeDescription !== null
            ? output.thingTypeDescription
            : undefined,
    };
};
const deserializeAws_restJson1TimeoutConfig = (output, context) => {
    return {
        inProgressTimeoutInMinutes: output.inProgressTimeoutInMinutes !== undefined && output.inProgressTimeoutInMinutes !== null
            ? output.inProgressTimeoutInMinutes
            : undefined,
    };
};
const deserializeAws_restJson1TimestreamAction = (output, context) => {
    return {
        databaseName: output.databaseName !== undefined && output.databaseName !== null ? output.databaseName : undefined,
        dimensions: output.dimensions !== undefined && output.dimensions !== null
            ? deserializeAws_restJson1TimestreamDimensionList(output.dimensions, context)
            : undefined,
        roleArn: output.roleArn !== undefined && output.roleArn !== null ? output.roleArn : undefined,
        tableName: output.tableName !== undefined && output.tableName !== null ? output.tableName : undefined,
        timestamp: output.timestamp !== undefined && output.timestamp !== null
            ? deserializeAws_restJson1TimestreamTimestamp(output.timestamp, context)
            : undefined,
    };
};
const deserializeAws_restJson1TimestreamDimension = (output, context) => {
    return {
        name: output.name !== undefined && output.name !== null ? output.name : undefined,
        value: output.value !== undefined && output.value !== null ? output.value : undefined,
    };
};
const deserializeAws_restJson1TimestreamDimensionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1TimestreamDimension(entry, context);
    });
};
const deserializeAws_restJson1TimestreamTimestamp = (output, context) => {
    return {
        unit: output.unit !== undefined && output.unit !== null ? output.unit : undefined,
        value: output.value !== undefined && output.value !== null ? output.value : undefined,
    };
};
const deserializeAws_restJson1TopicRule = (output, context) => {
    return {
        actions: output.actions !== undefined && output.actions !== null
            ? deserializeAws_restJson1ActionList(output.actions, context)
            : undefined,
        awsIotSqlVersion: output.awsIotSqlVersion !== undefined && output.awsIotSqlVersion !== null ? output.awsIotSqlVersion : undefined,
        createdAt: output.createdAt !== undefined && output.createdAt !== null
            ? new Date(Math.round(output.createdAt * 1000))
            : undefined,
        description: output.description !== undefined && output.description !== null ? output.description : undefined,
        errorAction: output.errorAction !== undefined && output.errorAction !== null
            ? deserializeAws_restJson1Action(output.errorAction, context)
            : undefined,
        ruleDisabled: output.ruleDisabled !== undefined && output.ruleDisabled !== null ? output.ruleDisabled : undefined,
        ruleName: output.ruleName !== undefined && output.ruleName !== null ? output.ruleName : undefined,
        sql: output.sql !== undefined && output.sql !== null ? output.sql : undefined,
    };
};
const deserializeAws_restJson1TopicRuleDestination = (output, context) => {
    return {
        arn: output.arn !== undefined && output.arn !== null ? output.arn : undefined,
        httpUrlProperties: output.httpUrlProperties !== undefined && output.httpUrlProperties !== null
            ? deserializeAws_restJson1HttpUrlDestinationProperties(output.httpUrlProperties, context)
            : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
        statusReason: output.statusReason !== undefined && output.statusReason !== null ? output.statusReason : undefined,
    };
};
const deserializeAws_restJson1TopicRuleDestinationSummaries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1TopicRuleDestinationSummary(entry, context);
    });
};
const deserializeAws_restJson1TopicRuleDestinationSummary = (output, context) => {
    return {
        arn: output.arn !== undefined && output.arn !== null ? output.arn : undefined,
        httpUrlSummary: output.httpUrlSummary !== undefined && output.httpUrlSummary !== null
            ? deserializeAws_restJson1HttpUrlDestinationSummary(output.httpUrlSummary, context)
            : undefined,
        status: output.status !== undefined && output.status !== null ? output.status : undefined,
        statusReason: output.statusReason !== undefined && output.statusReason !== null ? output.statusReason : undefined,
    };
};
const deserializeAws_restJson1TopicRuleList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1TopicRuleListItem(entry, context);
    });
};
const deserializeAws_restJson1TopicRuleListItem = (output, context) => {
    return {
        createdAt: output.createdAt !== undefined && output.createdAt !== null
            ? new Date(Math.round(output.createdAt * 1000))
            : undefined,
        ruleArn: output.ruleArn !== undefined && output.ruleArn !== null ? output.ruleArn : undefined,
        ruleDisabled: output.ruleDisabled !== undefined && output.ruleDisabled !== null ? output.ruleDisabled : undefined,
        ruleName: output.ruleName !== undefined && output.ruleName !== null ? output.ruleName : undefined,
        topicPattern: output.topicPattern !== undefined && output.topicPattern !== null ? output.topicPattern : undefined,
    };
};
const deserializeAws_restJson1TransferData = (output, context) => {
    return {
        acceptDate: output.acceptDate !== undefined && output.acceptDate !== null
            ? new Date(Math.round(output.acceptDate * 1000))
            : undefined,
        rejectDate: output.rejectDate !== undefined && output.rejectDate !== null
            ? new Date(Math.round(output.rejectDate * 1000))
            : undefined,
        rejectReason: output.rejectReason !== undefined && output.rejectReason !== null ? output.rejectReason : undefined,
        transferDate: output.transferDate !== undefined && output.transferDate !== null
            ? new Date(Math.round(output.transferDate * 1000))
            : undefined,
        transferMessage: output.transferMessage !== undefined && output.transferMessage !== null ? output.transferMessage : undefined,
    };
};
const deserializeAws_restJson1UpdateCACertificateParams = (output, context) => {
    return {
        action: output.action !== undefined && output.action !== null ? output.action : undefined,
    };
};
const deserializeAws_restJson1UpdateDeviceCertificateParams = (output, context) => {
    return {
        action: output.action !== undefined && output.action !== null ? output.action : undefined,
    };
};
const deserializeAws_restJson1ValidationError = (output, context) => {
    return {
        errorMessage: output.errorMessage !== undefined && output.errorMessage !== null ? output.errorMessage : undefined,
    };
};
const deserializeAws_restJson1ValidationErrors = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ValidationError(entry, context);
    });
};
const deserializeAws_restJson1ViolationEvent = (output, context) => {
    return {
        behavior: output.behavior !== undefined && output.behavior !== null
            ? deserializeAws_restJson1Behavior(output.behavior, context)
            : undefined,
        metricValue: output.metricValue !== undefined && output.metricValue !== null
            ? deserializeAws_restJson1MetricValue(output.metricValue, context)
            : undefined,
        securityProfileName: output.securityProfileName !== undefined && output.securityProfileName !== null
            ? output.securityProfileName
            : undefined,
        thingName: output.thingName !== undefined && output.thingName !== null ? output.thingName : undefined,
        violationEventTime: output.violationEventTime !== undefined && output.violationEventTime !== null
            ? new Date(Math.round(output.violationEventTime * 1000))
            : undefined,
        violationEventType: output.violationEventType !== undefined && output.violationEventType !== null
            ? output.violationEventType
            : undefined,
        violationId: output.violationId !== undefined && output.violationId !== null ? output.violationId : undefined,
    };
};
const deserializeAws_restJson1ViolationEvents = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ViolationEvent(entry, context);
    });
};
const deserializeMetadata = (output) => {
    var _a;
    return ({
        httpStatusCode: output.statusCode,
        requestId: (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
};
// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
    return "";
};
//# sourceMappingURL=Aws_restJson1.js.map